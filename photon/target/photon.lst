
d:/Devel/findybot/photon/target/photon.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00006e28  080a0018  080a0018  00010018  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .backup       00000004  40024000  080a6e40  00024000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .data         000001f0  20000300  080a6e44  00030300  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00001050  200004f0  200004f0  000404f0  2**2
                  ALLOC
  5 .module_info_suffix 00000028  080a7034  080a7034  00037034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .module_info_crc 00000004  080a705c  080a705c  0003705c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .debug_info   000c10a9  00000000  00000000  00037060  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000116b7  00000000  00000000  000f8109  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0001943d  00000000  00000000  001097c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 000023a0  00000000  00000000  00122bfd  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00003de8  00000000  00000000  00124f9d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0002821c  00000000  00000000  00128d85  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   000288e7  00000000  00000000  00150fa1  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000a0cfd  00000000  00000000  00179888  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  0000c8ec  00000000  00000000  0021a588  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a0018 <user_part_module>:
 80a0018:	38 5f 0a 08                                         8_..

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <module_user_pre_init+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <module_user_pre_init+0x2c>)
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <module_user_pre_init+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f005 fdb3 	bl	80a5b98 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <module_user_pre_init+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <module_user_pre_init+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f005 fdb8 	bl	80a5bae <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <module_user_pre_init+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000300 	.word	0x20000300
 80a0048:	080a6e44 	.word	0x080a6e44
 80a004c:	200004f0 	.word	0x200004f0
 80a0050:	200004f0 	.word	0x200004f0
 80a0054:	20001540 	.word	0x20001540
 80a0058:	20001540 	.word	0x20001540

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f003 ffa1 	bl	80a3fa4 <module_user_init_hook>
 80a0062:	4b07      	ldr	r3, [pc, #28]	; (80a0080 <module_user_init+0x24>)
 80a0064:	4c07      	ldr	r4, [pc, #28]	; (80a0084 <module_user_init+0x28>)
 80a0066:	461e      	mov	r6, r3
 80a0068:	1ae4      	subs	r4, r4, r3
 80a006a:	08a4      	lsrs	r4, r4, #2

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a006c:	2500      	movs	r5, #0
 80a006e:	42a5      	cmp	r5, r4
 80a0070:	d004      	beq.n	80a007c <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
 80a0072:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80a0076:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f8      	b.n	80a006e <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a007c:	bd70      	pop	{r4, r5, r6, pc}
 80a007e:	bf00      	nop
 80a0080:	080a6e00 	.word	0x080a6e00
 80a0084:	080a6e40 	.word	0x080a6e40

080a0088 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0088:	f000 b98c 	b.w	80a03a4 <setup>

080a008c <module_user_loop>:
}

void module_user_loop() {
 80a008c:	b508      	push	{r3, lr}
    loop();
 80a008e:	f000 f8b5 	bl	80a01fc <loop>
    _post_loop();
}
 80a0092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
 80a0096:	f003 bf47 	b.w	80a3f28 <_post_loop>

080a009a <_Znwj>:
 80a009a:	f003 bcc5 	b.w	80a3a28 <malloc>

080a009e <_ZdlPv>:
 80a009e:	f003 bccb 	b.w	80a3a38 <free>
	...

080a00a4 <__cxa_pure_virtual>:
        ;
    }
}

/* Default implementation for call made to pure virtual function. */
void __cxa_pure_virtual() {
 80a00a4:	b508      	push	{r3, lr}
  PANIC(PureVirtualCall,"Call on pure virtual");
 80a00a6:	4a03      	ldr	r2, [pc, #12]	; (80a00b4 <__cxa_pure_virtual+0x10>)
 80a00a8:	2100      	movs	r1, #0
 80a00aa:	200c      	movs	r0, #12
 80a00ac:	f003 fc60 	bl	80a3970 <panic_>
 80a00b0:	e7fe      	b.n	80a00b0 <__cxa_pure_virtual+0xc>
 80a00b2:	bf00      	nop
 80a00b4:	080a37bd 	.word	0x080a37bd

080a00b8 <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a00b8:	7800      	ldrb	r0, [r0, #0]
 80a00ba:	fab0 f080 	clz	r0, r0
 80a00be:	0940      	lsrs	r0, r0, #5
 80a00c0:	4770      	bx	lr

080a00c2 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00c2:	2301      	movs	r3, #1
 80a00c4:	7003      	strb	r3, [r0, #0]
 80a00c6:	4770      	bx	lr

080a00c8 <_ZN11ArduinoJson16StaticJsonBufferILj3000EED1Ev>:

// Implements a JsonBuffer with fixed memory allocation.
// The template paramenter CAPACITY specifies the capacity of the buffer in
// bytes.
template <size_t CAPACITY>
class StaticJsonBuffer : public Internals::StaticJsonBufferBase {
 80a00c8:	4770      	bx	lr
	...

080a00cc <_Z12changeColorsPKc>:
{
  callAzureFunction(HowMany, data);
}

void changeColors(const char *data)
{
 80a00cc:	b5b0      	push	{r4, r5, r7, lr}
  if (data == NULL) return;
 80a00ce:	4605      	mov	r5, r0
{
  callAzureFunction(HowMany, data);
}

void changeColors(const char *data)
{
 80a00d0:	af00      	add	r7, sp, #0
  int len = strlen(data)+1;
  char buff[len];
  memcpy(buff, data, len);

  char *token = strtok(buff, " to ");
  if (token == NULL) return;
 80a00d2:	466c      	mov	r4, sp
  callAzureFunction(HowMany, data);
}

void changeColors(const char *data)
{
  if (data == NULL) return;
 80a00d4:	b180      	cbz	r0, 80a00f8 <_Z12changeColorsPKc+0x2c>

  int len = strlen(data)+1;
 80a00d6:	f005 fe12 	bl	80a5cfe <strlen>
  char buff[len];
 80a00da:	f100 0308 	add.w	r3, r0, #8
 80a00de:	f023 0307 	bic.w	r3, r3, #7
 80a00e2:	ebad 0d03 	sub.w	sp, sp, r3
  memcpy(buff, data, len);
 80a00e6:	1c42      	adds	r2, r0, #1
 80a00e8:	4629      	mov	r1, r5
 80a00ea:	4668      	mov	r0, sp
 80a00ec:	f005 fd54 	bl	80a5b98 <memcpy>

  char *token = strtok(buff, " to ");
 80a00f0:	4903      	ldr	r1, [pc, #12]	; (80a0100 <_Z12changeColorsPKc+0x34>)
 80a00f2:	4668      	mov	r0, sp
 80a00f4:	f005 fe26 	bl	80a5d44 <strtok>
  callAzureFunction(HowMany, data);
}

void changeColors(const char *data)
{
  if (data == NULL) return;
 80a00f8:	46a5      	mov	sp, r4
      Serial.printlnf("unlikelyColor: %s", c.name);
      break;
    }
  }
  */
}
 80a00fa:	46bd      	mov	sp, r7
 80a00fc:	bdb0      	pop	{r4, r5, r7, pc}
 80a00fe:	bf00      	nop
 80a0100:	080a5f58 	.word	0x080a5f58

080a0104 <_Z13setBrightnessPKc>:
  }
}

// Set the brightness of the LED matrix, from 1 to 100, inclusive
void setBrightness(const char *data)
{
 80a0104:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if (data == NULL) return;
 80a0106:	4601      	mov	r1, r0
 80a0108:	b150      	cbz	r0, 80a0120 <_Z13setBrightnessPKc+0x1c>

  String brightnessText = data;
 80a010a:	4668      	mov	r0, sp
 80a010c:	f003 fd4b 	bl	80a3ba6 <_ZN6StringC1EPK19__FlashStringHelper>
  int brightness = brightnessText.toInt();
 80a0110:	4668      	mov	r0, sp
 80a0112:	f003 fdb4 	bl	80a3c7e <_ZNK6String5toIntEv>

  GFX_setBrightness(brightness);
 80a0116:	f002 fdeb 	bl	80a2cf0 <_Z17GFX_setBrightnessi>
// Set the brightness of the LED matrix, from 1 to 100, inclusive
void setBrightness(const char *data)
{
  if (data == NULL) return;

  String brightnessText = data;
 80a011a:	4668      	mov	r0, sp
 80a011c:	f003 fcfc 	bl	80a3b18 <_ZN6StringD1Ev>
  int brightness = brightnessText.toInt();

  GFX_setBrightness(brightness);
}
 80a0120:	b005      	add	sp, #20
 80a0122:	f85d fb04 	ldr.w	pc, [sp], #4

080a0126 <_ZN11ArduinoJson9Internals20StaticJsonBufferBase5allocEj>:

  // Preserve aligment if necessary
  static FORCE_INLINE size_t round_size_up(size_t bytes) {
#if ARDUINOJSON_ENABLE_ALIGNMENT
    const size_t x = sizeof(void *) - 1;
    return (bytes + x) & ~x;
 80a0126:	68c3      	ldr	r3, [r0, #12]
  }

  // Allocates the specified amount of bytes in the buffer
  virtual void* alloc(size_t bytes) {
    alignNextAlloc();
    if (!canAlloc(bytes)) return NULL;
 80a0128:	6882      	ldr	r2, [r0, #8]
 80a012a:	3303      	adds	r3, #3
 80a012c:	f023 0303 	bic.w	r3, r3, #3
  void alignNextAlloc() {
    _size = round_size_up(_size);
  }

  bool canAlloc(size_t bytes) const {
    return _size + bytes <= _capacity;
 80a0130:	4419      	add	r1, r3
  }

  // Allocates the specified amount of bytes in the buffer
  virtual void* alloc(size_t bytes) {
    alignNextAlloc();
    if (!canAlloc(bytes)) return NULL;
 80a0132:	4291      	cmp	r1, r2
  bool canAlloc(size_t bytes) const {
    return _size + bytes <= _capacity;
  }

  void* doAlloc(size_t bytes) {
    void* p = &_buffer[_size];
 80a0134:	bf98      	it	ls
 80a0136:	6842      	ldrls	r2, [r0, #4]
 protected:
  ~StaticJsonBufferBase() {}

 private:
  void alignNextAlloc() {
    _size = round_size_up(_size);
 80a0138:	60c3      	str	r3, [r0, #12]
    return _size + bytes <= _capacity;
  }

  void* doAlloc(size_t bytes) {
    void* p = &_buffer[_size];
    _size += bytes;
 80a013a:	bf9a      	itte	ls
 80a013c:	60c1      	strls	r1, [r0, #12]

  // Allocates the specified amount of bytes in the buffer
  virtual void* alloc(size_t bytes) {
    alignNextAlloc();
    if (!canAlloc(bytes)) return NULL;
    return doAlloc(bytes);
 80a013e:	18d0      	addls	r0, r2, r3
  }

  // Allocates the specified amount of bytes in the buffer
  virtual void* alloc(size_t bytes) {
    alignNextAlloc();
    if (!canAlloc(bytes)) return NULL;
 80a0140:	2000      	movhi	r0, #0
    return doAlloc(bytes);
  }
 80a0142:	4770      	bx	lr

080a0144 <_Z17IFTTTEventHandlerPKcS0_>:
  { ChangeColors, changeColors },
  { Welcome, welcome }
};

void IFTTTEventHandler(const char* event, const char* data)
{
 80a0144:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80a0148:	460e      	mov	r6, r1
  if (event == NULL || data == NULL) return;
 80a014a:	4605      	mov	r5, r0
 80a014c:	b1d8      	cbz	r0, 80a0186 <_Z17IFTTTEventHandlerPKcS0_+0x42>
 80a014e:	b1d1      	cbz	r1, 80a0186 <_Z17IFTTTEventHandlerPKcS0_+0x42>

  Serial.printlnf("IFTTTEventHandler event: %s, data: %s", event, data);
 80a0150:	f004 fa5a 	bl	80a4608 <_Z16_fetch_usbserialv>
    }

    template <typename... Args>
    inline size_t printlnf(const char* format, Args... args)
    {
        return this->printf_impl(true, format, args...);
 80a0154:	9600      	str	r6, [sp, #0]
 80a0156:	462b      	mov	r3, r5
 80a0158:	4a0c      	ldr	r2, [pc, #48]	; (80a018c <_Z17IFTTTEventHandlerPKcS0_+0x48>)
 80a015a:	2101      	movs	r1, #1
 80a015c:	f003 fe0d 	bl	80a3d7a <_ZN5Print11printf_implEbPKcz>
 80a0160:	4f0b      	ldr	r7, [pc, #44]	; (80a0190 <_Z17IFTTTEventHandlerPKcS0_+0x4c>)
 80a0162:	2400      	movs	r4, #0

  // loop through each command until a match is found; then call the associated handler
  for (CommandHandler cmd : commands) {
    if (strstr(event, cmd.command)) {
 80a0164:	59e1      	ldr	r1, [r4, r7]
 80a0166:	4628      	mov	r0, r5
 80a0168:	eb07 0804 	add.w	r8, r7, r4
 80a016c:	f005 fdcf 	bl	80a5d0e <strstr>
 80a0170:	b130      	cbz	r0, 80a0180 <_Z17IFTTTEventHandlerPKcS0_+0x3c>
      cmd.handle(data);
 80a0172:	4630      	mov	r0, r6
 80a0174:	f8d8 3004 	ldr.w	r3, [r8, #4]
      break;
    }
  }
}
 80a0178:	b002      	add	sp, #8
 80a017a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  Serial.printlnf("IFTTTEventHandler event: %s, data: %s", event, data);

  // loop through each command until a match is found; then call the associated handler
  for (CommandHandler cmd : commands) {
    if (strstr(event, cmd.command)) {
      cmd.handle(data);
 80a017e:	4718      	bx	r3
 80a0180:	3408      	adds	r4, #8
  if (event == NULL || data == NULL) return;

  Serial.printlnf("IFTTTEventHandler event: %s, data: %s", event, data);

  // loop through each command until a match is found; then call the associated handler
  for (CommandHandler cmd : commands) {
 80a0182:	2c78      	cmp	r4, #120	; 0x78
 80a0184:	d1ee      	bne.n	80a0164 <_Z17IFTTTEventHandlerPKcS0_+0x20>
    if (strstr(event, cmd.command)) {
      cmd.handle(data);
      break;
    }
  }
}
 80a0186:	b002      	add	sp, #8
 80a0188:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a018c:	080a5f5d 	.word	0x080a5f5d
 80a0190:	200003c4 	.word	0x200003c4

080a0194 <_ZN11ArduinoJson9Internals19JsonBufferAllocatednwEjPNS_10JsonBufferE>:
namespace ArduinoJson {
namespace Internals {

class JsonBufferAllocated {
 public:
  void *operator new(size_t n, JsonBuffer *jsonBuffer) throw() {
 80a0194:	4602      	mov	r2, r0
    if (!jsonBuffer) return NULL;
 80a0196:	4608      	mov	r0, r1
 80a0198:	b119      	cbz	r1, 80a01a2 <_ZN11ArduinoJson9Internals19JsonBufferAllocatednwEjPNS_10JsonBufferE+0xe>
    return jsonBuffer->alloc(n);
 80a019a:	680b      	ldr	r3, [r1, #0]
 80a019c:	4611      	mov	r1, r2
 80a019e:	681b      	ldr	r3, [r3, #0]
 80a01a0:	4718      	bx	r3
  }
 80a01a2:	4770      	bx	lr

080a01a4 <_ZN11ArduinoJson9JsonArray7invalidEv>:
  using Internals::List<JsonVariant>::remove;

  // Returns a reference an invalid JsonArray.
  // This object is meant to replace a NULL pointer.
  // This is used when memory allocation or JSON parsing fail.
  static JsonArray &invalid() {
 80a01a4:	b538      	push	{r3, r4, r5, lr}
    static JsonArray instance(NULL);
 80a01a6:	4d08      	ldr	r5, [pc, #32]	; (80a01c8 <_ZN11ArduinoJson9JsonArray7invalidEv+0x24>)
 80a01a8:	682b      	ldr	r3, [r5, #0]
 80a01aa:	f013 0401 	ands.w	r4, r3, #1
 80a01ae:	d109      	bne.n	80a01c4 <_ZN11ArduinoJson9JsonArray7invalidEv+0x20>
 80a01b0:	4628      	mov	r0, r5
 80a01b2:	f7ff ff81 	bl	80a00b8 <__cxa_guard_acquire>
 80a01b6:	b128      	cbz	r0, 80a01c4 <_ZN11ArduinoJson9JsonArray7invalidEv+0x20>
  // Creates an empty List<T> attached to a JsonBuffer.
  // The JsonBuffer allows to allocate new nodes.
  // When buffer is NULL, the List is not able to grow and success() returns
  // false. This is used to identify bad memory allocations and parsing
  // failures.
  explicit List(JsonBuffer *buffer) : _buffer(buffer), _firstNode(NULL) {}
 80a01b8:	4b04      	ldr	r3, [pc, #16]	; (80a01cc <_ZN11ArduinoJson9JsonArray7invalidEv+0x28>)
 80a01ba:	4628      	mov	r0, r5
 80a01bc:	601c      	str	r4, [r3, #0]
 80a01be:	605c      	str	r4, [r3, #4]
 80a01c0:	f7ff ff7f 	bl	80a00c2 <__cxa_guard_release>
    return instance;
  }
 80a01c4:	4801      	ldr	r0, [pc, #4]	; (80a01cc <_ZN11ArduinoJson9JsonArray7invalidEv+0x28>)
 80a01c6:	bd38      	pop	{r3, r4, r5, pc}
 80a01c8:	20000500 	.word	0x20000500
 80a01cc:	20000504 	.word	0x20000504

080a01d0 <_ZN11ArduinoJson10JsonObject7invalidEv>:
  using Internals::List<JsonPair>::remove;

  // Returns a reference an invalid JsonObject.
  // This object is meant to replace a NULL pointer.
  // This is used when memory allocation or JSON parsing fail.
  static JsonObject& invalid() {
 80a01d0:	b538      	push	{r3, r4, r5, lr}
    static JsonObject instance(NULL);
 80a01d2:	4d08      	ldr	r5, [pc, #32]	; (80a01f4 <_ZN11ArduinoJson10JsonObject7invalidEv+0x24>)
 80a01d4:	682b      	ldr	r3, [r5, #0]
 80a01d6:	f013 0401 	ands.w	r4, r3, #1
 80a01da:	d109      	bne.n	80a01f0 <_ZN11ArduinoJson10JsonObject7invalidEv+0x20>
 80a01dc:	4628      	mov	r0, r5
 80a01de:	f7ff ff6b 	bl	80a00b8 <__cxa_guard_acquire>
 80a01e2:	b128      	cbz	r0, 80a01f0 <_ZN11ArduinoJson10JsonObject7invalidEv+0x20>
 80a01e4:	4b04      	ldr	r3, [pc, #16]	; (80a01f8 <_ZN11ArduinoJson10JsonObject7invalidEv+0x28>)
 80a01e6:	4628      	mov	r0, r5
 80a01e8:	601c      	str	r4, [r3, #0]
 80a01ea:	605c      	str	r4, [r3, #4]
 80a01ec:	f7ff ff69 	bl	80a00c2 <__cxa_guard_release>
    return instance;
  }
 80a01f0:	4801      	ldr	r0, [pc, #4]	; (80a01f8 <_ZN11ArduinoJson10JsonObject7invalidEv+0x28>)
 80a01f2:	bd38      	pop	{r3, r4, r5, pc}
 80a01f4:	200004f4 	.word	0x200004f4
 80a01f8:	200004f8 	.word	0x200004f8

080a01fc <loop>:
  greenRedGradientTest();
}

void loop()
{
  if (!enableDisplay)      return;
 80a01fc:	4b02      	ldr	r3, [pc, #8]	; (80a0208 <loop+0xc>)
 80a01fe:	781b      	ldrb	r3, [r3, #0]
 80a0200:	b10b      	cbz	r3, 80a0206 <loop+0xa>
  GFX_loop();
 80a0202:	f003 b9d9 	b.w	80a35b8 <_Z8GFX_loopv>
 80a0206:	4770      	bx	lr
 80a0208:	20000764 	.word	0x20000764

080a020c <_Z17callAzureFunctionPKcS0_b>:
    }
  }
}

void callAzureFunction(const char* command, const char* payload, bool isJson = false)
{
 80a020c:	b510      	push	{r4, lr}
 80a020e:	460b      	mov	r3, r1
 80a0210:	b0c4      	sub	sp, #272	; 0x110
  char jsonData[255];
  if (isJson) {
 80a0212:	b112      	cbz	r2, 80a021a <_Z17callAzureFunctionPKcS0_b+0xe>
    sprintf(jsonData, "{\"command\":\"%s\", \"data\":%s}", command, payload);
 80a0214:	4602      	mov	r2, r0
 80a0216:	4915      	ldr	r1, [pc, #84]	; (80a026c <_Z17callAzureFunctionPKcS0_b+0x60>)
 80a0218:	e001      	b.n	80a021e <_Z17callAzureFunctionPKcS0_b+0x12>
  } else {
    sprintf(jsonData, "{\"command\":\"%s\", \"data\":\"%s\"}", command, payload);
 80a021a:	4602      	mov	r2, r0
 80a021c:	4914      	ldr	r1, [pc, #80]	; (80a0270 <_Z17callAzureFunctionPKcS0_b+0x64>)
 80a021e:	a804      	add	r0, sp, #16
 80a0220:	f003 fc1a 	bl	80a3a58 <sprintf>
  }
  Serial.println(jsonData);
 80a0224:	f004 f9f0 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0228:	a904      	add	r1, sp, #16
 80a022a:	f003 fd66 	bl	80a3cfa <_ZN5Print7printlnEPKc>
 80a022e:	4b11      	ldr	r3, [pc, #68]	; (80a0274 <_Z17callAzureFunctionPKcS0_b+0x68>)
        return publish(eventName, eventData, 60, flags1, flags2);
    }

    inline particle::Future<bool> publish(const char *eventName, const char *eventData, int ttl, PublishFlags flags1, PublishFlags flags2 = PublishFlags())
    {
        return publish_event(eventName, eventData, ttl, flags1 | flags2);
 80a0230:	aa04      	add	r2, sp, #16
 80a0232:	781b      	ldrb	r3, [r3, #0]
 80a0234:	4910      	ldr	r1, [pc, #64]	; (80a0278 <_Z17callAzureFunctionPKcS0_b+0x6c>)
 80a0236:	f88d 3000 	strb.w	r3, [sp]
 80a023a:	a802      	add	r0, sp, #8
 80a023c:	233c      	movs	r3, #60	; 0x3c
 80a023e:	f003 fffb 	bl	80a4238 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>
      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
 80a0242:	9c03      	ldr	r4, [sp, #12]
 80a0244:	b17c      	cbz	r4, 80a0266 <_Z17callAzureFunctionPKcS0_b+0x5a>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a0246:	6863      	ldr	r3, [r4, #4]
 80a0248:	3b01      	subs	r3, #1
 80a024a:	6063      	str	r3, [r4, #4]
 80a024c:	b95b      	cbnz	r3, 80a0266 <_Z17callAzureFunctionPKcS0_b+0x5a>
        {
          _M_dispose();
 80a024e:	6823      	ldr	r3, [r4, #0]
 80a0250:	4620      	mov	r0, r4
 80a0252:	689b      	ldr	r3, [r3, #8]
 80a0254:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a0256:	68a3      	ldr	r3, [r4, #8]
 80a0258:	3b01      	subs	r3, #1
 80a025a:	60a3      	str	r3, [r4, #8]
 80a025c:	b91b      	cbnz	r3, 80a0266 <_Z17callAzureFunctionPKcS0_b+0x5a>
            _M_destroy();
 80a025e:	6823      	ldr	r3, [r4, #0]
 80a0260:	4620      	mov	r0, r4
 80a0262:	68db      	ldr	r3, [r3, #12]
 80a0264:	4798      	blx	r3

  // This event is tied to a webhook created in Particle Console
  // https://console.particle.io/integrations
  // The webhook calls an Azure Function with a json payload
  Particle.publish("callAzureFunctionEvent", jsonData, PRIVATE);
}
 80a0266:	b044      	add	sp, #272	; 0x110
 80a0268:	bd10      	pop	{r4, pc}
 80a026a:	bf00      	nop
 80a026c:	080a5f83 	.word	0x080a5f83
 80a0270:	080a5f9f 	.word	0x080a5f9f
 80a0274:	20000765 	.word	0x20000765
 80a0278:	080a5fe9 	.word	0x080a5fe9

080a027c <_Z8findItemPKc>:

/* ============= IFTTT ASSISTANT EVENT HANDLERS ============= */

void findItem(const char *data)
{
  callAzureFunction(FindItem, data);
 80a027c:	4b02      	ldr	r3, [pc, #8]	; (80a0288 <_Z8findItemPKc+0xc>)
 80a027e:	4601      	mov	r1, r0
 80a0280:	2200      	movs	r2, #0
 80a0282:	6818      	ldr	r0, [r3, #0]
 80a0284:	f7ff bfc2 	b.w	80a020c <_Z17callAzureFunctionPKcS0_b>
 80a0288:	200003a0 	.word	0x200003a0

080a028c <_Z8findTagsPKc>:
}

void findTags(const char *data)
{
  callAzureFunction(FindTags, data);
 80a028c:	4b02      	ldr	r3, [pc, #8]	; (80a0298 <_Z8findTagsPKc+0xc>)
 80a028e:	4601      	mov	r1, r0
 80a0290:	2200      	movs	r2, #0
 80a0292:	6818      	ldr	r0, [r3, #0]
 80a0294:	f7ff bfba 	b.w	80a020c <_Z17callAzureFunctionPKcS0_b>
 80a0298:	200003a4 	.word	0x200003a4

080a029c <_Z10insertItemPKc>:
}

void insertItem(const char *data)
{
  callAzureFunction(InsertItem, data, true);
 80a029c:	4b02      	ldr	r3, [pc, #8]	; (80a02a8 <_Z10insertItemPKc+0xc>)
 80a029e:	4601      	mov	r1, r0
 80a02a0:	2201      	movs	r2, #1
 80a02a2:	6818      	ldr	r0, [r3, #0]
 80a02a4:	f7ff bfb2 	b.w	80a020c <_Z17callAzureFunctionPKcS0_b>
 80a02a8:	2000039c 	.word	0x2000039c

080a02ac <_Z10removeItemPKc>:
}

void removeItem(const char *data)
{
  callAzureFunction(RemoveItem, data);
 80a02ac:	4b02      	ldr	r3, [pc, #8]	; (80a02b8 <_Z10removeItemPKc+0xc>)
 80a02ae:	4601      	mov	r1, r0
 80a02b0:	2200      	movs	r2, #0
 80a02b2:	6818      	ldr	r0, [r3, #0]
 80a02b4:	f7ff bfaa 	b.w	80a020c <_Z17callAzureFunctionPKcS0_b>
 80a02b8:	20000340 	.word	0x20000340

080a02bc <_Z7addTagsPKc>:
}

void addTags(const char *data)
{
  callAzureFunction(AddTags, data);
 80a02bc:	4b02      	ldr	r3, [pc, #8]	; (80a02c8 <_Z7addTagsPKc+0xc>)
 80a02be:	4601      	mov	r1, r0
 80a02c0:	2200      	movs	r2, #0
 80a02c2:	6818      	ldr	r0, [r3, #0]
 80a02c4:	f7ff bfa2 	b.w	80a020c <_Z17callAzureFunctionPKcS0_b>
 80a02c8:	200003bc 	.word	0x200003bc

080a02cc <_Z11setQuantityPKc>:
}

void setQuantity(const char *data)
{
  callAzureFunction(SetQuantity, data, true);
 80a02cc:	4b02      	ldr	r3, [pc, #8]	; (80a02d8 <_Z11setQuantityPKc+0xc>)
 80a02ce:	4601      	mov	r1, r0
 80a02d0:	2201      	movs	r2, #1
 80a02d2:	6818      	ldr	r0, [r3, #0]
 80a02d4:	f7ff bf9a 	b.w	80a020c <_Z17callAzureFunctionPKcS0_b>
 80a02d8:	200003b4 	.word	0x200003b4

080a02dc <_Z14updateQuantityPKc>:
}

void updateQuantity(const char *data)
{
  callAzureFunction(UpdateQuantity, data, true);
 80a02dc:	4b02      	ldr	r3, [pc, #8]	; (80a02e8 <_Z14updateQuantityPKc+0xc>)
 80a02de:	4601      	mov	r1, r0
 80a02e0:	2201      	movs	r2, #1
 80a02e2:	6818      	ldr	r0, [r3, #0]
 80a02e4:	f7ff bf92 	b.w	80a020c <_Z17callAzureFunctionPKcS0_b>
 80a02e8:	200003a8 	.word	0x200003a8

080a02ec <_Z12showAllBoxesPKc>:
}

void showAllBoxes(const char *data)
{
  callAzureFunction(ShowAllBoxes, data);
 80a02ec:	4b02      	ldr	r3, [pc, #8]	; (80a02f8 <_Z12showAllBoxesPKc+0xc>)
 80a02ee:	4601      	mov	r1, r0
 80a02f0:	2200      	movs	r2, #0
 80a02f2:	6818      	ldr	r0, [r3, #0]
 80a02f4:	f7ff bf8a 	b.w	80a020c <_Z17callAzureFunctionPKcS0_b>
 80a02f8:	200003b8 	.word	0x200003b8

080a02fc <_Z10bundleWithPKc>:
}

void bundleWith(const char *data)
{
  callAzureFunction(BundleWith, data, true);
 80a02fc:	4b02      	ldr	r3, [pc, #8]	; (80a0308 <_Z10bundleWithPKc+0xc>)
 80a02fe:	4601      	mov	r1, r0
 80a0300:	2201      	movs	r2, #1
 80a0302:	6818      	ldr	r0, [r3, #0]
 80a0304:	f7ff bf82 	b.w	80a020c <_Z17callAzureFunctionPKcS0_b>
 80a0308:	20000334 	.word	0x20000334

080a030c <_Z7howManyPKc>:
}

void howMany(const char *data)
{
  callAzureFunction(HowMany, data);
 80a030c:	4b02      	ldr	r3, [pc, #8]	; (80a0318 <_Z7howManyPKc+0xc>)
 80a030e:	4601      	mov	r1, r0
 80a0310:	2200      	movs	r2, #0
 80a0312:	6818      	ldr	r0, [r3, #0]
 80a0314:	f7ff bf7a 	b.w	80a020c <_Z17callAzureFunctionPKcS0_b>
 80a0318:	2000033c 	.word	0x2000033c

080a031c <_Z16setStateFromTextRbPKc>:
{
  setStateFromText(enableTextScrolling, data);
}

void setStateFromText(bool& variable, const char *onOffText)
{
 80a031c:	b538      	push	{r3, r4, r5, lr}
 80a031e:	460d      	mov	r5, r1
 80a0320:	4604      	mov	r4, r0
  if (strcmp(onOffText, "on") == 0) {
 80a0322:	4907      	ldr	r1, [pc, #28]	; (80a0340 <_Z16setStateFromTextRbPKc+0x24>)
 80a0324:	4628      	mov	r0, r5
 80a0326:	f005 fcbc 	bl	80a5ca2 <strcmp>
 80a032a:	b910      	cbnz	r0, 80a0332 <_Z16setStateFromTextRbPKc+0x16>
    variable = true;
 80a032c:	2301      	movs	r3, #1
 80a032e:	7023      	strb	r3, [r4, #0]
 80a0330:	bd38      	pop	{r3, r4, r5, pc}
  }
  else if (strcmp(onOffText, "off") == 0) {
 80a0332:	4904      	ldr	r1, [pc, #16]	; (80a0344 <_Z16setStateFromTextRbPKc+0x28>)
 80a0334:	4628      	mov	r0, r5
 80a0336:	f005 fcb4 	bl	80a5ca2 <strcmp>
 80a033a:	b900      	cbnz	r0, 80a033e <_Z16setStateFromTextRbPKc+0x22>
    variable = false;
 80a033c:	7020      	strb	r0, [r4, #0]
 80a033e:	bd38      	pop	{r3, r4, r5, pc}
 80a0340:	080a5fbd 	.word	0x080a5fbd
 80a0344:	080a5fc0 	.word	0x080a5fc0

080a0348 <_Z13setScrollTextPKc>:
  GFX_setBrightness(brightness);
}

void setScrollText(const char *data)
{
  setStateFromText(enableTextScrolling, data);
 80a0348:	4601      	mov	r1, r0
 80a034a:	4801      	ldr	r0, [pc, #4]	; (80a0350 <_Z13setScrollTextPKc+0x8>)
 80a034c:	f7ff bfe6 	b.w	80a031c <_Z16setStateFromTextRbPKc>
 80a0350:	200013cc 	.word	0x200013cc

080a0354 <_Z11lightOneBoxiit>:
{
  setDisplay(ON);
  GFX_showNotFound();
}

void lightOneBox(int row, int col, uint16_t color) {
 80a0354:	b570      	push	{r4, r5, r6, lr}
 80a0356:	4604      	mov	r4, r0
 80a0358:	460d      	mov	r5, r1
 80a035a:	4616      	mov	r6, r2
  GFX_clear();
 80a035c:	f002 fce2 	bl	80a2d24 <_Z9GFX_clearv>
  GFX_lightBox(row, col, color);
 80a0360:	4632      	mov	r2, r6
 80a0362:	4629      	mov	r1, r5
 80a0364:	4620      	mov	r0, r4
 80a0366:	f002 fce9 	bl	80a2d3c <_Z12GFX_lightBoxiit>
  GFX_update();
}
 80a036a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
}

void lightOneBox(int row, int col, uint16_t color) {
  GFX_clear();
  GFX_lightBox(row, col, color);
  GFX_update();
 80a036e:	f002 bcdf 	b.w	80a2d30 <_Z10GFX_updatev>
	...

080a0374 <_Z10setDisplayb>:
}

void setDisplay(bool state)
{
 80a0374:	b538      	push	{r3, r4, r5, lr}
  if (enableDisplay == state) return;
 80a0376:	4b0a      	ldr	r3, [pc, #40]	; (80a03a0 <_Z10setDisplayb+0x2c>)
  GFX_lightBox(row, col, color);
  GFX_update();
}

void setDisplay(bool state)
{
 80a0378:	4605      	mov	r5, r0
  if (enableDisplay == state) return;
 80a037a:	781a      	ldrb	r2, [r3, #0]
 80a037c:	461c      	mov	r4, r3
 80a037e:	4282      	cmp	r2, r0
 80a0380:	d00d      	beq.n	80a039e <_Z10setDisplayb+0x2a>

  if (state) {
 80a0382:	b140      	cbz	r0, 80a0396 <_Z10setDisplayb+0x22>
    digitalWrite(POWER_SUPPLY_RELAY_PIN, ON);
 80a0384:	2101      	movs	r1, #1
 80a0386:	2000      	movs	r0, #0
 80a0388:	f004 fab5 	bl	80a48f6 <digitalWrite>
    // Give the power supply a moment to warm up if it was turned off
    // Datasheet suggests 20-50ms warm up time to support full load
    delay(1000);
 80a038c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a0390:	f003 fd68 	bl	80a3e64 <delay>
 80a0394:	e002      	b.n	80a039c <_Z10setDisplayb+0x28>
  } else {
    digitalWrite(POWER_SUPPLY_RELAY_PIN, OFF);
 80a0396:	4601      	mov	r1, r0
 80a0398:	f004 faad 	bl	80a48f6 <digitalWrite>
  }

  enableDisplay = state;
 80a039c:	7025      	strb	r5, [r4, #0]
 80a039e:	bd38      	pop	{r3, r4, r5, pc}
 80a03a0:	20000764 	.word	0x20000764

080a03a4 <setup>:
// Webhook response handler function prototypes
void azureFunctionEventResponseHandler(const char *event, const char *data);

// Program
void setup()
{
 80a03a4:	b513      	push	{r0, r1, r4, lr}
  Serial.begin();
 80a03a6:	f004 f92f 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a03aa:	f44f 5116 	mov.w	r1, #9600	; 0x2580
    particle::Future<bool> publish(const char* name, const char* data) PARTICLE_DEPRECATED_API_DEFAULT_PUBLISH_SCOPE;
    particle::Future<bool> publish(const char* name, const char* data, int ttl) PARTICLE_DEPRECATED_API_DEFAULT_PUBLISH_SCOPE;

    inline bool subscribe(const char *eventName, EventHandler handler, Spark_Subscription_Scope_TypeDef scope)
    {
        return CLOUD_FN(spark_subscribe(eventName, handler, NULL, scope, NULL, NULL), false);
 80a03ae:	2400      	movs	r4, #0
 80a03b0:	f004 f91e 	bl	80a45f0 <_ZN9USBSerial5beginEl>
  Serial.println("FindyBot3000");
 80a03b4:	f004 f928 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a03b8:	4918      	ldr	r1, [pc, #96]	; (80a041c <setup+0x78>)
 80a03ba:	f003 fc9e 	bl	80a3cfa <_ZN5Print7printlnEPKc>
 80a03be:	4622      	mov	r2, r4
 80a03c0:	9401      	str	r4, [sp, #4]
 80a03c2:	9400      	str	r4, [sp, #0]
 80a03c4:	2301      	movs	r3, #1
 80a03c6:	4916      	ldr	r1, [pc, #88]	; (80a0420 <setup+0x7c>)
 80a03c8:	4816      	ldr	r0, [pc, #88]	; (80a0424 <setup+0x80>)
 80a03ca:	f003 fb1d 	bl	80a3a08 <spark_subscribe>
 80a03ce:	4623      	mov	r3, r4
 80a03d0:	4622      	mov	r2, r4
 80a03d2:	9401      	str	r4, [sp, #4]
 80a03d4:	9400      	str	r4, [sp, #0]
 80a03d6:	4914      	ldr	r1, [pc, #80]	; (80a0428 <setup+0x84>)
 80a03d8:	4814      	ldr	r0, [pc, #80]	; (80a042c <setup+0x88>)
 80a03da:	f003 fb15 	bl	80a3a08 <spark_subscribe>

  // Handle Azure Function web hook response
  Particle.subscribe("hook-response/callAzureFunctionEvent", azureFunctionEventResponseHandler, MY_DEVICES);

  // Start FindyBot3000 with the display off
  pinMode(POWER_SUPPLY_RELAY_PIN, OUTPUT);
 80a03de:	4620      	mov	r0, r4
 80a03e0:	2101      	movs	r1, #1
 80a03e2:	f004 fa77 	bl	80a48d4 <pinMode>
  digitalWrite(POWER_SUPPLY_RELAY_PIN, OFF);
 80a03e6:	4621      	mov	r1, r4
 80a03e8:	4620      	mov	r0, r4
 80a03ea:	f004 fa84 	bl	80a48f6 <digitalWrite>
  delay(1000);
 80a03ee:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a03f2:	f003 fd37 	bl	80a3e64 <delay>

  GFX_setup();
 80a03f6:	f002 fc35 	bl	80a2c64 <_Z9GFX_setupv>
  likelyColor = green;
 80a03fa:	4b0d      	ldr	r3, [pc, #52]	; (80a0430 <setup+0x8c>)
  unlikelyColor = red;

  setDisplay(ON);
 80a03fc:	2001      	movs	r0, #1
  pinMode(POWER_SUPPLY_RELAY_PIN, OUTPUT);
  digitalWrite(POWER_SUPPLY_RELAY_PIN, OFF);
  delay(1000);

  GFX_setup();
  likelyColor = green;
 80a03fe:	881a      	ldrh	r2, [r3, #0]
 80a0400:	4b0c      	ldr	r3, [pc, #48]	; (80a0434 <setup+0x90>)
 80a0402:	801a      	strh	r2, [r3, #0]
  unlikelyColor = red;
 80a0404:	4b0c      	ldr	r3, [pc, #48]	; (80a0438 <setup+0x94>)
 80a0406:	881a      	ldrh	r2, [r3, #0]
 80a0408:	4b0c      	ldr	r3, [pc, #48]	; (80a043c <setup+0x98>)
 80a040a:	801a      	strh	r2, [r3, #0]

  setDisplay(ON);
 80a040c:	f7ff ffb2 	bl	80a0374 <_Z10setDisplayb>

  greenRedGradientTest();
}
 80a0410:	b002      	add	sp, #8
 80a0412:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  likelyColor = green;
  unlikelyColor = red;

  setDisplay(ON);

  greenRedGradientTest();
 80a0416:	f002 bf0b 	b.w	80a3230 <_Z20greenRedGradientTestv>
 80a041a:	bf00      	nop
 80a041c:	080a5fc4 	.word	0x080a5fc4
 80a0420:	080a0145 	.word	0x080a0145
 80a0424:	080a5fd1 	.word	0x080a5fd1
 80a0428:	080a08a9 	.word	0x080a08a9
 80a042c:	080a5fdb 	.word	0x080a5fdb
 80a0430:	20001344 	.word	0x20001344
 80a0434:	20001366 	.word	0x20001366
 80a0438:	2000136c 	.word	0x2000136c
 80a043c:	20001374 	.word	0x20001374

080a0440 <_Z7welcomePKc>:
  }
  */
}

void welcome(const char* data)
{
 80a0440:	b500      	push	{lr}
  if (data == NULL) return;
 80a0442:	4601      	mov	r1, r0
  }
  */
}

void welcome(const char* data)
{
 80a0444:	b089      	sub	sp, #36	; 0x24
  if (data == NULL) return;
 80a0446:	b1e8      	cbz	r0, 80a0484 <_Z7welcomePKc+0x44>

  char* tmp = "W E L C O M E  ";
  strcat(tmp, (char*)data);
 80a0448:	4810      	ldr	r0, [pc, #64]	; (80a048c <_Z7welcomePKc+0x4c>)
 80a044a:	f005 fc1b 	bl	80a5c84 <strcat>
  String s(tmp);
 80a044e:	490f      	ldr	r1, [pc, #60]	; (80a048c <_Z7welcomePKc+0x4c>)
 80a0450:	4668      	mov	r0, sp
 80a0452:	f003 fba8 	bl	80a3ba6 <_ZN6StringC1EPK19__FlashStringHelper>
  s = s.toUpperCase();
 80a0456:	4668      	mov	r0, sp
 80a0458:	f003 fc04 	bl	80a3c64 <_ZN6String11toUpperCaseEv>
 80a045c:	4601      	mov	r1, r0
 80a045e:	4668      	mov	r0, sp
 80a0460:	f003 fbb4 	bl	80a3bcc <_ZN6StringaSERKS_>

  GFX_setString(s);
 80a0464:	4669      	mov	r1, sp
 80a0466:	a804      	add	r0, sp, #16
 80a0468:	f003 fbbf 	bl	80a3bea <_ZN6StringC1ERKS_>
 80a046c:	a804      	add	r0, sp, #16
 80a046e:	f002 fc1d 	bl	80a2cac <_Z13GFX_setString6String>
 80a0472:	a804      	add	r0, sp, #16
 80a0474:	f003 fb50 	bl	80a3b18 <_ZN6StringD1Ev>
  setDisplay(ON);
 80a0478:	2001      	movs	r0, #1
 80a047a:	f7ff ff7b 	bl	80a0374 <_Z10setDisplayb>
{
  if (data == NULL) return;

  char* tmp = "W E L C O M E  ";
  strcat(tmp, (char*)data);
  String s(tmp);
 80a047e:	4668      	mov	r0, sp
 80a0480:	f003 fb4a 	bl	80a3b18 <_ZN6StringD1Ev>
  s = s.toUpperCase();

  GFX_setString(s);
  setDisplay(ON);
}
 80a0484:	b009      	add	sp, #36	; 0x24
 80a0486:	f85d fb04 	ldr.w	pc, [sp], #4
 80a048a:	bf00      	nop
 80a048c:	080a6000 	.word	0x080a6000

080a0490 <_Z10setDisplayPKc>:

// Turn the LED matrix power supply relay on or off
void setDisplay(const char *data)
{
 80a0490:	b538      	push	{r3, r4, r5, lr}
  if (data == NULL) return;
 80a0492:	4605      	mov	r5, r0
 80a0494:	b180      	cbz	r0, 80a04b8 <_Z10setDisplayPKc+0x28>

  if (strstr(data, "on")) {
 80a0496:	4909      	ldr	r1, [pc, #36]	; (80a04bc <_Z10setDisplayPKc+0x2c>)
 80a0498:	f005 fc39 	bl	80a5d0e <strstr>
 80a049c:	4604      	mov	r4, r0
 80a049e:	b108      	cbz	r0, 80a04a4 <_Z10setDisplayPKc+0x14>
    setDisplay(true);
 80a04a0:	2001      	movs	r0, #1
 80a04a2:	e005      	b.n	80a04b0 <_Z10setDisplayPKc+0x20>
  } else if (strstr(data, "off")) {
 80a04a4:	4906      	ldr	r1, [pc, #24]	; (80a04c0 <_Z10setDisplayPKc+0x30>)
 80a04a6:	4628      	mov	r0, r5
 80a04a8:	f005 fc31 	bl	80a5d0e <strstr>
 80a04ac:	b120      	cbz	r0, 80a04b8 <_Z10setDisplayPKc+0x28>
    setDisplay(false);
 80a04ae:	4620      	mov	r0, r4
  }
}
 80a04b0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  if (data == NULL) return;

  if (strstr(data, "on")) {
    setDisplay(true);
  } else if (strstr(data, "off")) {
    setDisplay(false);
 80a04b4:	f7ff bf5e 	b.w	80a0374 <_Z10setDisplayb>
 80a04b8:	bd38      	pop	{r3, r4, r5, pc}
 80a04ba:	bf00      	nop
 80a04bc:	080a5fbd 	.word	0x080a5fbd
 80a04c0:	080a5fc0 	.word	0x080a5fc0

080a04c4 <_Z18dispayItemNotFoundv>:
}

/* =============== HELPER FUNCTIONS =============== */

void dispayItemNotFound()
{
 80a04c4:	b508      	push	{r3, lr}
  setDisplay(ON);
 80a04c6:	2001      	movs	r0, #1
 80a04c8:	f7ff ff54 	bl	80a0374 <_Z10setDisplayb>
  GFX_showNotFound();
}
 80a04cc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
/* =============== HELPER FUNCTIONS =============== */

void dispayItemNotFound()
{
  setDisplay(ON);
  GFX_showNotFound();
 80a04d0:	f002 bc8a 	b.w	80a2de8 <_Z16GFX_showNotFoundv>

080a04d4 <_Z1rii>:
}


// Generate a random number between minRand and maxRand
int r(int minRand, int maxRand)
{
 80a04d4:	b538      	push	{r3, r4, r5, lr}
 80a04d6:	4605      	mov	r5, r0
 80a04d8:	460c      	mov	r4, r1
  return rand() % (maxRand-minRand+1) + minRand;
 80a04da:	f005 fb99 	bl	80a5c10 <rand>
 80a04de:	1b61      	subs	r1, r4, r5
 80a04e0:	3101      	adds	r1, #1
 80a04e2:	fb90 f3f1 	sdiv	r3, r0, r1
 80a04e6:	fb03 0011 	mls	r0, r3, r1, r0
 80a04ea:	4428      	add	r0, r5
 80a04ec:	bd38      	pop	{r3, r4, r5, pc}

080a04ee <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_>:
    void move() {
      ++_ptr;
    }

    char current() const {
      return char(_ptr[0]);
 80a04ee:	6803      	ldr	r3, [r0, #0]
namespace ArduinoJson {
namespace Internals {
template <typename TInput>
void skipSpacesAndComments(TInput& input) {
  for (;;) {
    switch (input.current()) {
 80a04f0:	781a      	ldrb	r2, [r3, #0]
 80a04f2:	2a0d      	cmp	r2, #13
 80a04f4:	d009      	beq.n	80a050a <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_+0x1c>
 80a04f6:	d803      	bhi.n	80a0500 <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_+0x12>
 80a04f8:	3a09      	subs	r2, #9
 80a04fa:	2a01      	cmp	r2, #1
 80a04fc:	d826      	bhi.n	80a054c <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_+0x5e>
 80a04fe:	e004      	b.n	80a050a <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_+0x1c>
 80a0500:	2a20      	cmp	r2, #32
 80a0502:	d002      	beq.n	80a050a <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_+0x1c>
 80a0504:	2a2f      	cmp	r2, #47	; 0x2f
 80a0506:	d002      	beq.n	80a050e <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_+0x20>
 80a0508:	4770      	bx	lr
   public:
    Reader(const TChar* ptr)
        : _ptr(ptr ? ptr : reinterpret_cast<const TChar*>("")) {}

    void move() {
      ++_ptr;
 80a050a:	3301      	adds	r3, #1
 80a050c:	e01c      	b.n	80a0548 <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_+0x5a>
        input.move();
        continue;

      // comments
      case '/':
        switch (input.next()) {
 80a050e:	785a      	ldrb	r2, [r3, #1]
 80a0510:	2a2a      	cmp	r2, #42	; 0x2a
 80a0512:	d002      	beq.n	80a051a <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_+0x2c>
 80a0514:	2a2f      	cmp	r2, #47	; 0x2f
 80a0516:	d010      	beq.n	80a053a <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_+0x4c>
 80a0518:	4770      	bx	lr
 80a051a:	3301      	adds	r3, #1
 80a051c:	6003      	str	r3, [r0, #0]
 80a051e:	6803      	ldr	r3, [r0, #0]
 80a0520:	1c5a      	adds	r2, r3, #1
 80a0522:	6002      	str	r2, [r0, #0]
    }

    char current() const {
      return char(_ptr[0]);
 80a0524:	785a      	ldrb	r2, [r3, #1]
          case '*':
            input.move();  // skip '/'
            // no need to skip '*'
            for (;;) {
              input.move();
              if (input.current() == '\0') return;
 80a0526:	b18a      	cbz	r2, 80a054c <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_+0x5e>
              if (input.current() == '*' && input.next() == '/') {
 80a0528:	2a2a      	cmp	r2, #42	; 0x2a
 80a052a:	d1f8      	bne.n	80a051e <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_+0x30>
 80a052c:	789a      	ldrb	r2, [r3, #2]
 80a052e:	2a2f      	cmp	r2, #47	; 0x2f
 80a0530:	d1f5      	bne.n	80a051e <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_+0x30>
   public:
    Reader(const TChar* ptr)
        : _ptr(ptr ? ptr : reinterpret_cast<const TChar*>("")) {}

    void move() {
      ++_ptr;
 80a0532:	3303      	adds	r3, #3
 80a0534:	e008      	b.n	80a0548 <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_+0x5a>
          case '/':
            // not need to skip "//"
            for (;;) {
              input.move();
              if (input.current() == '\0') return;
              if (input.current() == '\n') break;
 80a0536:	2b0a      	cmp	r3, #10
 80a0538:	d0d9      	beq.n	80a04ee <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_>
 80a053a:	6803      	ldr	r3, [r0, #0]
 80a053c:	1c5a      	adds	r2, r3, #1
 80a053e:	6002      	str	r2, [r0, #0]
    }

    char current() const {
      return char(_ptr[0]);
 80a0540:	785b      	ldrb	r3, [r3, #1]
          // C++-style line comment
          case '/':
            // not need to skip "//"
            for (;;) {
              input.move();
              if (input.current() == '\0') return;
 80a0542:	2b00      	cmp	r3, #0
 80a0544:	d1f7      	bne.n	80a0536 <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_+0x48>
 80a0546:	e001      	b.n	80a054c <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_+0x5e>
   public:
    Reader(const TChar* ptr)
        : _ptr(ptr ? ptr : reinterpret_cast<const TChar*>("")) {}

    void move() {
      ++_ptr;
 80a0548:	6003      	str	r3, [r0, #0]
 80a054a:	e7d0      	b.n	80a04ee <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_>
 80a054c:	4770      	bx	lr

080a054e <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE3eatERS4_c>:

#include "Comments.hpp"
#include "JsonParser.hpp"

template <typename TReader, typename TWriter>
inline bool ArduinoJson::Internals::JsonParser<TReader, TWriter>::eat(
 80a054e:	b538      	push	{r3, r4, r5, lr}
 80a0550:	4604      	mov	r4, r0
 80a0552:	460d      	mov	r5, r1
    TReader &reader, char charToSkip) {
  skipSpacesAndComments(reader);
 80a0554:	f7ff ffcb 	bl	80a04ee <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_>
    }

    char current() const {
      return char(_ptr[0]);
 80a0558:	6823      	ldr	r3, [r4, #0]
  if (reader.current() != charToSkip) return false;
 80a055a:	781a      	ldrb	r2, [r3, #0]
 80a055c:	42aa      	cmp	r2, r5
   public:
    Reader(const TChar* ptr)
        : _ptr(ptr ? ptr : reinterpret_cast<const TChar*>("")) {}

    void move() {
      ++_ptr;
 80a055e:	bf03      	ittte	eq
 80a0560:	3301      	addeq	r3, #1
 80a0562:	6023      	streq	r3, [r4, #0]
  reader.move();
  return true;
 80a0564:	2001      	moveq	r0, #1

template <typename TReader, typename TWriter>
inline bool ArduinoJson::Internals::JsonParser<TReader, TWriter>::eat(
    TReader &reader, char charToSkip) {
  skipSpacesAndComments(reader);
  if (reader.current() != charToSkip) return false;
 80a0566:	2000      	movne	r0, #0
  reader.move();
  return true;
}
 80a0568:	bd38      	pop	{r3, r4, r5, pc}
	...

080a056c <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv>:
  return true;
}

template <typename TReader, typename TWriter>
inline const char *
ArduinoJson::Internals::JsonParser<TReader, TWriter>::parseString() {
 80a056c:	b570      	push	{r4, r5, r6, lr}
 80a056e:	4604      	mov	r4, r0
template <typename TChar>
class StringWriter {
 public:
  class String {
   public:
    String(TChar** ptr) : _writePtr(ptr), _startPtr(*ptr) {}
 80a0570:	6885      	ldr	r5, [r0, #8]
  typename RemoveReference<TWriter>::type::String str = _writer.startString();

  skipSpacesAndComments(_reader);
 80a0572:	3004      	adds	r0, #4
 80a0574:	f7ff ffbb 	bl	80a04ee <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_>
    }

    char current() const {
      return char(_ptr[0]);
 80a0578:	6862      	ldr	r2, [r4, #4]
 80a057a:	7813      	ldrb	r3, [r2, #0]
    return isBetween(c, '0', '9') || isBetween(c, '_', 'z') ||
           isBetween(c, 'A', 'Z') || c == '+' || c == '-' || c == '.';
  }

  static inline bool isQuote(char c) {
    return c == '\'' || c == '\"';
 80a057c:	2b27      	cmp	r3, #39	; 0x27
 80a057e:	d011      	beq.n	80a05a4 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x38>
 80a0580:	2b22      	cmp	r3, #34	; 0x22
 80a0582:	d00f      	beq.n	80a05a4 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x38>
    return min <= c && c <= max;
  }

  static inline bool canBeInNonQuotedString(char c) {
    return isBetween(c, '0', '9') || isBetween(c, '_', 'z') ||
           isBetween(c, 'A', 'Z') || c == '+' || c == '-' || c == '.';
 80a0584:	f647 71ed 	movw	r1, #32749	; 0x7fed
  inline bool parseArrayTo(JsonVariant *destination);
  inline bool parseObjectTo(JsonVariant *destination);
  inline bool parseStringTo(JsonVariant *destination);

  static inline bool isBetween(char c, char min, char max) {
    return min <= c && c <= max;
 80a0588:	f1a3 025f 	sub.w	r2, r3, #95	; 0x5f
 80a058c:	2a1b      	cmp	r2, #27
 80a058e:	d826      	bhi.n	80a05de <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x72>
   public:
    Reader(const TChar* ptr)
        : _ptr(ptr ? ptr : reinterpret_cast<const TChar*>("")) {}

    void move() {
      ++_ptr;
 80a0590:	6862      	ldr	r2, [r4, #4]
 80a0592:	3201      	adds	r2, #1
 80a0594:	6062      	str	r2, [r4, #4]

    void append(char c) {
      *(*_writePtr)++ = TChar(c);
 80a0596:	68a2      	ldr	r2, [r4, #8]
 80a0598:	1c50      	adds	r0, r2, #1
 80a059a:	60a0      	str	r0, [r4, #8]
 80a059c:	7013      	strb	r3, [r2, #0]
    }

    char current() const {
      return char(_ptr[0]);
 80a059e:	6863      	ldr	r3, [r4, #4]
 80a05a0:	781b      	ldrb	r3, [r3, #0]
      }

      str.append(c);
    }
  } else {  // no quotes
    for (;;) {
 80a05a2:	e7f1      	b.n	80a0588 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x1c>
   public:
    Reader(const TChar* ptr)
        : _ptr(ptr ? ptr : reinterpret_cast<const TChar*>("")) {}

    void move() {
      ++_ptr;
 80a05a4:	3201      	adds	r2, #1
 80a05a6:	6062      	str	r2, [r4, #4]
    }

    char current() const {
      return char(_ptr[0]);
 80a05a8:	6861      	ldr	r1, [r4, #4]
 80a05aa:	780a      	ldrb	r2, [r1, #0]
  if (isQuote(c)) {  // quotes
    _reader.move();
    char stopChar = c;
    for (;;) {
      c = _reader.current();
      if (c == '\0') break;
 80a05ac:	b322      	cbz	r2, 80a05f8 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x8c>
   public:
    Reader(const TChar* ptr)
        : _ptr(ptr ? ptr : reinterpret_cast<const TChar*>("")) {}

    void move() {
      ++_ptr;
 80a05ae:	1c48      	adds	r0, r1, #1
      _reader.move();

      if (c == stopChar) break;
 80a05b0:	429a      	cmp	r2, r3
 80a05b2:	6060      	str	r0, [r4, #4]
 80a05b4:	d020      	beq.n	80a05f8 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x8c>

      if (c == '\\') {
 80a05b6:	2a5c      	cmp	r2, #92	; 0x5c
 80a05b8:	d10c      	bne.n	80a05d4 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x68>
    }

    char current() const {
      return char(_ptr[0]);
 80a05ba:	784a      	ldrb	r2, [r1, #1]
    return p[0];
  }

  // Optimized for code size on a 8-bit AVR
  static char unescapeChar(char c) {
    const char *p = escapeTable(true);
 80a05bc:	4812      	ldr	r0, [pc, #72]	; (80a0608 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x9c>)
    for (;;) {
      if (p[0] == '\0') return c;
 80a05be:	7806      	ldrb	r6, [r0, #0]
 80a05c0:	b12e      	cbz	r6, 80a05ce <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x62>
      if (p[0] == c) return p[1];
 80a05c2:	42b2      	cmp	r2, r6
 80a05c4:	d101      	bne.n	80a05ca <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x5e>
 80a05c6:	7842      	ldrb	r2, [r0, #1]
 80a05c8:	e001      	b.n	80a05ce <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x62>
      p += 2;
 80a05ca:	3002      	adds	r0, #2
 80a05cc:	e7f7      	b.n	80a05be <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x52>
        // replace char
        c = Encoding::unescapeChar(_reader.current());
        if (c == '\0') break;
 80a05ce:	b19a      	cbz	r2, 80a05f8 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x8c>
   public:
    Reader(const TChar* ptr)
        : _ptr(ptr ? ptr : reinterpret_cast<const TChar*>("")) {}

    void move() {
      ++_ptr;
 80a05d0:	3102      	adds	r1, #2
 80a05d2:	6061      	str	r1, [r4, #4]
 80a05d4:	68a1      	ldr	r1, [r4, #8]
 80a05d6:	1c48      	adds	r0, r1, #1
 80a05d8:	60a0      	str	r0, [r4, #8]
 80a05da:	700a      	strb	r2, [r1, #0]
 80a05dc:	e7e4      	b.n	80a05a8 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x3c>
 80a05de:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 80a05e2:	2a19      	cmp	r2, #25
 80a05e4:	d9d4      	bls.n	80a0590 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x24>
  }

  static inline bool canBeInNonQuotedString(char c) {
    return isBetween(c, '0', '9') || isBetween(c, '_', 'z') ||
           isBetween(c, 'A', 'Z') || c == '+' || c == '-' || c == '.';
 80a05e6:	f1a3 022b 	sub.w	r2, r3, #43	; 0x2b
 80a05ea:	b2d2      	uxtb	r2, r2
 80a05ec:	2a0e      	cmp	r2, #14
 80a05ee:	d803      	bhi.n	80a05f8 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x8c>
 80a05f0:	fa21 f202 	lsr.w	r2, r1, r2
 80a05f4:	07d2      	lsls	r2, r2, #31
 80a05f6:	d4cb      	bmi.n	80a0590 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv+0x24>
    }

    const char* c_str() const {
      *(*_writePtr)++ = 0;
 80a05f8:	68a3      	ldr	r3, [r4, #8]
      c = _reader.current();
    }
  }

  return str.c_str();
}
 80a05fa:	4628      	mov	r0, r5
 80a05fc:	1c5a      	adds	r2, r3, #1
 80a05fe:	60a2      	str	r2, [r4, #8]
 80a0600:	2200      	movs	r2, #0
 80a0602:	701a      	strb	r2, [r3, #0]
 80a0604:	bd70      	pop	{r4, r5, r6, pc}
 80a0606:	bf00      	nop
 80a0608:	080a6014 	.word	0x080a6014

080a060c <_ZN11ArduinoJson9Internals17ListConstIteratorINS_11JsonVariantEEpLEj>:
    if (_node) _node = _node->next;
    return *this;
  }

  ListConstIterator<T> &operator+=(size_t distance) {
    while (_node && distance) {
 80a060c:	6803      	ldr	r3, [r0, #0]
 80a060e:	b123      	cbz	r3, 80a061a <_ZN11ArduinoJson9Internals17ListConstIteratorINS_11JsonVariantEEpLEj+0xe>
 80a0610:	b119      	cbz	r1, 80a061a <_ZN11ArduinoJson9Internals17ListConstIteratorINS_11JsonVariantEEpLEj+0xe>
      _node = _node->next;
 80a0612:	681b      	ldr	r3, [r3, #0]
      --distance;
 80a0614:	3901      	subs	r1, #1
    return *this;
  }

  ListConstIterator<T> &operator+=(size_t distance) {
    while (_node && distance) {
      _node = _node->next;
 80a0616:	6003      	str	r3, [r0, #0]
    if (_node) _node = _node->next;
    return *this;
  }

  ListConstIterator<T> &operator+=(size_t distance) {
    while (_node && distance) {
 80a0618:	e7f8      	b.n	80a060c <_ZN11ArduinoJson9Internals17ListConstIteratorINS_11JsonVariantEEpLEj>
      _node = _node->next;
      --distance;
    }
    return *this;
  }
 80a061a:	4770      	bx	lr

080a061c <_ZNK11ArduinoJson9JsonArray3getIRNS_10JsonObjectEEENS_9Internals13JsonVariantAsIT_E4typeEj>:
    return set_impl<const JsonVariant &>(index, JsonVariant(value, decimals));
  }

  // Gets the value at the specified index.
  template <typename T>
  typename Internals::JsonVariantAs<T>::type get(size_t index) const {
 80a061c:	b507      	push	{r0, r1, r2, lr}
    const_iterator it = begin() += index;
 80a061e:	6843      	ldr	r3, [r0, #4]
 80a0620:	a802      	add	r0, sp, #8
 80a0622:	f840 3d04 	str.w	r3, [r0, #-4]!
 80a0626:	f7ff fff1 	bl	80a060c <_ZN11ArduinoJson9Internals17ListConstIteratorINS_11JsonVariantEEpLEj>
 80a062a:	6803      	ldr	r3, [r0, #0]
    return it != end() ? it->as<T>() : Internals::JsonVariantDefault<T>::get();
 80a062c:	b123      	cbz	r3, 80a0638 <_ZNK11ArduinoJson9JsonArray3getIRNS_10JsonObjectEEENS_9Internals13JsonVariantAsIT_E4typeEj+0x1c>
  if (_type == Internals::JSON_ARRAY) return *_content.asArray;
  return JsonArray::invalid();
}

inline JsonObject &JsonVariant::variantAsObject() const {
  if (_type == Internals::JSON_OBJECT) return *_content.asObject;
 80a062e:	7a1a      	ldrb	r2, [r3, #8]
 80a0630:	2a07      	cmp	r2, #7
 80a0632:	d101      	bne.n	80a0638 <_ZNK11ArduinoJson9JsonArray3getIRNS_10JsonObjectEEENS_9Internals13JsonVariantAsIT_E4typeEj+0x1c>
 80a0634:	6918      	ldr	r0, [r3, #16]
 80a0636:	e001      	b.n	80a063c <_ZNK11ArduinoJson9JsonArray3getIRNS_10JsonObjectEEENS_9Internals13JsonVariantAsIT_E4typeEj+0x20>
  return JsonObject::invalid();
 80a0638:	f7ff fdca 	bl	80a01d0 <_ZN11ArduinoJson10JsonObject7invalidEv>
  }
 80a063c:	b003      	add	sp, #12
 80a063e:	f85d fb04 	ldr.w	pc, [sp], #4

080a0642 <_ZN11ArduinoJson10JsonObject7findKeyIPKcEENS_9Internals12ListIteratorINS_8JsonPairEEET_>:

 private:
  // Returns the list node that matches the specified key.
  template <typename TStringRef>
  iterator findKey(TStringRef key) {
 80a0642:	b538      	push	{r3, r4, r5, lr}
 80a0644:	460d      	mov	r5, r1
 80a0646:	6844      	ldr	r4, [r0, #4]
    iterator it;
    for (it = begin(); it != end(); ++it) {
 80a0648:	b17c      	cbz	r4, 80a066a <_ZN11ArduinoJson10JsonObject7findKeyIPKcEENS_9Internals12ListIteratorINS_8JsonPairEEET_+0x28>
      if (Internals::StringTraits<TStringRef>::equals(key, it->key)) break;
 80a064a:	68a1      	ldr	r1, [r4, #8]
    }
  };

  static bool equals(const TChar* str, const char* expected) {
    const char* actual = reinterpret_cast<const char*>(str);
    if (!actual || !expected) return actual == expected;
 80a064c:	b105      	cbz	r5, 80a0650 <_ZN11ArduinoJson10JsonObject7findKeyIPKcEENS_9Internals12ListIteratorINS_8JsonPairEEET_+0xe>
 80a064e:	b919      	cbnz	r1, 80a0658 <_ZN11ArduinoJson10JsonObject7findKeyIPKcEENS_9Internals12ListIteratorINS_8JsonPairEEET_+0x16>
 80a0650:	1b4b      	subs	r3, r1, r5
 80a0652:	4258      	negs	r0, r3
 80a0654:	4158      	adcs	r0, r3
 80a0656:	e005      	b.n	80a0664 <_ZN11ArduinoJson10JsonObject7findKeyIPKcEENS_9Internals12ListIteratorINS_8JsonPairEEET_+0x22>
    return strcmp(actual, expected) == 0;
 80a0658:	4628      	mov	r0, r5
 80a065a:	f005 fb22 	bl	80a5ca2 <strcmp>
 80a065e:	fab0 f080 	clz	r0, r0
 80a0662:	0940      	lsrs	r0, r0, #5
 80a0664:	b908      	cbnz	r0, 80a066a <_ZN11ArduinoJson10JsonObject7findKeyIPKcEENS_9Internals12ListIteratorINS_8JsonPairEEET_+0x28>
  bool operator!=(const ListIterator<T> &other) const {
    return _node != other._node;
  }

  ListIterator<T> &operator++() {
    if (_node) _node = _node->next;
 80a0666:	6824      	ldr	r4, [r4, #0]
 80a0668:	e7ee      	b.n	80a0648 <_ZN11ArduinoJson10JsonObject7findKeyIPKcEENS_9Internals12ListIteratorINS_8JsonPairEEET_+0x6>
    }
    return it;
  }
 80a066a:	4620      	mov	r0, r4
 80a066c:	bd38      	pop	{r3, r4, r5, pc}

080a066e <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv>:
  return true;
}

template <typename TReader, typename TWriter>
inline ArduinoJson::JsonObject &
ArduinoJson::Internals::JsonParser<TReader, TWriter>::parseObject() {
 80a066e:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
  if (_nestingLimit == 0) return JsonObject::invalid();
 80a0672:	7b03      	ldrb	r3, [r0, #12]
  return true;
}

template <typename TReader, typename TWriter>
inline ArduinoJson::JsonObject &
ArduinoJson::Internals::JsonParser<TReader, TWriter>::parseObject() {
 80a0674:	4606      	mov	r6, r0
  if (_nestingLimit == 0) return JsonObject::invalid();
 80a0676:	2b00      	cmp	r3, #0
 80a0678:	d05f      	beq.n	80a073a <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0xcc>
  _nestingLimit--;

  // Create an empty object
  JsonObject &object = _buffer->createObject();
 80a067a:	6804      	ldr	r4, [r0, #0]

template <typename TReader, typename TWriter>
inline ArduinoJson::JsonObject &
ArduinoJson::Internals::JsonParser<TReader, TWriter>::parseObject() {
  if (_nestingLimit == 0) return JsonObject::invalid();
  _nestingLimit--;
 80a067c:	3b01      	subs	r3, #1
 80a067e:	7303      	strb	r3, [r0, #12]
  JsonArray *ptr = new (this) JsonArray(this);
  return ptr ? *ptr : JsonArray::invalid();
}

inline ArduinoJson::JsonObject &ArduinoJson::JsonBuffer::createObject() {
  JsonObject *ptr = new (this) JsonObject(this);
 80a0680:	4621      	mov	r1, r4
 80a0682:	2008      	movs	r0, #8
 80a0684:	f7ff fd86 	bl	80a0194 <_ZN11ArduinoJson9Internals19JsonBufferAllocatednwEjPNS_10JsonBufferE>
 80a0688:	2800      	cmp	r0, #0
 80a068a:	d059      	beq.n	80a0740 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0xd2>
 80a068c:	2300      	movs	r3, #0
 80a068e:	6004      	str	r4, [r0, #0]
 80a0690:	6043      	str	r3, [r0, #4]
 private:
  JsonParser &operator=(const JsonParser &);  // non-copiable

  static bool eat(TReader &, char charToSkip);
  FORCE_INLINE bool eat(char charToSkip) {
    return eat(_reader, charToSkip);
 80a0692:	1d37      	adds	r7, r6, #4
 80a0694:	4605      	mov	r5, r0
 80a0696:	217b      	movs	r1, #123	; 0x7b
 80a0698:	4638      	mov	r0, r7
 80a069a:	f7ff ff58 	bl	80a054e <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE3eatERS4_c>

  // Create an empty object
  JsonObject &object = _buffer->createObject();

  // Check opening brace
  if (!eat('{')) goto ERROR_MISSING_BRACE;
 80a069e:	2800      	cmp	r0, #0
 80a06a0:	d04b      	beq.n	80a073a <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0xcc>
 80a06a2:	217d      	movs	r1, #125	; 0x7d
 80a06a4:	4638      	mov	r0, r7
 80a06a6:	f7ff ff52 	bl	80a054e <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE3eatERS4_c>
  if (eat('}')) goto SUCCESS_EMPTY_OBJECT;
 80a06aa:	2800      	cmp	r0, #0
 80a06ac:	d140      	bne.n	80a0730 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0xc2>
  template <typename Print>
  friend class Internals::JsonSerializer;

 public:
  // Creates an uninitialized JsonVariant
  JsonVariant() : _type(Internals::JSON_UNDEFINED) {}
 80a06ae:	4681      	mov	r9, r0
    if (!key) goto ERROR_INVALID_KEY;
    if (!eat(':')) goto ERROR_MISSING_COLON;

    // 2 - Parse value
    JsonVariant value;
    if (!parseAnythingTo(&value)) goto ERROR_INVALID_VALUE;
 80a06b0:	46e8      	mov	r8, sp
  if (eat('}')) goto SUCCESS_EMPTY_OBJECT;

  // Read each key value pair
  for (;;) {
    // 1 - Parse key
    const char *key = parseString();
 80a06b2:	4630      	mov	r0, r6
 80a06b4:	f7ff ff5a 	bl	80a056c <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv>
    if (!key) goto ERROR_INVALID_KEY;
 80a06b8:	4604      	mov	r4, r0
 80a06ba:	2800      	cmp	r0, #0
 80a06bc:	d03d      	beq.n	80a073a <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0xcc>
 80a06be:	213a      	movs	r1, #58	; 0x3a
 80a06c0:	4638      	mov	r0, r7
 80a06c2:	f7ff ff44 	bl	80a054e <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE3eatERS4_c>
    if (!eat(':')) goto ERROR_MISSING_COLON;
 80a06c6:	2800      	cmp	r0, #0
 80a06c8:	d037      	beq.n	80a073a <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0xcc>

    // 2 - Parse value
    JsonVariant value;
    if (!parseAnythingTo(&value)) goto ERROR_INVALID_VALUE;
 80a06ca:	4641      	mov	r1, r8
 80a06cc:	4630      	mov	r0, r6
 80a06ce:	f88d 9000 	strb.w	r9, [sp]
 80a06d2:	f000 f83b 	bl	80a074c <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE15parseAnythingToEPNS_11JsonVariantE>
 80a06d6:	b380      	cbz	r0, 80a073a <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0xcc>
  bool set_impl(TStringRef key, TValueRef value) {
    // ignore null key
    if (Internals::StringTraits<TStringRef>::is_null(key)) return false;

    // search a matching key
    iterator it = findKey<TStringRef>(key);
 80a06d8:	4621      	mov	r1, r4
 80a06da:	4628      	mov	r0, r5
 80a06dc:	f7ff ffb1 	bl	80a0642 <_ZN11ArduinoJson10JsonObject7findKeyIPKcEENS_9Internals12ListIteratorINS_8JsonPairEEET_>
 80a06e0:	4682      	mov	sl, r0
    if (it == end()) {
 80a06e2:	b998      	cbnz	r0, 80a070c <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0x9e>
    for (node_type *node = _firstNode; node; node = node->next) nodeCount++;
    return nodeCount;
  }

  iterator add() {
    node_type *newNode = new (_buffer) node_type();
 80a06e4:	6829      	ldr	r1, [r5, #0]
 80a06e6:	2020      	movs	r0, #32
 80a06e8:	f7ff fd54 	bl	80a0194 <_ZN11ArduinoJson9Internals19JsonBufferAllocatednwEjPNS_10JsonBufferE>
 80a06ec:	b118      	cbz	r0, 80a06f6 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0x88>

// A node for a singly-linked list.
// Used by List<T> and its iterators.
template <typename T>
struct ListNode : public Internals::JsonBufferAllocated {
  ListNode() throw() : next(NULL) {}
 80a06ee:	f8c0 a000 	str.w	sl, [r0]
 80a06f2:	f880 a010 	strb.w	sl, [r0, #16]

    if (_firstNode) {
 80a06f6:	686b      	ldr	r3, [r5, #4]
 80a06f8:	b12b      	cbz	r3, 80a0706 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0x98>
      node_type *lastNode = _firstNode;
      while (lastNode->next) lastNode = lastNode->next;
 80a06fa:	681a      	ldr	r2, [r3, #0]
 80a06fc:	b10a      	cbz	r2, 80a0702 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0x94>
 80a06fe:	4613      	mov	r3, r2
 80a0700:	e7fb      	b.n	80a06fa <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0x8c>
      lastNode->next = newNode;
 80a0702:	6018      	str	r0, [r3, #0]
 80a0704:	e000      	b.n	80a0708 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0x9a>
    } else {
      _firstNode = newNode;
 80a0706:	6068      	str	r0, [r5, #4]
      // add the key
      it = Internals::List<JsonPair>::add();
      if (it == end()) return false;
 80a0708:	b1b8      	cbz	r0, 80a073a <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0xcc>
template <typename Char>
struct ValueSaver<
    Char*, typename EnableIf<!StringTraits<Char*>::should_duplicate>::type> {
  template <typename Destination>
  static bool save(JsonBuffer*, Destination& dest, Char* source) {
    dest = reinterpret_cast<const char*>(source);
 80a070a:	6084      	str	r4, [r0, #8]

template <typename Source, typename Enable = void>
struct ValueSaver {
  template <typename Destination>
  static bool save(JsonBuffer*, Destination& destination, Source source) {
    destination = source;
 80a070c:	f100 0410 	add.w	r4, r0, #16
 80a0710:	e898 000f 	ldmia.w	r8, {r0, r1, r2, r3}
 80a0714:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 80a0718:	217d      	movs	r1, #125	; 0x7d
 80a071a:	4638      	mov	r0, r7
 80a071c:	f7ff ff17 	bl	80a054e <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE3eatERS4_c>
    if (!object.set(key, value)) goto ERROR_NO_MEMORY;

    // 3 - More keys/values?
    if (eat('}')) goto SUCCESS_NON_EMPTY_OBJECT;
 80a0720:	b930      	cbnz	r0, 80a0730 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0xc2>
 80a0722:	212c      	movs	r1, #44	; 0x2c
 80a0724:	4638      	mov	r0, r7
 80a0726:	f7ff ff12 	bl	80a054e <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE3eatERS4_c>
    if (!eat(',')) goto ERROR_MISSING_COMMA;
 80a072a:	2800      	cmp	r0, #0
 80a072c:	d1c1      	bne.n	80a06b2 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0x44>
 80a072e:	e004      	b.n	80a073a <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0xcc>
  }

SUCCESS_EMPTY_OBJECT:
SUCCESS_NON_EMPTY_OBJECT:
  _nestingLimit++;
 80a0730:	7b33      	ldrb	r3, [r6, #12]
  return object;
 80a0732:	4628      	mov	r0, r5
    if (!eat(',')) goto ERROR_MISSING_COMMA;
  }

SUCCESS_EMPTY_OBJECT:
SUCCESS_NON_EMPTY_OBJECT:
  _nestingLimit++;
 80a0734:	3301      	adds	r3, #1
 80a0736:	7333      	strb	r3, [r6, #12]
  return object;
 80a0738:	e005      	b.n	80a0746 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0xd8>
ERROR_INVALID_VALUE:
ERROR_MISSING_BRACE:
ERROR_MISSING_COLON:
ERROR_MISSING_COMMA:
ERROR_NO_MEMORY:
  return JsonObject::invalid();
 80a073a:	f7ff fd49 	bl	80a01d0 <_ZN11ArduinoJson10JsonObject7invalidEv>
 80a073e:	e002      	b.n	80a0746 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0xd8>
  return ptr ? *ptr : JsonObject::invalid();
 80a0740:	f7ff fd46 	bl	80a01d0 <_ZN11ArduinoJson10JsonObject7invalidEv>
 80a0744:	e7a5      	b.n	80a0692 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv+0x24>
}
 80a0746:	b004      	add	sp, #16
 80a0748:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080a074c <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE15parseAnythingToEPNS_11JsonVariantE>:
  return true;
}

template <typename TReader, typename TWriter>
inline bool
ArduinoJson::Internals::JsonParser<TReader, TWriter>::parseAnythingTo(
 80a074c:	b570      	push	{r4, r5, r6, lr}
 80a074e:	4606      	mov	r6, r0
    JsonVariant *destination) {
  skipSpacesAndComments(_reader);
 80a0750:	3004      	adds	r0, #4
  return true;
}

template <typename TReader, typename TWriter>
inline bool
ArduinoJson::Internals::JsonParser<TReader, TWriter>::parseAnythingTo(
 80a0752:	460d      	mov	r5, r1
    JsonVariant *destination) {
  skipSpacesAndComments(_reader);
 80a0754:	f7ff fecb 	bl	80a04ee <_ZN11ArduinoJson9Internals21skipSpacesAndCommentsINS0_17CharPointerTraitsIcE6ReaderEEEvRT_>
    void move() {
      ++_ptr;
    }

    char current() const {
      return char(_ptr[0]);
 80a0758:	6873      	ldr	r3, [r6, #4]
 80a075a:	781c      	ldrb	r4, [r3, #0]

  switch (_reader.current()) {
 80a075c:	2c5b      	cmp	r4, #91	; 0x5b
 80a075e:	d002      	beq.n	80a0766 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE15parseAnythingToEPNS_11JsonVariantE+0x1a>
 80a0760:	2c7b      	cmp	r4, #123	; 0x7b
 80a0762:	d009      	beq.n	80a0778 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE15parseAnythingToEPNS_11JsonVariantE+0x2c>
 80a0764:	e013      	b.n	80a078e <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE15parseAnythingToEPNS_11JsonVariantE+0x42>
}

template <typename TReader, typename TWriter>
inline bool ArduinoJson::Internals::JsonParser<TReader, TWriter>::parseArrayTo(
    JsonVariant *destination) {
  JsonArray &array = parseArray();
 80a0766:	4630      	mov	r0, r6
 80a0768:	f000 f827 	bl	80a07ba <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv>
  if (!array.success()) return false;
 80a076c:	6803      	ldr	r3, [r0, #0]
 80a076e:	b90b      	cbnz	r3, 80a0774 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE15parseAnythingToEPNS_11JsonVariantE+0x28>
 80a0770:	2400      	movs	r4, #0
 80a0772:	e020      	b.n	80a07b6 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE15parseAnythingToEPNS_11JsonVariantE+0x6a>

  *destination = array;
 80a0774:	2306      	movs	r3, #6
 80a0776:	e006      	b.n	80a0786 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE15parseAnythingToEPNS_11JsonVariantE+0x3a>
}

template <typename TReader, typename TWriter>
inline bool ArduinoJson::Internals::JsonParser<TReader, TWriter>::parseObjectTo(
    JsonVariant *destination) {
  JsonObject &object = parseObject();
 80a0778:	4630      	mov	r0, r6
 80a077a:	f7ff ff78 	bl	80a066e <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv>
  if (!object.success()) return false;
 80a077e:	6803      	ldr	r3, [r0, #0]
 80a0780:	2b00      	cmp	r3, #0
 80a0782:	d0f5      	beq.n	80a0770 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE15parseAnythingToEPNS_11JsonVariantE+0x24>

  *destination = object;
 80a0784:	2307      	movs	r3, #7
 80a0786:	702b      	strb	r3, [r5, #0]
 80a0788:	60a8      	str	r0, [r5, #8]
  return true;
 80a078a:	2401      	movs	r4, #1
 80a078c:	e013      	b.n	80a07b6 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE15parseAnythingToEPNS_11JsonVariantE+0x6a>
    return isBetween(c, '0', '9') || isBetween(c, '_', 'z') ||
           isBetween(c, 'A', 'Z') || c == '+' || c == '-' || c == '.';
  }

  static inline bool isQuote(char c) {
    return c == '\'' || c == '\"';
 80a078e:	2c27      	cmp	r4, #39	; 0x27
 80a0790:	d004      	beq.n	80a079c <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE15parseAnythingToEPNS_11JsonVariantE+0x50>
 80a0792:	f1a4 0322 	sub.w	r3, r4, #34	; 0x22
 80a0796:	425c      	negs	r4, r3
 80a0798:	415c      	adcs	r4, r3
 80a079a:	e000      	b.n	80a079e <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE15parseAnythingToEPNS_11JsonVariantE+0x52>
 80a079c:	2401      	movs	r4, #1

template <typename TReader, typename TWriter>
inline bool ArduinoJson::Internals::JsonParser<TReader, TWriter>::parseStringTo(
    JsonVariant *destination) {
  bool hasQuotes = isQuote(_reader.current());
  const char *value = parseString();
 80a079e:	4630      	mov	r0, r6
 80a07a0:	f7ff fee4 	bl	80a056c <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseStringEv>
  if (value == NULL) return false;
 80a07a4:	2800      	cmp	r0, #0
 80a07a6:	d0e3      	beq.n	80a0770 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE15parseAnythingToEPNS_11JsonVariantE+0x24>
  if (hasQuotes) {
 80a07a8:	b114      	cbz	r4, 80a07b0 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE15parseAnythingToEPNS_11JsonVariantE+0x64>
    *destination = value;
 80a07aa:	2302      	movs	r3, #2
 80a07ac:	702b      	strb	r3, [r5, #0]
 80a07ae:	e001      	b.n	80a07b4 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE15parseAnythingToEPNS_11JsonVariantE+0x68>
  } else {
    *destination = RawJson(value);
 80a07b0:	2401      	movs	r4, #1
 80a07b2:	702c      	strb	r4, [r5, #0]
 80a07b4:	60a8      	str	r0, [r5, #8]
      return parseObjectTo(destination);

    default:
      return parseStringTo(destination);
  }
}
 80a07b6:	4620      	mov	r0, r4
 80a07b8:	bd70      	pop	{r4, r5, r6, pc}

080a07ba <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv>:

template <typename TReader, typename TWriter>
inline ArduinoJson::JsonArray &
ArduinoJson::Internals::JsonParser<TReader, TWriter>::parseArray() {
 80a07ba:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if (_nestingLimit == 0) return JsonArray::invalid();
 80a07be:	7b03      	ldrb	r3, [r0, #12]
  }
}

template <typename TReader, typename TWriter>
inline ArduinoJson::JsonArray &
ArduinoJson::Internals::JsonParser<TReader, TWriter>::parseArray() {
 80a07c0:	b085      	sub	sp, #20
 80a07c2:	4606      	mov	r6, r0
  if (_nestingLimit == 0) return JsonArray::invalid();
 80a07c4:	2b00      	cmp	r3, #0
 80a07c6:	d049      	beq.n	80a085c <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0xa2>
  _nestingLimit--;

  // Create an empty array
  JsonArray &array = _buffer->createArray();
 80a07c8:	6804      	ldr	r4, [r0, #0]

template <typename TReader, typename TWriter>
inline ArduinoJson::JsonArray &
ArduinoJson::Internals::JsonParser<TReader, TWriter>::parseArray() {
  if (_nestingLimit == 0) return JsonArray::invalid();
  _nestingLimit--;
 80a07ca:	3b01      	subs	r3, #1
 80a07cc:	7303      	strb	r3, [r0, #12]
#pragma once

#include "Deserialization/JsonParser.hpp"

inline ArduinoJson::JsonArray &ArduinoJson::JsonBuffer::createArray() {
  JsonArray *ptr = new (this) JsonArray(this);
 80a07ce:	4621      	mov	r1, r4
 80a07d0:	2008      	movs	r0, #8
 80a07d2:	f7ff fcdf 	bl	80a0194 <_ZN11ArduinoJson9Internals19JsonBufferAllocatednwEjPNS_10JsonBufferE>
 80a07d6:	2800      	cmp	r0, #0
 80a07d8:	d043      	beq.n	80a0862 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0xa8>
  // Creates an empty List<T> attached to a JsonBuffer.
  // The JsonBuffer allows to allocate new nodes.
  // When buffer is NULL, the List is not able to grow and success() returns
  // false. This is used to identify bad memory allocations and parsing
  // failures.
  explicit List(JsonBuffer *buffer) : _buffer(buffer), _firstNode(NULL) {}
 80a07da:	2300      	movs	r3, #0
 80a07dc:	6004      	str	r4, [r0, #0]
 80a07de:	6043      	str	r3, [r0, #4]
 private:
  JsonParser &operator=(const JsonParser &);  // non-copiable

  static bool eat(TReader &, char charToSkip);
  FORCE_INLINE bool eat(char charToSkip) {
    return eat(_reader, charToSkip);
 80a07e0:	f106 0904 	add.w	r9, r6, #4
 80a07e4:	4604      	mov	r4, r0
 80a07e6:	215b      	movs	r1, #91	; 0x5b
 80a07e8:	4648      	mov	r0, r9
 80a07ea:	f7ff feb0 	bl	80a054e <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE3eatERS4_c>

  // Create an empty array
  JsonArray &array = _buffer->createArray();

  // Check opening braket
  if (!eat('[')) goto ERROR_MISSING_BRACKET;
 80a07ee:	b3a8      	cbz	r0, 80a085c <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0xa2>
 80a07f0:	215d      	movs	r1, #93	; 0x5d
 80a07f2:	4648      	mov	r0, r9
 80a07f4:	f7ff feab 	bl	80a054e <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE3eatERS4_c>
  if (eat(']')) goto SUCCESS_EMPTY_ARRAY;
 80a07f8:	bb58      	cbnz	r0, 80a0852 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0x98>
 80a07fa:	4607      	mov	r7, r0

  // Read each value
  for (;;) {
    // 1 - Parse value
    JsonVariant value;
    if (!parseAnythingTo(&value)) goto ERROR_INVALID_VALUE;
 80a07fc:	46e8      	mov	r8, sp
 80a07fe:	4641      	mov	r1, r8
 80a0800:	4630      	mov	r0, r6
 80a0802:	f88d 7000 	strb.w	r7, [sp]
 80a0806:	f7ff ffa1 	bl	80a074c <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE15parseAnythingToEPNS_11JsonVariantE>
 80a080a:	b338      	cbz	r0, 80a085c <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0xa2>
    for (node_type *node = _firstNode; node; node = node->next) nodeCount++;
    return nodeCount;
  }

  iterator add() {
    node_type *newNode = new (_buffer) node_type();
 80a080c:	6821      	ldr	r1, [r4, #0]
 80a080e:	2018      	movs	r0, #24
 80a0810:	f7ff fcc0 	bl	80a0194 <_ZN11ArduinoJson9Internals19JsonBufferAllocatednwEjPNS_10JsonBufferE>
 80a0814:	b108      	cbz	r0, 80a081a <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0x60>
 80a0816:	6007      	str	r7, [r0, #0]
 80a0818:	7207      	strb	r7, [r0, #8]

    if (_firstNode) {
 80a081a:	6863      	ldr	r3, [r4, #4]
 80a081c:	b12b      	cbz	r3, 80a082a <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0x70>
      node_type *lastNode = _firstNode;
      while (lastNode->next) lastNode = lastNode->next;
 80a081e:	681a      	ldr	r2, [r3, #0]
 80a0820:	b10a      	cbz	r2, 80a0826 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0x6c>
 80a0822:	4613      	mov	r3, r2
 80a0824:	e7fb      	b.n	80a081e <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0x64>
      lastNode->next = newNode;
 80a0826:	6018      	str	r0, [r3, #0]
 80a0828:	e000      	b.n	80a082c <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0x72>
    } else {
      _firstNode = newNode;
 80a082a:	6060      	str	r0, [r4, #4]
  }

  template <typename TValueRef>
  bool add_impl(TValueRef value) {
    iterator it = Internals::List<JsonVariant>::add();
    if (it == end()) return false;
 80a082c:	b1b0      	cbz	r0, 80a085c <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0xa2>
 80a082e:	f100 0508 	add.w	r5, r0, #8
 80a0832:	e898 000f 	ldmia.w	r8, {r0, r1, r2, r3}
 80a0836:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
 80a083a:	215d      	movs	r1, #93	; 0x5d
 80a083c:	4648      	mov	r0, r9
 80a083e:	f7ff fe86 	bl	80a054e <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE3eatERS4_c>
    if (!array.add(value)) goto ERROR_NO_MEMORY;

    // 2 - More values?
    if (eat(']')) goto SUCCES_NON_EMPTY_ARRAY;
 80a0842:	b930      	cbnz	r0, 80a0852 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0x98>
 80a0844:	212c      	movs	r1, #44	; 0x2c
 80a0846:	4648      	mov	r0, r9
 80a0848:	f7ff fe81 	bl	80a054e <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE3eatERS4_c>
    if (!eat(',')) goto ERROR_MISSING_COMMA;
 80a084c:	2800      	cmp	r0, #0
 80a084e:	d1d6      	bne.n	80a07fe <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0x44>
 80a0850:	e004      	b.n	80a085c <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0xa2>
  }

SUCCESS_EMPTY_ARRAY:
SUCCES_NON_EMPTY_ARRAY:
  _nestingLimit++;
 80a0852:	7b33      	ldrb	r3, [r6, #12]
  return array;
 80a0854:	4620      	mov	r0, r4
    if (!eat(',')) goto ERROR_MISSING_COMMA;
  }

SUCCESS_EMPTY_ARRAY:
SUCCES_NON_EMPTY_ARRAY:
  _nestingLimit++;
 80a0856:	3301      	adds	r3, #1
 80a0858:	7333      	strb	r3, [r6, #12]
  return array;
 80a085a:	e005      	b.n	80a0868 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0xae>

ERROR_INVALID_VALUE:
ERROR_MISSING_BRACKET:
ERROR_MISSING_COMMA:
ERROR_NO_MEMORY:
  return JsonArray::invalid();
 80a085c:	f7ff fca2 	bl	80a01a4 <_ZN11ArduinoJson9JsonArray7invalidEv>
 80a0860:	e002      	b.n	80a0868 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0xae>
  return ptr ? *ptr : JsonArray::invalid();
 80a0862:	f7ff fc9f 	bl	80a01a4 <_ZN11ArduinoJson9JsonArray7invalidEv>
 80a0866:	e7bb      	b.n	80a07e0 <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE10parseArrayEv+0x26>
}
 80a0868:	b005      	add	sp, #20
 80a086a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

080a086e <_ZNK11ArduinoJson10JsonObject7findKeyIPKcEENS_9Internals17ListConstIteratorINS_8JsonPairEEET_>:
      if (Internals::StringTraits<TStringRef>::equals(key, it->key)) break;
    }
    return it;
  }
  template <typename TStringRef>
  const_iterator findKey(TStringRef key) const {
 80a086e:	b508      	push	{r3, lr}
    return const_cast<JsonObject*>(this)->findKey<TStringRef>(key);
 80a0870:	f7ff fee7 	bl	80a0642 <_ZN11ArduinoJson10JsonObject7findKeyIPKcEENS_9Internals12ListIteratorINS_8JsonPairEEET_>
  }
 80a0874:	bd08      	pop	{r3, pc}
	...

080a0878 <_ZNK11ArduinoJson10JsonObject8get_implIPKcS3_EENS_9Internals13JsonVariantAsIT0_E4typeET_>:

  template <typename TStringRef, typename TValue>
  typename Internals::JsonVariantAs<TValue>::type get_impl(
 80a0878:	b538      	push	{r3, r4, r5, lr}
      TStringRef key) const {
    const_iterator it = findKey<TStringRef>(key);
 80a087a:	f7ff fff8 	bl	80a086e <_ZNK11ArduinoJson10JsonObject7findKeyIPKcEENS_9Internals17ListConstIteratorINS_8JsonPairEEET_>
    return it != end() ? it->value.as<TValue>()
                       : Internals::JsonVariantDefault<TValue>::get();
 80a087e:	4604      	mov	r4, r0
 80a0880:	b168      	cbz	r0, 80a089e <_ZNK11ArduinoJson10JsonObject8get_implIPKcS3_EENS_9Internals13JsonVariantAsIT0_E4typeET_+0x26>
  }
}

inline const char *JsonVariant::variantAsString() const {
  using namespace Internals;
  if (_type == JSON_UNPARSED && _content.asString &&
 80a0882:	7c05      	ldrb	r5, [r0, #16]
 80a0884:	2d01      	cmp	r5, #1
 80a0886:	d105      	bne.n	80a0894 <_ZNK11ArduinoJson10JsonObject8get_implIPKcS3_EENS_9Internals13JsonVariantAsIT0_E4typeET_+0x1c>
 80a0888:	6981      	ldr	r1, [r0, #24]
 80a088a:	b119      	cbz	r1, 80a0894 <_ZNK11ArduinoJson10JsonObject8get_implIPKcS3_EENS_9Internals13JsonVariantAsIT0_E4typeET_+0x1c>
      !strcmp("null", _content.asString))
 80a088c:	4805      	ldr	r0, [pc, #20]	; (80a08a4 <_ZNK11ArduinoJson10JsonObject8get_implIPKcS3_EENS_9Internals13JsonVariantAsIT0_E4typeET_+0x2c>)
 80a088e:	f005 fa08 	bl	80a5ca2 <strcmp>
  }
}

inline const char *JsonVariant::variantAsString() const {
  using namespace Internals;
  if (_type == JSON_UNPARSED && _content.asString &&
 80a0892:	b130      	cbz	r0, 80a08a2 <_ZNK11ArduinoJson10JsonObject8get_implIPKcS3_EENS_9Internals13JsonVariantAsIT0_E4typeET_+0x2a>
      !strcmp("null", _content.asString))
    return NULL;
  if (_type == JSON_STRING || _type == JSON_UNPARSED) return _content.asString;
 80a0894:	3d01      	subs	r5, #1
 80a0896:	2d01      	cmp	r5, #1
 80a0898:	d802      	bhi.n	80a08a0 <_ZNK11ArduinoJson10JsonObject8get_implIPKcS3_EENS_9Internals13JsonVariantAsIT0_E4typeET_+0x28>
 80a089a:	69a0      	ldr	r0, [r4, #24]
 80a089c:	bd38      	pop	{r3, r4, r5, pc}
 80a089e:	bd38      	pop	{r3, r4, r5, pc}
 80a08a0:	2000      	movs	r0, #0
  }
 80a08a2:	bd38      	pop	{r3, r4, r5, pc}
 80a08a4:	080a601f 	.word	0x080a601f

080a08a8 <_Z33azureFunctionEventResponseHandlerPKcS0_>:
};

char msg[600];
// This function handles the webhook-response from the Azure Function
void azureFunctionEventResponseHandler(const char *event, const char *data)
{
 80a08a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a08ac:	460c      	mov	r4, r1
 80a08ae:	4605      	mov	r5, r0
 80a08b0:	b086      	sub	sp, #24
  Serial.printlnf("azureFunctionEventResponseHandler\nevent: %s\ndata: %s", event, data);
 80a08b2:	f003 fea9 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a08b6:	9400      	str	r4, [sp, #0]
 80a08b8:	462b      	mov	r3, r5
 80a08ba:	4a34      	ldr	r2, [pc, #208]	; (80a098c <_Z33azureFunctionEventResponseHandlerPKcS0_+0xe4>)
 80a08bc:	2101      	movs	r1, #1
 80a08be:	f003 fa5c 	bl	80a3d7a <_ZN5Print11printf_implEbPKcz>
  if (data == NULL) return;
 80a08c2:	2c00      	cmp	r4, #0
 80a08c4:	d05f      	beq.n	80a0986 <_Z33azureFunctionEventResponseHandlerPKcS0_+0xde>

  // remove all backslashes ('\') added by particle webhook-response
  int dataLen = strlen(data);
 80a08c6:	4620      	mov	r0, r4
 80a08c8:	f005 fa19 	bl	80a5cfe <strlen>
  int j = 0;
  for (int i = 1; i < dataLen-1; i++)
  {
    if (data[i] == '\\') continue;
    msg[j++] = data[i];
 80a08cc:	4d30      	ldr	r5, [pc, #192]	; (80a0990 <_Z33azureFunctionEventResponseHandlerPKcS0_+0xe8>)
 80a08ce:	1c62      	adds	r2, r4, #1
  Serial.printlnf("azureFunctionEventResponseHandler\nevent: %s\ndata: %s", event, data);
  if (data == NULL) return;

  // remove all backslashes ('\') added by particle webhook-response
  int dataLen = strlen(data);
  int j = 0;
 80a08d0:	2300      	movs	r3, #0
  for (int i = 1; i < dataLen-1; i++)
 80a08d2:	3801      	subs	r0, #1
 80a08d4:	1b11      	subs	r1, r2, r4
 80a08d6:	4288      	cmp	r0, r1
 80a08d8:	dd06      	ble.n	80a08e8 <_Z33azureFunctionEventResponseHandlerPKcS0_+0x40>
  {
    if (data[i] == '\\') continue;
 80a08da:	f812 1b01 	ldrb.w	r1, [r2], #1
 80a08de:	295c      	cmp	r1, #92	; 0x5c
 80a08e0:	d0f8      	beq.n	80a08d4 <_Z33azureFunctionEventResponseHandlerPKcS0_+0x2c>
    msg[j++] = data[i];
 80a08e2:	54e9      	strb	r1, [r5, r3]
 80a08e4:	3301      	adds	r3, #1
  if (data == NULL) return;

  // remove all backslashes ('\') added by particle webhook-response
  int dataLen = strlen(data);
  int j = 0;
  for (int i = 1; i < dataLen-1; i++)
 80a08e6:	e7f5      	b.n	80a08d4 <_Z33azureFunctionEventResponseHandlerPKcS0_+0x2c>
  {
    if (data[i] == '\\') continue;
    msg[j++] = data[i];
  }
  msg[j] = '\0'; // Terminate the string
 80a08e8:	4d29      	ldr	r5, [pc, #164]	; (80a0990 <_Z33azureFunctionEventResponseHandlerPKcS0_+0xe8>)
 80a08ea:	2400      	movs	r4, #0
 80a08ec:	54ec      	strb	r4, [r5, r3]

  //strcpy(msg, data);
  Serial.println("------------------------------------");
 80a08ee:	f003 fe8b 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a08f2:	4928      	ldr	r1, [pc, #160]	; (80a0994 <_Z33azureFunctionEventResponseHandlerPKcS0_+0xec>)
 80a08f4:	f003 fa01 	bl	80a3cfa <_ZN5Print7printlnEPKc>
  Serial.println(msg);
 80a08f8:	f003 fe86 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a08fc:	4629      	mov	r1, r5
 80a08fe:	f003 f9fc 	bl	80a3cfa <_ZN5Print7printlnEPKc>
  Serial.println(strlen(msg));
 80a0902:	f003 fe81 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0906:	4606      	mov	r6, r0
 80a0908:	4628      	mov	r0, r5
 80a090a:	f005 f9f8 	bl	80a5cfe <strlen>
 80a090e:	220a      	movs	r2, #10
 80a0910:	4601      	mov	r1, r0
 80a0912:	4630      	mov	r0, r6
 80a0914:	f003 fa27 	bl	80a3d66 <_ZN5Print7printlnEji>
  Serial.println("------------------------------------");
 80a0918:	f003 fe76 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a091c:	491d      	ldr	r1, [pc, #116]	; (80a0994 <_Z33azureFunctionEventResponseHandlerPKcS0_+0xec>)
 80a091e:	f003 f9ec 	bl	80a3cfa <_ZN5Print7printlnEPKc>

  // Resets the buffer.
  // USE WITH CAUTION: this invalidates all previously allocated data
  void clear() {
    _size = 0;
 80a0922:	4b1d      	ldr	r3, [pc, #116]	; (80a0998 <_Z33azureFunctionEventResponseHandlerPKcS0_+0xf0>)
  // JsonObject& parseObject(TString);
  // TString = const char*, const char[N], const FlashStringHelper*
  template <typename TString>
  JsonObject &parseObject(
      TString *json, uint8_t nestingLimit = ARDUINOJSON_DEFAULT_NESTING_LIMIT) {
    return Internals::makeParser(that(), json, nestingLimit).parseObject();
 80a0924:	a802      	add	r0, sp, #8
 80a0926:	60dc      	str	r4, [r3, #12]
  JsonParser(JsonBuffer *buffer, TReader reader, TWriter writer,
             uint8_t nestingLimit)
      : _buffer(buffer),
        _reader(reader),
        _writer(writer),
        _nestingLimit(nestingLimit) {}
 80a0928:	9302      	str	r3, [sp, #8]
 80a092a:	2332      	movs	r3, #50	; 0x32
 80a092c:	f88d 3014 	strb.w	r3, [sp, #20]
 80a0930:	9503      	str	r5, [sp, #12]
 80a0932:	9504      	str	r5, [sp, #16]
 80a0934:	f7ff fe9b 	bl	80a066e <_ZN11ArduinoJson9Internals10JsonParserINS0_17CharPointerTraitsIcE6ReaderENS0_12StringWriterIcEEE11parseObjectEv>

  jsonBuffer.clear(); // Aha! This is what I needed to fix multiple FindItem calls.
  JsonObject& responseJson = jsonBuffer.parseObject(msg);

  if (!responseJson.success()) {
 80a0938:	6803      	ldr	r3, [r0, #0]
 80a093a:	4606      	mov	r6, r0
 80a093c:	b92b      	cbnz	r3, 80a094a <_Z33azureFunctionEventResponseHandlerPKcS0_+0xa2>
    Serial.println("Parsing JSON failed");
 80a093e:	f003 fe63 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0942:	4916      	ldr	r1, [pc, #88]	; (80a099c <_Z33azureFunctionEventResponseHandlerPKcS0_+0xf4>)
 80a0944:	f003 f9d9 	bl	80a3cfa <_ZN5Print7printlnEPKc>
    return;
 80a0948:	e01d      	b.n	80a0986 <_Z33azureFunctionEventResponseHandlerPKcS0_+0xde>
  // TKey = char*, const char*, const FlashStringHelper*
  // TValue = bool, char, long, int, short, float, double,
  //          std::string, String, JsonArray, JsonObject
  template <typename TValue, typename TString>
  typename Internals::JsonVariantAs<TValue>::type get(TString* key) const {
    return get_impl<TString*, TValue>(key);
 80a094a:	4915      	ldr	r1, [pc, #84]	; (80a09a0 <_Z33azureFunctionEventResponseHandlerPKcS0_+0xf8>)
 80a094c:	f7ff ff94 	bl	80a0878 <_ZNK11ArduinoJson10JsonObject8get_implIPKcS3_EENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0950:	4605      	mov	r5, r0
  }

  const char* cmd = responseJson["Command"];

  Serial.print("Command: ");
 80a0952:	f003 fe59 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0956:	4913      	ldr	r1, [pc, #76]	; (80a09a4 <_Z33azureFunctionEventResponseHandlerPKcS0_+0xfc>)
 80a0958:	f003 f9bc 	bl	80a3cd4 <_ZN5Print5printEPKc>
  Serial.println(cmd);
 80a095c:	f003 fe54 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0960:	4629      	mov	r1, r5
 80a0962:	f003 f9ca 	bl	80a3cfa <_ZN5Print7printlnEPKc>
 80a0966:	4f10      	ldr	r7, [pc, #64]	; (80a09a8 <_Z33azureFunctionEventResponseHandlerPKcS0_+0x100>)

  for (ResponseHandler responseHandler : responseHandlers) {
    if (strcmp(cmd, responseHandler.command) == 0) {
 80a0968:	59e1      	ldr	r1, [r4, r7]
 80a096a:	4628      	mov	r0, r5
 80a096c:	eb07 0804 	add.w	r8, r7, r4
 80a0970:	f005 f997 	bl	80a5ca2 <strcmp>
 80a0974:	b920      	cbnz	r0, 80a0980 <_Z33azureFunctionEventResponseHandlerPKcS0_+0xd8>
      responseHandler.handle(responseJson);
 80a0976:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80a097a:	4630      	mov	r0, r6
 80a097c:	4798      	blx	r3
      break;
 80a097e:	e002      	b.n	80a0986 <_Z33azureFunctionEventResponseHandlerPKcS0_+0xde>
 80a0980:	3408      	adds	r4, #8
  const char* cmd = responseJson["Command"];

  Serial.print("Command: ");
  Serial.println(cmd);

  for (ResponseHandler responseHandler : responseHandlers) {
 80a0982:	2c58      	cmp	r4, #88	; 0x58
 80a0984:	d1f0      	bne.n	80a0968 <_Z33azureFunctionEventResponseHandlerPKcS0_+0xc0>
    if (strcmp(cmd, responseHandler.command) == 0) {
      responseHandler.handle(responseJson);
      break;
    }
  }
}
 80a0986:	b006      	add	sp, #24
 80a0988:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a098c:	080a6024 	.word	0x080a6024
 80a0990:	2000050c 	.word	0x2000050c
 80a0994:	080a6059 	.word	0x080a6059
 80a0998:	20000768 	.word	0x20000768
 80a099c:	080a607e 	.word	0x080a607e
 80a09a0:	080a6303 	.word	0x080a6303
 80a09a4:	080a6092 	.word	0x080a6092
 80a09a8:	20000344 	.word	0x20000344

080a09ac <_Z29unknownCommandResponseHandlerRN11ArduinoJson10JsonObjectE>:
  matrix.show();
  */
}

void unknownCommandResponseHandler(JsonObject& json)
{
 80a09ac:	b510      	push	{r4, lr}
 80a09ae:	4604      	mov	r4, r0
  Serial.println("unknownCommandResponseHandler");
 80a09b0:	f003 fe2a 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a09b4:	4907      	ldr	r1, [pc, #28]	; (80a09d4 <_Z29unknownCommandResponseHandlerRN11ArduinoJson10JsonObjectE+0x28>)
 80a09b6:	f003 f9a0 	bl	80a3cfa <_ZN5Print7printlnEPKc>
 80a09ba:	4907      	ldr	r1, [pc, #28]	; (80a09d8 <_Z29unknownCommandResponseHandlerRN11ArduinoJson10JsonObjectE+0x2c>)
 80a09bc:	4620      	mov	r0, r4
 80a09be:	f7ff ff5b 	bl	80a0878 <_ZNK11ArduinoJson10JsonObject8get_implIPKcS3_EENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a09c2:	4604      	mov	r4, r0
  const char* unknownCmd = json["Command"];
  Serial.println(unknownCmd);
 80a09c4:	f003 fe20 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a09c8:	4621      	mov	r1, r4
}
 80a09ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void unknownCommandResponseHandler(JsonObject& json)
{
  Serial.println("unknownCommandResponseHandler");
  const char* unknownCmd = json["Command"];
  Serial.println(unknownCmd);
 80a09ce:	f003 b994 	b.w	80a3cfa <_ZN5Print7printlnEPKc>
 80a09d2:	bf00      	nop
 80a09d4:	080a609c 	.word	0x080a609c
 80a09d8:	080a6303 	.word	0x080a6303

080a09dc <_ZNK11ArduinoJson10JsonObject8get_implIPKcRNS_9JsonArrayEEENS_9Internals13JsonVariantAsIT0_E4typeET_>:
  const_iterator findKey(TStringRef key) const {
    return const_cast<JsonObject*>(this)->findKey<TStringRef>(key);
  }

  template <typename TStringRef, typename TValue>
  typename Internals::JsonVariantAs<TValue>::type get_impl(
 80a09dc:	b508      	push	{r3, lr}
      TStringRef key) const {
    const_iterator it = findKey<TStringRef>(key);
 80a09de:	f7ff ff46 	bl	80a086e <_ZNK11ArduinoJson10JsonObject7findKeyIPKcEENS_9Internals17ListConstIteratorINS_8JsonPairEEET_>
    return it != end() ? it->value.as<TValue>()
                       : Internals::JsonVariantDefault<TValue>::get();
 80a09e2:	b120      	cbz	r0, 80a09ee <_ZNK11ArduinoJson10JsonObject8get_implIPKcRNS_9JsonArrayEEENS_9Internals13JsonVariantAsIT0_E4typeET_+0x12>
    _content.asObject = 0;  // <- prevent warning 'maybe-uninitialized'
  }
}

inline JsonArray &JsonVariant::variantAsArray() const {
  if (_type == Internals::JSON_ARRAY) return *_content.asArray;
 80a09e4:	7c03      	ldrb	r3, [r0, #16]
 80a09e6:	2b06      	cmp	r3, #6
 80a09e8:	d101      	bne.n	80a09ee <_ZNK11ArduinoJson10JsonObject8get_implIPKcRNS_9JsonArrayEEENS_9Internals13JsonVariantAsIT0_E4typeET_+0x12>
 80a09ea:	6980      	ldr	r0, [r0, #24]
 80a09ec:	bd08      	pop	{r3, pc}
  return JsonArray::invalid();
 80a09ee:	f7ff fbd9 	bl	80a01a4 <_ZN11ArduinoJson9JsonArray7invalidEv>
  }
 80a09f2:	bd08      	pop	{r3, pc}

080a09f4 <_ZNK11ArduinoJson11JsonVariant16variantAsIntegerIiEET_v>:
  if (_type == Internals::JSON_OBJECT) return *_content.asObject;
  return JsonObject::invalid();
}

template <typename T>
inline T JsonVariant::variantAsInteger() const {
 80a09f4:	b538      	push	{r3, r4, r5, lr}
  using namespace Internals;
  switch (_type) {
 80a09f6:	7803      	ldrb	r3, [r0, #0]
 80a09f8:	2b05      	cmp	r3, #5
 80a09fa:	d825      	bhi.n	80a0a48 <_ZNK11ArduinoJson11JsonVariant16variantAsIntegerIiEET_v+0x54>
 80a09fc:	e8df f003 	tbb	[pc, r3]
 80a0a00:	0307072b 	.word	0x0307072b
 80a0a04:	0503      	.short	0x0503
    case JSON_UNDEFINED:
      return 0;
    case JSON_POSITIVE_INTEGER:
    case JSON_BOOLEAN:
      return T(_content.asInteger);
 80a0a06:	6880      	ldr	r0, [r0, #8]
 80a0a08:	bd38      	pop	{r3, r4, r5, pc}
    case JSON_NEGATIVE_INTEGER:
      return T(~_content.asInteger + 1);
 80a0a0a:	6880      	ldr	r0, [r0, #8]
 80a0a0c:	e01a      	b.n	80a0a44 <_ZNK11ArduinoJson11JsonVariant16variantAsIntegerIiEET_v+0x50>
    case JSON_STRING:
    case JSON_UNPARSED:
      return parseInteger<T>(_content.asString);
 80a0a0e:	6880      	ldr	r0, [r0, #8]

namespace ArduinoJson {
namespace Internals {
template <typename T>
T parseInteger(const char *s) {
  if (!s) return 0;  // NULL
 80a0a10:	b320      	cbz	r0, 80a0a5c <_ZNK11ArduinoJson11JsonVariant16variantAsIntegerIiEET_v+0x68>

  if (*s == 't') return 1;  // "true"
 80a0a12:	7803      	ldrb	r3, [r0, #0]
 80a0a14:	2b74      	cmp	r3, #116	; 0x74
 80a0a16:	d020      	beq.n	80a0a5a <_ZNK11ArduinoJson11JsonVariant16variantAsIntegerIiEET_v+0x66>

  T result = 0;
  bool negative_result = false;

  switch (*s) {
 80a0a18:	2b2b      	cmp	r3, #43	; 0x2b
 80a0a1a:	d004      	beq.n	80a0a26 <_ZNK11ArduinoJson11JsonVariant16variantAsIntegerIiEET_v+0x32>
 80a0a1c:	2b2d      	cmp	r3, #45	; 0x2d
 80a0a1e:	d103      	bne.n	80a0a28 <_ZNK11ArduinoJson11JsonVariant16variantAsIntegerIiEET_v+0x34>
    case '-':
      negative_result = true;
      s++;
 80a0a20:	3001      	adds	r0, #1
  T result = 0;
  bool negative_result = false;

  switch (*s) {
    case '-':
      negative_result = true;
 80a0a22:	2201      	movs	r2, #1
 80a0a24:	e001      	b.n	80a0a2a <_ZNK11ArduinoJson11JsonVariant16variantAsIntegerIiEET_v+0x36>
      s++;
      break;
    case '+':
      s++;
 80a0a26:	3001      	adds	r0, #1
  if (!s) return 0;  // NULL

  if (*s == 't') return 1;  // "true"

  T result = 0;
  bool negative_result = false;
 80a0a28:	2200      	movs	r2, #0
 80a0a2a:	1e41      	subs	r1, r0, #1
      s++;
      break;
  }

  while (isdigit(*s)) {
    result = T(result * 10 + T(*s - '0'));
 80a0a2c:	240a      	movs	r4, #10
 80a0a2e:	2000      	movs	r0, #0
    case '+':
      s++;
      break;
  }

  while (isdigit(*s)) {
 80a0a30:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 80a0a34:	3b30      	subs	r3, #48	; 0x30
 80a0a36:	b2dd      	uxtb	r5, r3
 80a0a38:	2d09      	cmp	r5, #9
 80a0a3a:	d802      	bhi.n	80a0a42 <_ZNK11ArduinoJson11JsonVariant16variantAsIntegerIiEET_v+0x4e>
    result = T(result * 10 + T(*s - '0'));
 80a0a3c:	fb04 3000 	mla	r0, r4, r0, r3
 80a0a40:	e7f6      	b.n	80a0a30 <_ZNK11ArduinoJson11JsonVariant16variantAsIntegerIiEET_v+0x3c>
    s++;
  }

  return negative_result ? T(~result + 1) : result;
 80a0a42:	b15a      	cbz	r2, 80a0a5c <_ZNK11ArduinoJson11JsonVariant16variantAsIntegerIiEET_v+0x68>
 80a0a44:	4240      	negs	r0, r0
 80a0a46:	bd38      	pop	{r3, r4, r5, pc}
    default:
      return T(_content.asFloat);
 80a0a48:	f100 0108 	add.w	r1, r0, #8
 80a0a4c:	e9d1 0100 	ldrd	r0, r1, [r1]
 80a0a50:	f004 fcde 	bl	80a5410 <__aeabi_d2iz>
 80a0a54:	bd38      	pop	{r3, r4, r5, pc}
template <typename T>
inline T JsonVariant::variantAsInteger() const {
  using namespace Internals;
  switch (_type) {
    case JSON_UNDEFINED:
      return 0;
 80a0a56:	2000      	movs	r0, #0
 80a0a58:	bd38      	pop	{r3, r4, r5, pc}
namespace Internals {
template <typename T>
T parseInteger(const char *s) {
  if (!s) return 0;  // NULL

  if (*s == 't') return 1;  // "true"
 80a0a5a:	2001      	movs	r0, #1
    case JSON_UNPARSED:
      return parseInteger<T>(_content.asString);
    default:
      return T(_content.asFloat);
  }
}
 80a0a5c:	bd38      	pop	{r3, r4, r5, pc}

080a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>:
  const_iterator findKey(TStringRef key) const {
    return const_cast<JsonObject*>(this)->findKey<TStringRef>(key);
  }

  template <typename TStringRef, typename TValue>
  typename Internals::JsonVariantAs<TValue>::type get_impl(
 80a0a5e:	b508      	push	{r3, lr}
      TStringRef key) const {
    const_iterator it = findKey<TStringRef>(key);
 80a0a60:	f7ff ff05 	bl	80a086e <_ZNK11ArduinoJson10JsonObject7findKeyIPKcEENS_9Internals17ListConstIteratorINS_8JsonPairEEET_>
    return it != end() ? it->value.as<TValue>()
                       : Internals::JsonVariantDefault<TValue>::get();
 80a0a64:	b110      	cbz	r0, 80a0a6c <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_+0xe>
  // unsigned int as<unsigned int>() const;
  // unsigned long as<unsigned long>() const;
  template <typename T>
  const typename Internals::EnableIf<Internals::IsIntegral<T>::value, T>::type
  as() const {
    return variantAsInteger<T>();
 80a0a66:	3010      	adds	r0, #16
 80a0a68:	f7ff ffc4 	bl	80a09f4 <_ZNK11ArduinoJson11JsonVariant16variantAsIntegerIiEET_v>
  }
 80a0a6c:	bd08      	pop	{r3, pc}
	...

080a0a70 <_Z23findItemResponseHandlerRN11ArduinoJson10JsonObjectE>:
    }
  }
}

void findItemResponseHandler(JsonObject& json)
{
 80a0a70:	b5f0      	push	{r4, r5, r6, r7, lr}
  // TKey = char*, const char*, const FlashStringHelper*
  // TValue = bool, char, long, int, short, float, double,
  //          std::string, String, JsonArray, JsonObject
  template <typename TValue, typename TString>
  typename Internals::JsonVariantAs<TValue>::type get(TString* key) const {
    return get_impl<TString*, TValue>(key);
 80a0a72:	4924      	ldr	r1, [pc, #144]	; (80a0b04 <_Z23findItemResponseHandlerRN11ArduinoJson10JsonObjectE+0x94>)
 80a0a74:	b089      	sub	sp, #36	; 0x24
 80a0a76:	4604      	mov	r4, r0
 80a0a78:	f7ff fff1 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>
  int count = json["Count"];
  if (count <= 0) {
 80a0a7c:	2800      	cmp	r0, #0
 80a0a7e:	dc07      	bgt.n	80a0a90 <_Z23findItemResponseHandlerRN11ArduinoJson10JsonObjectE+0x20>
    Serial.println("Item not found");
 80a0a80:	f003 fdc2 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0a84:	4920      	ldr	r1, [pc, #128]	; (80a0b08 <_Z23findItemResponseHandlerRN11ArduinoJson10JsonObjectE+0x98>)
 80a0a86:	f003 f938 	bl	80a3cfa <_ZN5Print7printlnEPKc>
    dispayItemNotFound();
 80a0a8a:	f7ff fd1b 	bl	80a04c4 <_Z18dispayItemNotFoundv>
 80a0a8e:	e037      	b.n	80a0b00 <_Z23findItemResponseHandlerRN11ArduinoJson10JsonObjectE+0x90>
 80a0a90:	491e      	ldr	r1, [pc, #120]	; (80a0b0c <_Z23findItemResponseHandlerRN11ArduinoJson10JsonObjectE+0x9c>)
 80a0a92:	4620      	mov	r0, r4
 80a0a94:	f7ff ffa2 	bl	80a09dc <_ZNK11ArduinoJson10JsonObject8get_implIPKcRNS_9JsonArrayEEENS_9Internals13JsonVariantAsIT0_E4typeET_>
    return _index < _array.size();
  }

  template <typename T>
  FORCE_INLINE typename JsonVariantAs<T>::type as() const {
    return _array.get<T>(_index);
 80a0a98:	2100      	movs	r1, #0
 80a0a9a:	f7ff fdbf 	bl	80a061c <_ZNK11ArduinoJson9JsonArray3getIRNS_10JsonObjectEEENS_9Internals13JsonVariantAsIT_E4typeEj>
 80a0a9e:	491c      	ldr	r1, [pc, #112]	; (80a0b10 <_Z23findItemResponseHandlerRN11ArduinoJson10JsonObjectE+0xa0>)
 80a0aa0:	4604      	mov	r4, r0
 80a0aa2:	f7ff fee9 	bl	80a0878 <_ZNK11ArduinoJson10JsonObject8get_implIPKcS3_EENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0aa6:	491b      	ldr	r1, [pc, #108]	; (80a0b14 <_Z23findItemResponseHandlerRN11ArduinoJson10JsonObjectE+0xa4>)
 80a0aa8:	4605      	mov	r5, r0
 80a0aaa:	4620      	mov	r0, r4
 80a0aac:	f7ff ffd7 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0ab0:	4919      	ldr	r1, [pc, #100]	; (80a0b18 <_Z23findItemResponseHandlerRN11ArduinoJson10JsonObjectE+0xa8>)
 80a0ab2:	4607      	mov	r7, r0
 80a0ab4:	4620      	mov	r0, r4
 80a0ab6:	f7ff ffd2 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0aba:	4918      	ldr	r1, [pc, #96]	; (80a0b1c <_Z23findItemResponseHandlerRN11ArduinoJson10JsonObjectE+0xac>)
 80a0abc:	4606      	mov	r6, r0
 80a0abe:	4620      	mov	r0, r4
 80a0ac0:	f7ff ffcd 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0ac4:	4604      	mov	r4, r0
    const char* item = result["Name"];
    int quantity = result["Quantity"];
    int row = result["Row"];
    int col = result["Col"];

    setDisplay(ON);
 80a0ac6:	2001      	movs	r0, #1
 80a0ac8:	f7ff fc54 	bl	80a0374 <_Z10setDisplayb>
    lightOneBox(row, col, green);
 80a0acc:	4b14      	ldr	r3, [pc, #80]	; (80a0b20 <_Z23findItemResponseHandlerRN11ArduinoJson10JsonObjectE+0xb0>)
 80a0ace:	4621      	mov	r1, r4
 80a0ad0:	881a      	ldrh	r2, [r3, #0]
 80a0ad2:	4630      	mov	r0, r6
 80a0ad4:	f7ff fc3e 	bl	80a0354 <_Z11lightOneBoxiit>

    Serial.printlnf("item: %s, row: %d, col: %d, quantity: %d", item, row, col, quantity);
 80a0ad8:	f003 fd96 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0adc:	462b      	mov	r3, r5
 80a0ade:	4a11      	ldr	r2, [pc, #68]	; (80a0b24 <_Z23findItemResponseHandlerRN11ArduinoJson10JsonObjectE+0xb4>)
 80a0ae0:	2101      	movs	r1, #1
 80a0ae2:	9702      	str	r7, [sp, #8]
 80a0ae4:	9401      	str	r4, [sp, #4]
 80a0ae6:	9600      	str	r6, [sp, #0]
 80a0ae8:	f003 f947 	bl	80a3d7a <_ZN5Print11printf_implEbPKcz>

    GFX_setString(item);
 80a0aec:	4629      	mov	r1, r5
 80a0aee:	a804      	add	r0, sp, #16
 80a0af0:	f003 f859 	bl	80a3ba6 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0af4:	a804      	add	r0, sp, #16
 80a0af6:	f002 f8d9 	bl	80a2cac <_Z13GFX_setString6String>
 80a0afa:	a804      	add	r0, sp, #16
 80a0afc:	f003 f80c 	bl	80a3b18 <_ZN6StringD1Ev>
  }
}
 80a0b00:	b009      	add	sp, #36	; 0x24
 80a0b02:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a0b04:	080a60ba 	.word	0x080a60ba
 80a0b08:	080a60c0 	.word	0x080a60c0
 80a0b0c:	080a60cf 	.word	0x080a60cf
 80a0b10:	080a60d6 	.word	0x080a60d6
 80a0b14:	080a636d 	.word	0x080a636d
 80a0b18:	080a60db 	.word	0x080a60db
 80a0b1c:	080a60df 	.word	0x080a60df
 80a0b20:	20001344 	.word	0x20001344
 80a0b24:	080a60e3 	.word	0x080a60e3

080a0b28 <_Z27showAllBoxesResponseHandlerRN11ArduinoJson10JsonObjectE>:

  Serial.printlnf("row: %d, col: %d", row, col);
}

void showAllBoxesResponseHandler(JsonObject& json)
{
 80a0b28:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a0b2c:	4605      	mov	r5, r0
  Serial.println("showAllBoxesResponseHandler");
 80a0b2e:	f003 fd6b 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0b32:	491c      	ldr	r1, [pc, #112]	; (80a0ba4 <_Z27showAllBoxesResponseHandlerRN11ArduinoJson10JsonObjectE+0x7c>)
 80a0b34:	f003 f8e1 	bl	80a3cfa <_ZN5Print7printlnEPKc>
 80a0b38:	491b      	ldr	r1, [pc, #108]	; (80a0ba8 <_Z27showAllBoxesResponseHandlerRN11ArduinoJson10JsonObjectE+0x80>)
 80a0b3a:	4628      	mov	r0, r5
 80a0b3c:	f7ff ff8f 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>

  int count = json["Count"];

  if (count == 0)
 80a0b40:	4604      	mov	r4, r0
 80a0b42:	b930      	cbnz	r0, 80a0b52 <_Z27showAllBoxesResponseHandlerRN11ArduinoJson10JsonObjectE+0x2a>
  {
    Serial.println("ShowAllBoxes returned 0 entries");
 80a0b44:	f003 fd60 	bl	80a4608 <_Z16_fetch_usbserialv>
    GFX_lightBox(row, col, colors[r(0, colorCount-1)]);
  }
  //Serial.println();

  GFX_update();
}
 80a0b48:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  int count = json["Count"];

  if (count == 0)
  {
    Serial.println("ShowAllBoxes returned 0 entries");
 80a0b4c:	4917      	ldr	r1, [pc, #92]	; (80a0bac <_Z27showAllBoxesResponseHandlerRN11ArduinoJson10JsonObjectE+0x84>)
 80a0b4e:	f003 b8d4 	b.w	80a3cfa <_ZN5Print7printlnEPKc>
 80a0b52:	4917      	ldr	r1, [pc, #92]	; (80a0bb0 <_Z27showAllBoxesResponseHandlerRN11ArduinoJson10JsonObjectE+0x88>)
 80a0b54:	4628      	mov	r0, r5
 80a0b56:	f7ff fe8f 	bl	80a0878 <_ZNK11ArduinoJson10JsonObject8get_implIPKcS3_EENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0b5a:	4680      	mov	r8, r0
    return;
  }

  const char* coordsJson = json["Coords"];
  GFX_clear();
 80a0b5c:	f002 f8e2 	bl	80a2d24 <_Z9GFX_clearv>
  for (int i = 0; i < count*2; i += 2)
  {
    int row = coordsJson[i] - 'a';
    int col = coordsJson[i+1] - 'a';
    //Serial.printf("[%d,%d],", row, col);
    GFX_lightBox(row, col, colors[r(0, colorCount-1)]);
 80a0b60:	f8df a050 	ldr.w	sl, [pc, #80]	; 80a0bb4 <_Z27showAllBoxesResponseHandlerRN11ArduinoJson10JsonObjectE+0x8c>
 80a0b64:	f8df 9050 	ldr.w	r9, [pc, #80]	; 80a0bb8 <_Z27showAllBoxesResponseHandlerRN11ArduinoJson10JsonObjectE+0x90>
  }

  const char* coordsJson = json["Coords"];
  GFX_clear();

  for (int i = 0; i < count*2; i += 2)
 80a0b68:	0067      	lsls	r7, r4, #1
 80a0b6a:	2400      	movs	r4, #0
 80a0b6c:	42bc      	cmp	r4, r7
 80a0b6e:	da14      	bge.n	80a0b9a <_Z27showAllBoxesResponseHandlerRN11ArduinoJson10JsonObjectE+0x72>
  {
    int row = coordsJson[i] - 'a';
    int col = coordsJson[i+1] - 'a';
    //Serial.printf("[%d,%d],", row, col);
    GFX_lightBox(row, col, colors[r(0, colorCount-1)]);
 80a0b70:	f89a 1000 	ldrb.w	r1, [sl]
  GFX_clear();

  for (int i = 0; i < count*2; i += 2)
  {
    int row = coordsJson[i] - 'a';
    int col = coordsJson[i+1] - 'a';
 80a0b74:	eb08 0304 	add.w	r3, r8, r4
    //Serial.printf("[%d,%d],", row, col);
    GFX_lightBox(row, col, colors[r(0, colorCount-1)]);
 80a0b78:	3901      	subs	r1, #1
 80a0b7a:	2000      	movs	r0, #0
  const char* coordsJson = json["Coords"];
  GFX_clear();

  for (int i = 0; i < count*2; i += 2)
  {
    int row = coordsJson[i] - 'a';
 80a0b7c:	f818 5004 	ldrb.w	r5, [r8, r4]
    int col = coordsJson[i+1] - 'a';
 80a0b80:	785e      	ldrb	r6, [r3, #1]
    //Serial.printf("[%d,%d],", row, col);
    GFX_lightBox(row, col, colors[r(0, colorCount-1)]);
 80a0b82:	f7ff fca7 	bl	80a04d4 <_Z1rii>
  const char* coordsJson = json["Coords"];
  GFX_clear();

  for (int i = 0; i < count*2; i += 2)
  {
    int row = coordsJson[i] - 'a';
 80a0b86:	3d61      	subs	r5, #97	; 0x61
    int col = coordsJson[i+1] - 'a';
 80a0b88:	3e61      	subs	r6, #97	; 0x61
    //Serial.printf("[%d,%d],", row, col);
    GFX_lightBox(row, col, colors[r(0, colorCount-1)]);
 80a0b8a:	f839 2010 	ldrh.w	r2, [r9, r0, lsl #1]
 80a0b8e:	4631      	mov	r1, r6
 80a0b90:	4628      	mov	r0, r5
 80a0b92:	f002 f8d3 	bl	80a2d3c <_Z12GFX_lightBoxiit>
  }

  const char* coordsJson = json["Coords"];
  GFX_clear();

  for (int i = 0; i < count*2; i += 2)
 80a0b96:	3402      	adds	r4, #2
 80a0b98:	e7e8      	b.n	80a0b6c <_Z27showAllBoxesResponseHandlerRN11ArduinoJson10JsonObjectE+0x44>
    GFX_lightBox(row, col, colors[r(0, colorCount-1)]);
  }
  //Serial.println();

  GFX_update();
}
 80a0b9a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    //Serial.printf("[%d,%d],", row, col);
    GFX_lightBox(row, col, colors[r(0, colorCount-1)]);
  }
  //Serial.println();

  GFX_update();
 80a0b9e:	f002 b8c7 	b.w	80a2d30 <_Z10GFX_updatev>
 80a0ba2:	bf00      	nop
 80a0ba4:	080a610c 	.word	0x080a610c
 80a0ba8:	080a60ba 	.word	0x080a60ba
 80a0bac:	080a6128 	.word	0x080a6128
 80a0bb0:	080a6148 	.word	0x080a6148
 80a0bb4:	20000480 	.word	0x20000480
 80a0bb8:	20001338 	.word	0x20001338

080a0bbc <_Z26setQuantityResponseHandlerRN11ArduinoJson10JsonObjectE.part.19>:
  lightOneBox(row, col, green);

  Serial.printlnf("row: %d, col: %d", row, col);
}

void updateQuantityResponseHandler(JsonObject& json)
 80a0bbc:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a0bbe:	4910      	ldr	r1, [pc, #64]	; (80a0c00 <_Z26setQuantityResponseHandlerRN11ArduinoJson10JsonObjectE.part.19+0x44>)
 80a0bc0:	f7ff ff0c 	bl	80a09dc <_ZNK11ArduinoJson10JsonObject8get_implIPKcRNS_9JsonArrayEEENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0bc4:	2100      	movs	r1, #0
 80a0bc6:	f7ff fd29 	bl	80a061c <_ZNK11ArduinoJson9JsonArray3getIRNS_10JsonObjectEEENS_9Internals13JsonVariantAsIT_E4typeEj>
 80a0bca:	490e      	ldr	r1, [pc, #56]	; (80a0c04 <_Z26setQuantityResponseHandlerRN11ArduinoJson10JsonObjectE.part.19+0x48>)
 80a0bcc:	4605      	mov	r5, r0
 80a0bce:	f7ff ff46 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0bd2:	490d      	ldr	r1, [pc, #52]	; (80a0c08 <_Z26setQuantityResponseHandlerRN11ArduinoJson10JsonObjectE.part.19+0x4c>)
 80a0bd4:	4604      	mov	r4, r0
 80a0bd6:	4628      	mov	r0, r5
 80a0bd8:	f7ff ff41 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0bdc:	4605      	mov	r5, r0

  JsonObject& result = json["Result"][0];
  int row = result["Row"];
  int col = result["Col"];

  lightOneBox(row, col, green);
 80a0bde:	4b0b      	ldr	r3, [pc, #44]	; (80a0c0c <_Z26setQuantityResponseHandlerRN11ArduinoJson10JsonObjectE.part.19+0x50>)
 80a0be0:	4601      	mov	r1, r0
 80a0be2:	881a      	ldrh	r2, [r3, #0]
 80a0be4:	4620      	mov	r0, r4
 80a0be6:	f7ff fbb5 	bl	80a0354 <_Z11lightOneBoxiit>

  Serial.printlnf("row: %d, col: %d", row, col);
 80a0bea:	f003 fd0d 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0bee:	9500      	str	r5, [sp, #0]
 80a0bf0:	4623      	mov	r3, r4
 80a0bf2:	4a07      	ldr	r2, [pc, #28]	; (80a0c10 <_Z26setQuantityResponseHandlerRN11ArduinoJson10JsonObjectE.part.19+0x54>)
 80a0bf4:	2101      	movs	r1, #1
 80a0bf6:	f003 f8c0 	bl	80a3d7a <_ZN5Print11printf_implEbPKcz>
}
 80a0bfa:	b003      	add	sp, #12
 80a0bfc:	bd30      	pop	{r4, r5, pc}
 80a0bfe:	bf00      	nop
 80a0c00:	080a60cf 	.word	0x080a60cf
 80a0c04:	080a60db 	.word	0x080a60db
 80a0c08:	080a60df 	.word	0x080a60df
 80a0c0c:	20001344 	.word	0x20001344
 80a0c10:	080a614f 	.word	0x080a614f

080a0c14 <_ZNK11ArduinoJson9JsonArray3getIiEENS_9Internals13JsonVariantAsIT_E4typeEj>:
    return set_impl<const JsonVariant &>(index, JsonVariant(value, decimals));
  }

  // Gets the value at the specified index.
  template <typename T>
  typename Internals::JsonVariantAs<T>::type get(size_t index) const {
 80a0c14:	b507      	push	{r0, r1, r2, lr}
    const_iterator it = begin() += index;
 80a0c16:	6843      	ldr	r3, [r0, #4]
 80a0c18:	a802      	add	r0, sp, #8
 80a0c1a:	f840 3d04 	str.w	r3, [r0, #-4]!
 80a0c1e:	f7ff fcf5 	bl	80a060c <_ZN11ArduinoJson9Internals17ListConstIteratorINS_11JsonVariantEEpLEj>
 80a0c22:	6800      	ldr	r0, [r0, #0]
    return it != end() ? it->as<T>() : Internals::JsonVariantDefault<T>::get();
 80a0c24:	b110      	cbz	r0, 80a0c2c <_ZNK11ArduinoJson9JsonArray3getIiEENS_9Internals13JsonVariantAsIT_E4typeEj+0x18>
 80a0c26:	3008      	adds	r0, #8
 80a0c28:	f7ff fee4 	bl	80a09f4 <_ZNK11ArduinoJson11JsonVariant16variantAsIntegerIiEET_v>
  }
 80a0c2c:	b003      	add	sp, #12
 80a0c2e:	f85d fb04 	ldr.w	pc, [sp], #4

080a0c32 <_ZNK11ArduinoJson10JsonObject8get_implIPKcbEENS_9Internals13JsonVariantAsIT0_E4typeET_>:
  const_iterator findKey(TStringRef key) const {
    return const_cast<JsonObject*>(this)->findKey<TStringRef>(key);
  }

  template <typename TStringRef, typename TValue>
  typename Internals::JsonVariantAs<TValue>::type get_impl(
 80a0c32:	b508      	push	{r3, lr}
      TStringRef key) const {
    const_iterator it = findKey<TStringRef>(key);
 80a0c34:	f7ff fe1b 	bl	80a086e <_ZNK11ArduinoJson10JsonObject7findKeyIPKcEENS_9Internals17ListConstIteratorINS_8JsonPairEEET_>
    return it != end() ? it->value.as<TValue>()
                       : Internals::JsonVariantDefault<TValue>::get();
 80a0c38:	b128      	cbz	r0, 80a0c46 <_ZNK11ArduinoJson10JsonObject8get_implIPKcbEENS_9Internals13JsonVariantAsIT0_E4typeET_+0x14>
  }
  // bool as<bool>() const
  template <typename T>
  const typename Internals::EnableIf<Internals::IsSame<T, bool>::value, T>::type
  as() const {
    return variantAsInteger<int>() != 0;
 80a0c3a:	3010      	adds	r0, #16
 80a0c3c:	f7ff feda 	bl	80a09f4 <_ZNK11ArduinoJson11JsonVariant16variantAsIntegerIiEET_v>
 80a0c40:	3000      	adds	r0, #0
 80a0c42:	bf18      	it	ne
 80a0c44:	2001      	movne	r0, #1
  }
 80a0c46:	bd08      	pop	{r3, pc}

080a0c48 <_Z22howManyResponseHandlerRN11ArduinoJson10JsonObjectE>:

  Serial.printlnf("NewItem: %s, row: %d, col: %d, quantity: %d, ExistingItem: %s", newItem, row, col, quantity, existingItem);
}

void howManyResponseHandler(JsonObject& json)
{
 80a0c48:	b510      	push	{r4, lr}
 80a0c4a:	4604      	mov	r4, r0
  Serial.println("howManyResponseHandler");
 80a0c4c:	f003 fcdc 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0c50:	490d      	ldr	r1, [pc, #52]	; (80a0c88 <_Z22howManyResponseHandlerRN11ArduinoJson10JsonObjectE+0x40>)
 80a0c52:	f003 f852 	bl	80a3cfa <_ZN5Print7printlnEPKc>
  // TKey = char*, const char*, const FlashStringHelper*
  // TValue = bool, char, long, int, short, float, double,
  //          std::string, String, JsonArray, JsonObject
  template <typename TValue, typename TString>
  typename Internals::JsonVariantAs<TValue>::type get(TString* key) const {
    return get_impl<TString*, TValue>(key);
 80a0c56:	490d      	ldr	r1, [pc, #52]	; (80a0c8c <_Z22howManyResponseHandlerRN11ArduinoJson10JsonObjectE+0x44>)
 80a0c58:	4620      	mov	r0, r4
 80a0c5a:	f7ff ffea 	bl	80a0c32 <_ZNK11ArduinoJson10JsonObject8get_implIPKcbEENS_9Internals13JsonVariantAsIT0_E4typeET_>

  if (!json["Success"]) {
 80a0c5e:	b930      	cbnz	r0, 80a0c6e <_Z22howManyResponseHandlerRN11ArduinoJson10JsonObjectE+0x26>
    Serial.println("HowMany failed");
 80a0c60:	f003 fcd2 	bl	80a4608 <_Z16_fetch_usbserialv>
  matrix.setCursor(3, 0);
  matrix.print(quantity);
  lightBox(row, col, green);
  matrix.show();
  */
}
 80a0c64:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void howManyResponseHandler(JsonObject& json)
{
  Serial.println("howManyResponseHandler");

  if (!json["Success"]) {
    Serial.println("HowMany failed");
 80a0c68:	4909      	ldr	r1, [pc, #36]	; (80a0c90 <_Z22howManyResponseHandlerRN11ArduinoJson10JsonObjectE+0x48>)
 80a0c6a:	f003 b846 	b.w	80a3cfa <_ZN5Print7printlnEPKc>
 80a0c6e:	4909      	ldr	r1, [pc, #36]	; (80a0c94 <_Z22howManyResponseHandlerRN11ArduinoJson10JsonObjectE+0x4c>)
 80a0c70:	4620      	mov	r0, r4
 80a0c72:	f7ff fef4 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0c76:	4908      	ldr	r1, [pc, #32]	; (80a0c98 <_Z22howManyResponseHandlerRN11ArduinoJson10JsonObjectE+0x50>)
 80a0c78:	4620      	mov	r0, r4
 80a0c7a:	f7ff fef0 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0c7e:	4907      	ldr	r1, [pc, #28]	; (80a0c9c <_Z22howManyResponseHandlerRN11ArduinoJson10JsonObjectE+0x54>)
 80a0c80:	4620      	mov	r0, r4
 80a0c82:	f7ff feec 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0c86:	bd10      	pop	{r4, pc}
 80a0c88:	080a6160 	.word	0x080a6160
 80a0c8c:	080a6177 	.word	0x080a6177
 80a0c90:	080a617f 	.word	0x080a617f
 80a0c94:	080a636d 	.word	0x080a636d
 80a0c98:	080a60db 	.word	0x080a60db
 80a0c9c:	080a60df 	.word	0x080a60df

080a0ca0 <_Z25insertItemResponseHandlerRN11ArduinoJson10JsonObjectE>:
    if (start == end) return value;
    return (value - start) / (end - start);
}

void insertItemResponseHandler(JsonObject& json)
{
 80a0ca0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a0ca2:	4913      	ldr	r1, [pc, #76]	; (80a0cf0 <_Z25insertItemResponseHandlerRN11ArduinoJson10JsonObjectE+0x50>)
 80a0ca4:	4605      	mov	r5, r0
 80a0ca6:	f7ff ffc4 	bl	80a0c32 <_ZNK11ArduinoJson10JsonObject8get_implIPKcbEENS_9Internals13JsonVariantAsIT0_E4typeET_>
  bool success = json["Success"];

  if (!success) {
 80a0caa:	b938      	cbnz	r0, 80a0cbc <_Z25insertItemResponseHandlerRN11ArduinoJson10JsonObjectE+0x1c>
    Serial.println("InsertItem failed");
 80a0cac:	f003 fcac 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0cb0:	4910      	ldr	r1, [pc, #64]	; (80a0cf4 <_Z25insertItemResponseHandlerRN11ArduinoJson10JsonObjectE+0x54>)
  int col = json["Col"];

  lightOneBox(row, col, green);

  Serial.printlnf("row: %d, col: %d", row, col);
}
 80a0cb2:	b003      	add	sp, #12
 80a0cb4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
void insertItemResponseHandler(JsonObject& json)
{
  bool success = json["Success"];

  if (!success) {
    Serial.println("InsertItem failed");
 80a0cb8:	f003 b81f 	b.w	80a3cfa <_ZN5Print7printlnEPKc>
 80a0cbc:	490e      	ldr	r1, [pc, #56]	; (80a0cf8 <_Z25insertItemResponseHandlerRN11ArduinoJson10JsonObjectE+0x58>)
 80a0cbe:	4628      	mov	r0, r5
 80a0cc0:	f7ff fecd 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0cc4:	490d      	ldr	r1, [pc, #52]	; (80a0cfc <_Z25insertItemResponseHandlerRN11ArduinoJson10JsonObjectE+0x5c>)
 80a0cc6:	4604      	mov	r4, r0
 80a0cc8:	4628      	mov	r0, r5
 80a0cca:	f7ff fec8 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0cce:	4605      	mov	r5, r0
  }

  int row = json["Row"];
  int col = json["Col"];

  lightOneBox(row, col, green);
 80a0cd0:	4b0b      	ldr	r3, [pc, #44]	; (80a0d00 <_Z25insertItemResponseHandlerRN11ArduinoJson10JsonObjectE+0x60>)
 80a0cd2:	4601      	mov	r1, r0
 80a0cd4:	881a      	ldrh	r2, [r3, #0]
 80a0cd6:	4620      	mov	r0, r4
 80a0cd8:	f7ff fb3c 	bl	80a0354 <_Z11lightOneBoxiit>

  Serial.printlnf("row: %d, col: %d", row, col);
 80a0cdc:	f003 fc94 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0ce0:	9500      	str	r5, [sp, #0]
 80a0ce2:	4623      	mov	r3, r4
 80a0ce4:	4a07      	ldr	r2, [pc, #28]	; (80a0d04 <_Z25insertItemResponseHandlerRN11ArduinoJson10JsonObjectE+0x64>)
 80a0ce6:	2101      	movs	r1, #1
 80a0ce8:	f003 f847 	bl	80a3d7a <_ZN5Print11printf_implEbPKcz>
}
 80a0cec:	b003      	add	sp, #12
 80a0cee:	bd30      	pop	{r4, r5, pc}
 80a0cf0:	080a6177 	.word	0x080a6177
 80a0cf4:	080a618e 	.word	0x080a618e
 80a0cf8:	080a60db 	.word	0x080a60db
 80a0cfc:	080a60df 	.word	0x080a60df
 80a0d00:	20001344 	.word	0x20001344
 80a0d04:	080a614f 	.word	0x080a614f

080a0d08 <_Z25removeItemResponseHandlerRN11ArduinoJson10JsonObjectE>:

void removeItemResponseHandler(JsonObject& json)
{
 80a0d08:	b510      	push	{r4, lr}
 80a0d0a:	4604      	mov	r4, r0
  Serial.println("removeItemResponseHandler");
 80a0d0c:	f003 fc7c 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0d10:	4907      	ldr	r1, [pc, #28]	; (80a0d30 <_Z25removeItemResponseHandlerRN11ArduinoJson10JsonObjectE+0x28>)
 80a0d12:	f002 fff2 	bl	80a3cfa <_ZN5Print7printlnEPKc>
 80a0d16:	4907      	ldr	r1, [pc, #28]	; (80a0d34 <_Z25removeItemResponseHandlerRN11ArduinoJson10JsonObjectE+0x2c>)
 80a0d18:	4620      	mov	r0, r4
 80a0d1a:	f7ff ff8a 	bl	80a0c32 <_ZNK11ArduinoJson10JsonObject8get_implIPKcbEENS_9Internals13JsonVariantAsIT0_E4typeET_>

  if (!json["Success"]) {
 80a0d1e:	b930      	cbnz	r0, 80a0d2e <_Z25removeItemResponseHandlerRN11ArduinoJson10JsonObjectE+0x26>
    Serial.println("RemoveItem failed");
 80a0d20:	f003 fc72 	bl	80a4608 <_Z16_fetch_usbserialv>
    return;
  }
}
 80a0d24:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void removeItemResponseHandler(JsonObject& json)
{
  Serial.println("removeItemResponseHandler");

  if (!json["Success"]) {
    Serial.println("RemoveItem failed");
 80a0d28:	4903      	ldr	r1, [pc, #12]	; (80a0d38 <_Z25removeItemResponseHandlerRN11ArduinoJson10JsonObjectE+0x30>)
 80a0d2a:	f002 bfe6 	b.w	80a3cfa <_ZN5Print7printlnEPKc>
 80a0d2e:	bd10      	pop	{r4, pc}
 80a0d30:	080a61a0 	.word	0x080a61a0
 80a0d34:	080a6177 	.word	0x080a6177
 80a0d38:	080a61ba 	.word	0x080a61ba

080a0d3c <_Z22addTagsResponseHandlerRN11ArduinoJson10JsonObjectE>:
    return;
  }
}

void addTagsResponseHandler(JsonObject& json)
{
 80a0d3c:	b510      	push	{r4, lr}
 80a0d3e:	4604      	mov	r4, r0
  Serial.println("addTagsResponseHandler");
 80a0d40:	f003 fc62 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0d44:	4907      	ldr	r1, [pc, #28]	; (80a0d64 <_Z22addTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x28>)
 80a0d46:	f002 ffd8 	bl	80a3cfa <_ZN5Print7printlnEPKc>
 80a0d4a:	4907      	ldr	r1, [pc, #28]	; (80a0d68 <_Z22addTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x2c>)
 80a0d4c:	4620      	mov	r0, r4
 80a0d4e:	f7ff ff70 	bl	80a0c32 <_ZNK11ArduinoJson10JsonObject8get_implIPKcbEENS_9Internals13JsonVariantAsIT0_E4typeET_>

  if (!json["Success"]) {
 80a0d52:	b930      	cbnz	r0, 80a0d62 <_Z22addTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x26>
    Serial.println("AddTags failed");
 80a0d54:	f003 fc58 	bl	80a4608 <_Z16_fetch_usbserialv>
    return;
  }
}
 80a0d58:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void addTagsResponseHandler(JsonObject& json)
{
  Serial.println("addTagsResponseHandler");

  if (!json["Success"]) {
    Serial.println("AddTags failed");
 80a0d5c:	4903      	ldr	r1, [pc, #12]	; (80a0d6c <_Z22addTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x30>)
 80a0d5e:	f002 bfcc 	b.w	80a3cfa <_ZN5Print7printlnEPKc>
 80a0d62:	bd10      	pop	{r4, pc}
 80a0d64:	080a61cc 	.word	0x080a61cc
 80a0d68:	080a6177 	.word	0x080a6177
 80a0d6c:	080a61e3 	.word	0x080a61e3

080a0d70 <_Z26setQuantityResponseHandlerRN11ArduinoJson10JsonObjectE>:
  }
}

// Modifying quantity triggers FindItem response handler
void setQuantityResponseHandler(JsonObject& json)
{
 80a0d70:	b510      	push	{r4, lr}
 80a0d72:	4604      	mov	r4, r0
  Serial.println("setQuantityResponseHandler");
 80a0d74:	f003 fc48 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0d78:	4909      	ldr	r1, [pc, #36]	; (80a0da0 <_Z26setQuantityResponseHandlerRN11ArduinoJson10JsonObjectE+0x30>)
 80a0d7a:	f002 ffbe 	bl	80a3cfa <_ZN5Print7printlnEPKc>
 80a0d7e:	4909      	ldr	r1, [pc, #36]	; (80a0da4 <_Z26setQuantityResponseHandlerRN11ArduinoJson10JsonObjectE+0x34>)
 80a0d80:	4620      	mov	r0, r4
 80a0d82:	f7ff ff56 	bl	80a0c32 <_ZNK11ArduinoJson10JsonObject8get_implIPKcbEENS_9Internals13JsonVariantAsIT0_E4typeET_>

  if (!json["Success"]) {
 80a0d86:	b930      	cbnz	r0, 80a0d96 <_Z26setQuantityResponseHandlerRN11ArduinoJson10JsonObjectE+0x26>
    Serial.println("SetQuantity failed");
 80a0d88:	f003 fc3e 	bl	80a4608 <_Z16_fetch_usbserialv>
  int col = result["Col"];

  lightOneBox(row, col, green);

  Serial.printlnf("row: %d, col: %d", row, col);
}
 80a0d8c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void setQuantityResponseHandler(JsonObject& json)
{
  Serial.println("setQuantityResponseHandler");

  if (!json["Success"]) {
    Serial.println("SetQuantity failed");
 80a0d90:	4905      	ldr	r1, [pc, #20]	; (80a0da8 <_Z26setQuantityResponseHandlerRN11ArduinoJson10JsonObjectE+0x38>)
 80a0d92:	f002 bfb2 	b.w	80a3cfa <_ZN5Print7printlnEPKc>
 80a0d96:	4620      	mov	r0, r4
  int col = result["Col"];

  lightOneBox(row, col, green);

  Serial.printlnf("row: %d, col: %d", row, col);
}
 80a0d98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a0d9c:	f7ff bf0e 	b.w	80a0bbc <_Z26setQuantityResponseHandlerRN11ArduinoJson10JsonObjectE.part.19>
 80a0da0:	080a61f2 	.word	0x080a61f2
 80a0da4:	080a6177 	.word	0x080a6177
 80a0da8:	080a620d 	.word	0x080a620d

080a0dac <_Z29updateQuantityResponseHandlerRN11ArduinoJson10JsonObjectE>:

void updateQuantityResponseHandler(JsonObject& json)
{
 80a0dac:	b510      	push	{r4, lr}
 80a0dae:	4604      	mov	r4, r0
  Serial.println("updateQuantityResponseHandler");
 80a0db0:	f003 fc2a 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0db4:	4909      	ldr	r1, [pc, #36]	; (80a0ddc <_Z29updateQuantityResponseHandlerRN11ArduinoJson10JsonObjectE+0x30>)
 80a0db6:	f002 ffa0 	bl	80a3cfa <_ZN5Print7printlnEPKc>
 80a0dba:	4909      	ldr	r1, [pc, #36]	; (80a0de0 <_Z29updateQuantityResponseHandlerRN11ArduinoJson10JsonObjectE+0x34>)
 80a0dbc:	4620      	mov	r0, r4
 80a0dbe:	f7ff ff38 	bl	80a0c32 <_ZNK11ArduinoJson10JsonObject8get_implIPKcbEENS_9Internals13JsonVariantAsIT0_E4typeET_>

  if (!json["Success"]) {
 80a0dc2:	b930      	cbnz	r0, 80a0dd2 <_Z29updateQuantityResponseHandlerRN11ArduinoJson10JsonObjectE+0x26>
    Serial.println("UpdateQuantity failed");
 80a0dc4:	f003 fc20 	bl	80a4608 <_Z16_fetch_usbserialv>
  int col = result["Col"];

  lightOneBox(row, col, green);

  Serial.printlnf("row: %d, col: %d", row, col);
}
 80a0dc8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void updateQuantityResponseHandler(JsonObject& json)
{
  Serial.println("updateQuantityResponseHandler");

  if (!json["Success"]) {
    Serial.println("UpdateQuantity failed");
 80a0dcc:	4905      	ldr	r1, [pc, #20]	; (80a0de4 <_Z29updateQuantityResponseHandlerRN11ArduinoJson10JsonObjectE+0x38>)
 80a0dce:	f002 bf94 	b.w	80a3cfa <_ZN5Print7printlnEPKc>
 80a0dd2:	4620      	mov	r0, r4
  int col = result["Col"];

  lightOneBox(row, col, green);

  Serial.printlnf("row: %d, col: %d", row, col);
}
 80a0dd4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a0dd8:	f7ff bef0 	b.w	80a0bbc <_Z26setQuantityResponseHandlerRN11ArduinoJson10JsonObjectE.part.19>
 80a0ddc:	080a6220 	.word	0x080a6220
 80a0de0:	080a6177 	.word	0x080a6177
 80a0de4:	080a623e 	.word	0x080a623e

080a0de8 <_Z25bundleWithResponseHandlerRN11ArduinoJson10JsonObjectE>:

  GFX_update();
}

void bundleWithResponseHandler(JsonObject& json)
{
 80a0de8:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 80a0dec:	4604      	mov	r4, r0
  Serial.println("bundleWithResponseHandler");
 80a0dee:	f003 fc0b 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0df2:	491e      	ldr	r1, [pc, #120]	; (80a0e6c <_Z25bundleWithResponseHandlerRN11ArduinoJson10JsonObjectE+0x84>)
 80a0df4:	f002 ff81 	bl	80a3cfa <_ZN5Print7printlnEPKc>
 80a0df8:	491d      	ldr	r1, [pc, #116]	; (80a0e70 <_Z25bundleWithResponseHandlerRN11ArduinoJson10JsonObjectE+0x88>)
 80a0dfa:	4620      	mov	r0, r4
 80a0dfc:	f7ff ff19 	bl	80a0c32 <_ZNK11ArduinoJson10JsonObject8get_implIPKcbEENS_9Internals13JsonVariantAsIT0_E4typeET_>

  if (!json["Success"]) {
 80a0e00:	b938      	cbnz	r0, 80a0e12 <_Z25bundleWithResponseHandlerRN11ArduinoJson10JsonObjectE+0x2a>
    Serial.println("UpdateQuantity failed");
 80a0e02:	f003 fc01 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0e06:	491b      	ldr	r1, [pc, #108]	; (80a0e74 <_Z25bundleWithResponseHandlerRN11ArduinoJson10JsonObjectE+0x8c>)
  const char* existingItem = json["ExistingItem"];

  lightOneBox(row, col, green);

  Serial.printlnf("NewItem: %s, row: %d, col: %d, quantity: %d, ExistingItem: %s", newItem, row, col, quantity, existingItem);
}
 80a0e08:	b004      	add	sp, #16
 80a0e0a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
void bundleWithResponseHandler(JsonObject& json)
{
  Serial.println("bundleWithResponseHandler");

  if (!json["Success"]) {
    Serial.println("UpdateQuantity failed");
 80a0e0e:	f002 bf74 	b.w	80a3cfa <_ZN5Print7printlnEPKc>
 80a0e12:	4919      	ldr	r1, [pc, #100]	; (80a0e78 <_Z25bundleWithResponseHandlerRN11ArduinoJson10JsonObjectE+0x90>)
 80a0e14:	4620      	mov	r0, r4
 80a0e16:	f7ff fd2f 	bl	80a0878 <_ZNK11ArduinoJson10JsonObject8get_implIPKcS3_EENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0e1a:	4918      	ldr	r1, [pc, #96]	; (80a0e7c <_Z25bundleWithResponseHandlerRN11ArduinoJson10JsonObjectE+0x94>)
 80a0e1c:	4607      	mov	r7, r0
 80a0e1e:	4620      	mov	r0, r4
 80a0e20:	f7ff fe1d 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0e24:	4916      	ldr	r1, [pc, #88]	; (80a0e80 <_Z25bundleWithResponseHandlerRN11ArduinoJson10JsonObjectE+0x98>)
 80a0e26:	4605      	mov	r5, r0
 80a0e28:	4620      	mov	r0, r4
 80a0e2a:	f7ff fe18 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0e2e:	4915      	ldr	r1, [pc, #84]	; (80a0e84 <_Z25bundleWithResponseHandlerRN11ArduinoJson10JsonObjectE+0x9c>)
 80a0e30:	4606      	mov	r6, r0
 80a0e32:	4620      	mov	r0, r4
 80a0e34:	f7ff fe13 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0e38:	4913      	ldr	r1, [pc, #76]	; (80a0e88 <_Z25bundleWithResponseHandlerRN11ArduinoJson10JsonObjectE+0xa0>)
 80a0e3a:	4680      	mov	r8, r0
 80a0e3c:	4620      	mov	r0, r4
 80a0e3e:	f7ff fd1b 	bl	80a0878 <_ZNK11ArduinoJson10JsonObject8get_implIPKcS3_EENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0e42:	4604      	mov	r4, r0
  int col = json["Col"];
  int quantity = json["Quantity"];

  const char* existingItem = json["ExistingItem"];

  lightOneBox(row, col, green);
 80a0e44:	4b11      	ldr	r3, [pc, #68]	; (80a0e8c <_Z25bundleWithResponseHandlerRN11ArduinoJson10JsonObjectE+0xa4>)
 80a0e46:	4631      	mov	r1, r6
 80a0e48:	881a      	ldrh	r2, [r3, #0]
 80a0e4a:	4628      	mov	r0, r5
 80a0e4c:	f7ff fa82 	bl	80a0354 <_Z11lightOneBoxiit>

  Serial.printlnf("NewItem: %s, row: %d, col: %d, quantity: %d, ExistingItem: %s", newItem, row, col, quantity, existingItem);
 80a0e50:	f003 fbda 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a0e54:	9403      	str	r4, [sp, #12]
 80a0e56:	e88d 0160 	stmia.w	sp, {r5, r6, r8}
 80a0e5a:	463b      	mov	r3, r7
 80a0e5c:	4a0c      	ldr	r2, [pc, #48]	; (80a0e90 <_Z25bundleWithResponseHandlerRN11ArduinoJson10JsonObjectE+0xa8>)
 80a0e5e:	2101      	movs	r1, #1
 80a0e60:	f002 ff8b 	bl	80a3d7a <_ZN5Print11printf_implEbPKcz>
}
 80a0e64:	b004      	add	sp, #16
 80a0e66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a0e6a:	bf00      	nop
 80a0e6c:	080a6254 	.word	0x080a6254
 80a0e70:	080a6177 	.word	0x080a6177
 80a0e74:	080a623e 	.word	0x080a623e
 80a0e78:	080a626e 	.word	0x080a626e
 80a0e7c:	080a60db 	.word	0x080a60db
 80a0e80:	080a60df 	.word	0x080a60df
 80a0e84:	080a636d 	.word	0x080a636d
 80a0e88:	080a6276 	.word	0x080a6276
 80a0e8c:	20001344 	.word	0x20001344
 80a0e90:	080a6283 	.word	0x080a6283

080a0e94 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc>:

namespace ArduinoJson {
namespace Internals {

template <typename T>
inline T parseFloat(const char* s) {
 80a0e94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  typedef FloatTraits<T> traits;
  typedef typename traits::mantissa_type mantissa_t;
  typedef typename traits::exponent_type exponent_t;

  if (!s) return 0;  // NULL
 80a0e96:	2800      	cmp	r0, #0
 80a0e98:	f000 8098 	beq.w	80a0fcc <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x138>

  bool negative_result = false;
  switch (*s) {
 80a0e9c:	7803      	ldrb	r3, [r0, #0]
 80a0e9e:	2b2b      	cmp	r3, #43	; 0x2b
 80a0ea0:	d004      	beq.n	80a0eac <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x18>
 80a0ea2:	2b2d      	cmp	r3, #45	; 0x2d
 80a0ea4:	d103      	bne.n	80a0eae <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x1a>
    case '-':
      negative_result = true;
      s++;
 80a0ea6:	3001      	adds	r0, #1
  if (!s) return 0;  // NULL

  bool negative_result = false;
  switch (*s) {
    case '-':
      negative_result = true;
 80a0ea8:	2501      	movs	r5, #1
      s++;
      break;
 80a0eaa:	e001      	b.n	80a0eb0 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x1c>
    case '+':
      s++;
 80a0eac:	3001      	adds	r0, #1
  typedef typename traits::mantissa_type mantissa_t;
  typedef typename traits::exponent_type exponent_t;

  if (!s) return 0;  // NULL

  bool negative_result = false;
 80a0eae:	2500      	movs	r5, #0
    case '+':
      s++;
      break;
  }

  if (*s == 't') return 1;  // true
 80a0eb0:	7803      	ldrb	r3, [r0, #0]
 80a0eb2:	2b74      	cmp	r3, #116	; 0x74
 80a0eb4:	f000 8085 	beq.w	80a0fc2 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x12e>
  if (*s == 'n' || *s == 'N') return traits::nan();
 80a0eb8:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80a0ebc:	2b4e      	cmp	r3, #78	; 0x4e
 80a0ebe:	f000 8083 	beq.w	80a0fc8 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x134>
  if (*s == 'i' || *s == 'I')
 80a0ec2:	2b49      	cmp	r3, #73	; 0x49
 80a0ec4:	d051      	beq.n	80a0f6a <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0xd6>
 80a0ec6:	2400      	movs	r4, #0
 80a0ec8:	4601      	mov	r1, r0
 80a0eca:	4620      	mov	r0, r4

  mantissa_t mantissa = 0;
  exponent_t exponent_offset = 0;

  while (isdigit(*s)) {
    if (mantissa < traits::mantissa_max / 10)
 80a0ecc:	4f42      	ldr	r7, [pc, #264]	; (80a0fd8 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x144>)
      mantissa = mantissa * 10 + (*s - '0');
 80a0ece:	f04f 0e0a 	mov.w	lr, #10
 80a0ed2:	460a      	mov	r2, r1
    return negative_result ? -traits::inf() : traits::inf();

  mantissa_t mantissa = 0;
  exponent_t exponent_offset = 0;

  while (isdigit(*s)) {
 80a0ed4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a0ed8:	f1a3 0630 	sub.w	r6, r3, #48	; 0x30
 80a0edc:	fa5f fc86 	uxtb.w	ip, r6
 80a0ee0:	f1bc 0f09 	cmp.w	ip, #9
 80a0ee4:	d806      	bhi.n	80a0ef4 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x60>
    if (mantissa < traits::mantissa_max / 10)
 80a0ee6:	42b8      	cmp	r0, r7
      mantissa = mantissa * 10 + (*s - '0');
    else
      exponent_offset++;
 80a0ee8:	bfca      	itet	gt
 80a0eea:	3401      	addgt	r4, #1
  mantissa_t mantissa = 0;
  exponent_t exponent_offset = 0;

  while (isdigit(*s)) {
    if (mantissa < traits::mantissa_max / 10)
      mantissa = mantissa * 10 + (*s - '0');
 80a0eec:	fb0e 6000 	mlale	r0, lr, r0, r6
    else
      exponent_offset++;
 80a0ef0:	b264      	sxtbgt	r4, r4
    return negative_result ? -traits::inf() : traits::inf();

  mantissa_t mantissa = 0;
  exponent_t exponent_offset = 0;

  while (isdigit(*s)) {
 80a0ef2:	e7ee      	b.n	80a0ed2 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x3e>
    else
      exponent_offset++;
    s++;
  }

  if (*s == '.') {
 80a0ef4:	2b2e      	cmp	r3, #46	; 0x2e
 80a0ef6:	d112      	bne.n	80a0f1e <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x8a>
    s++;
    while (isdigit(*s)) {
      if (mantissa < traits::mantissa_max / 10) {
 80a0ef8:	4f37      	ldr	r7, [pc, #220]	; (80a0fd8 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x144>)
 80a0efa:	1c51      	adds	r1, r2, #1
        mantissa = mantissa * 10 + (*s - '0');
 80a0efc:	260a      	movs	r6, #10
 80a0efe:	460a      	mov	r2, r1
    s++;
  }

  if (*s == '.') {
    s++;
    while (isdigit(*s)) {
 80a0f00:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a0f04:	3b30      	subs	r3, #48	; 0x30
 80a0f06:	fa5f fe83 	uxtb.w	lr, r3
 80a0f0a:	f1be 0f09 	cmp.w	lr, #9
 80a0f0e:	d806      	bhi.n	80a0f1e <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x8a>
      if (mantissa < traits::mantissa_max / 10) {
 80a0f10:	42b8      	cmp	r0, r7
 80a0f12:	dcf4      	bgt.n	80a0efe <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x6a>
        mantissa = mantissa * 10 + (*s - '0');
        exponent_offset--;
 80a0f14:	3c01      	subs	r4, #1

  if (*s == '.') {
    s++;
    while (isdigit(*s)) {
      if (mantissa < traits::mantissa_max / 10) {
        mantissa = mantissa * 10 + (*s - '0');
 80a0f16:	fb06 3000 	mla	r0, r6, r0, r3
        exponent_offset--;
 80a0f1a:	b264      	sxtb	r4, r4
    s++;
  }

  if (*s == '.') {
    s++;
    while (isdigit(*s)) {
 80a0f1c:	e7ef      	b.n	80a0efe <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x6a>
      s++;
    }
  }

  int exponent = 0;
  if (*s == 'e' || *s == 'E') {
 80a0f1e:	7813      	ldrb	r3, [r2, #0]
 80a0f20:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80a0f24:	2b45      	cmp	r3, #69	; 0x45
 80a0f26:	d126      	bne.n	80a0f76 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0xe2>
    s++;
    bool negative_exponent = false;
    if (*s == '-') {
 80a0f28:	7853      	ldrb	r3, [r2, #1]
 80a0f2a:	2b2d      	cmp	r3, #45	; 0x2d
 80a0f2c:	d102      	bne.n	80a0f34 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0xa0>
      negative_exponent = true;
      s++;
 80a0f2e:	3202      	adds	r2, #2
  int exponent = 0;
  if (*s == 'e' || *s == 'E') {
    s++;
    bool negative_exponent = false;
    if (*s == '-') {
      negative_exponent = true;
 80a0f30:	2101      	movs	r1, #1
 80a0f32:	e004      	b.n	80a0f3e <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0xaa>
      s++;
    } else if (*s == '+') {
 80a0f34:	2b2b      	cmp	r3, #43	; 0x2b
    }
  }

  int exponent = 0;
  if (*s == 'e' || *s == 'E') {
    s++;
 80a0f36:	bf14      	ite	ne
 80a0f38:	3201      	addne	r2, #1
    bool negative_exponent = false;
    if (*s == '-') {
      negative_exponent = true;
      s++;
    } else if (*s == '+') {
      s++;
 80a0f3a:	3202      	addeq	r2, #2
  }

  int exponent = 0;
  if (*s == 'e' || *s == 'E') {
    s++;
    bool negative_exponent = false;
 80a0f3c:	2100      	movs	r1, #0
 80a0f3e:	3a01      	subs	r2, #1
 80a0f40:	2300      	movs	r3, #0
    } else if (*s == '+') {
      s++;
    }

    while (isdigit(*s)) {
      exponent = exponent * 10 + (*s - '0');
 80a0f42:	270a      	movs	r7, #10
      s++;
    } else if (*s == '+') {
      s++;
    }

    while (isdigit(*s)) {
 80a0f44:	f812 6f01 	ldrb.w	r6, [r2, #1]!
 80a0f48:	3e30      	subs	r6, #48	; 0x30
 80a0f4a:	fa5f fe86 	uxtb.w	lr, r6
 80a0f4e:	f1be 0f09 	cmp.w	lr, #9
 80a0f52:	d80d      	bhi.n	80a0f70 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0xdc>
      exponent = exponent * 10 + (*s - '0');
 80a0f54:	fb07 6303 	mla	r3, r7, r3, r6
      if (exponent + exponent_offset > traits::exponent_max) {
 80a0f58:	18e6      	adds	r6, r4, r3
 80a0f5a:	2e26      	cmp	r6, #38	; 0x26
 80a0f5c:	ddf2      	ble.n	80a0f44 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0xb0>
        if (negative_exponent)
 80a0f5e:	b121      	cbz	r1, 80a0f6a <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0xd6>
          return negative_result ? -0.0f : 0.0f;
 80a0f60:	2d00      	cmp	r5, #0
 80a0f62:	d033      	beq.n	80a0fcc <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x138>
 80a0f64:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 80a0f68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        else
          return negative_result ? -traits::inf() : traits::inf();
 80a0f6a:	b38d      	cbz	r5, 80a0fd0 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x13c>
  }

  if (*s == 't') return 1;  // true
  if (*s == 'n' || *s == 'N') return traits::nan();
  if (*s == 'i' || *s == 'I')
    return negative_result ? -traits::inf() : traits::inf();
 80a0f6c:	481b      	ldr	r0, [pc, #108]	; (80a0fdc <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x148>)
 80a0f6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        else
          return negative_result ? -traits::inf() : traits::inf();
      }
      s++;
    }
    if (negative_exponent) exponent = -exponent;
 80a0f70:	b111      	cbz	r1, 80a0f78 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0xe4>
 80a0f72:	425b      	negs	r3, r3
 80a0f74:	e000      	b.n	80a0f78 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0xe4>
      }
      s++;
    }
  }

  int exponent = 0;
 80a0f76:	2300      	movs	r3, #0
      }
      s++;
    }
    if (negative_exponent) exponent = -exponent;
  }
  exponent += exponent_offset;
 80a0f78:	441c      	add	r4, r3

  T result = traits::make_float(static_cast<T>(mantissa), exponent);
 80a0f7a:	f004 fb9b 	bl	80a56b4 <__aeabi_i2f>
  typedef int8_t exponent_type;
  static const exponent_type exponent_max = 38;

  template <typename TExponent>
  static T make_float(T m, TExponent e) {
    if (e > 0) {
 80a0f7e:	2c00      	cmp	r4, #0
 80a0f80:	dd0d      	ble.n	80a0f9e <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x10a>
    return m;
  }

  static T positiveBinaryPowerOfTen(int index) {
    static T factors[] = {1e1f, 1e2f, 1e4f, 1e8f, 1e16f, 1e32f};
    return factors[index];
 80a0f82:	4f17      	ldr	r7, [pc, #92]	; (80a0fe0 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x14c>)
  typedef int8_t exponent_type;
  static const exponent_type exponent_max = 38;

  template <typename TExponent>
  static T make_float(T m, TExponent e) {
    if (e > 0) {
 80a0f84:	2600      	movs	r6, #0
      for (uint8_t index = 0; e != 0; index++) {
        if (e & 1) m *= positiveBinaryPowerOfTen(index);
 80a0f86:	07e2      	lsls	r2, r4, #31
 80a0f88:	d504      	bpl.n	80a0f94 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x100>
    return m;
  }

  static T positiveBinaryPowerOfTen(int index) {
    static T factors[] = {1e1f, 1e2f, 1e4f, 1e8f, 1e16f, 1e32f};
    return factors[index];
 80a0f8a:	b2f3      	uxtb	r3, r6

  template <typename TExponent>
  static T make_float(T m, TExponent e) {
    if (e > 0) {
      for (uint8_t index = 0; e != 0; index++) {
        if (e & 1) m *= positiveBinaryPowerOfTen(index);
 80a0f8c:	f857 1023 	ldr.w	r1, [r7, r3, lsl #2]
 80a0f90:	f004 fbe4 	bl	80a575c <__aeabi_fmul>
  static const exponent_type exponent_max = 38;

  template <typename TExponent>
  static T make_float(T m, TExponent e) {
    if (e > 0) {
      for (uint8_t index = 0; e != 0; index++) {
 80a0f94:	1064      	asrs	r4, r4, #1
 80a0f96:	f106 0601 	add.w	r6, r6, #1
 80a0f9a:	d1f4      	bne.n	80a0f86 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0xf2>
 80a0f9c:	e00d      	b.n	80a0fba <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x126>
    return factors[index];
  }

  static T negativeBinaryPowerOfTen(int index) {
    static T factors[] = {1e-1f, 1e-2f, 1e-4f, 1e-8f, 1e-16f, 1e-32f};
    return factors[index];
 80a0f9e:	4f11      	ldr	r7, [pc, #68]	; (80a0fe4 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x150>)
      for (uint8_t index = 0; e != 0; index++) {
        if (e & 1) m *= positiveBinaryPowerOfTen(index);
        e >>= 1;
      }
    } else {
      e = -e;
 80a0fa0:	4264      	negs	r4, r4
 80a0fa2:	2600      	movs	r6, #0
      for (uint8_t index = 0; e != 0; index++) {
 80a0fa4:	b14c      	cbz	r4, 80a0fba <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x126>
        if (e & 1) m *= negativeBinaryPowerOfTen(index);
 80a0fa6:	07e3      	lsls	r3, r4, #31
 80a0fa8:	d504      	bpl.n	80a0fb4 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x120>
    return factors[index];
  }

  static T negativeBinaryPowerOfTen(int index) {
    static T factors[] = {1e-1f, 1e-2f, 1e-4f, 1e-8f, 1e-16f, 1e-32f};
    return factors[index];
 80a0faa:	b2f3      	uxtb	r3, r6
        e >>= 1;
      }
    } else {
      e = -e;
      for (uint8_t index = 0; e != 0; index++) {
        if (e & 1) m *= negativeBinaryPowerOfTen(index);
 80a0fac:	f857 1023 	ldr.w	r1, [r7, r3, lsl #2]
 80a0fb0:	f004 fbd4 	bl	80a575c <__aeabi_fmul>
        e >>= 1;
 80a0fb4:	1064      	asrs	r4, r4, #1
 80a0fb6:	3601      	adds	r6, #1
 80a0fb8:	e7f4      	b.n	80a0fa4 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x110>

  return negative_result ? -result : result;
 80a0fba:	b15d      	cbz	r5, 80a0fd4 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x140>
 80a0fbc:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 80a0fc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    case '+':
      s++;
      break;
  }

  if (*s == 't') return 1;  // true
 80a0fc2:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80a0fc6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (*s == 'n' || *s == 'N') return traits::nan();
 80a0fc8:	4807      	ldr	r0, [pc, #28]	; (80a0fe8 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc+0x154>)
 80a0fca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

    while (isdigit(*s)) {
      exponent = exponent * 10 + (*s - '0');
      if (exponent + exponent_offset > traits::exponent_max) {
        if (negative_exponent)
          return negative_result ? -0.0f : 0.0f;
 80a0fcc:	2000      	movs	r0, #0
 80a0fce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  }

  if (*s == 't') return 1;  // true
  if (*s == 'n' || *s == 'N') return traits::nan();
  if (*s == 'i' || *s == 'I')
    return negative_result ? -traits::inf() : traits::inf();
 80a0fd0:	f04f 40ff 	mov.w	r0, #2139095040	; 0x7f800000
  exponent += exponent_offset;

  T result = traits::make_float(static_cast<T>(mantissa), exponent);

  return negative_result ? -result : result;
}
 80a0fd4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a0fd6:	bf00      	nop
 80a0fd8:	000ccccb 	.word	0x000ccccb
 80a0fdc:	ff800000 	.word	0xff800000
 80a0fe0:	20000318 	.word	0x20000318
 80a0fe4:	20000300 	.word	0x20000300
 80a0fe8:	7fc00000 	.word	0x7fc00000

080a0fec <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE>:
    GFX_setString(item);
  }
}

void findTagsResponseHandler(JsonObject& json)
{
 80a0fec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a0ff0:	4604      	mov	r4, r0
 80a0ff2:	b089      	sub	sp, #36	; 0x24
 80a0ff4:	495b      	ldr	r1, [pc, #364]	; (80a1164 <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x178>)
 80a0ff6:	f7ff fc3f 	bl	80a0878 <_ZNK11ArduinoJson10JsonObject8get_implIPKcS3_EENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a0ffa:	495b      	ldr	r1, [pc, #364]	; (80a1168 <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x17c>)
 80a0ffc:	4620      	mov	r0, r4
 80a0ffe:	f7ff fd2e 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a1002:	495a      	ldr	r1, [pc, #360]	; (80a116c <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x180>)
 80a1004:	4606      	mov	r6, r0
 80a1006:	4620      	mov	r0, r4
 80a1008:	f7ff fd29 	bl	80a0a5e <_ZNK11ArduinoJson10JsonObject8get_implIPKciEENS_9Internals13JsonVariantAsIT0_E4typeET_>
  const char* cmd = json["Command"];
  int count = json["Count"];
  int numTags = json["Tags"];

  if (count <= 0) {
 80a100c:	2e00      	cmp	r6, #0
 80a100e:	4681      	mov	r9, r0
 80a1010:	dc05      	bgt.n	80a101e <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x32>
    Serial.println("FindTags returned 0 items");
 80a1012:	f003 faf9 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a1016:	4956      	ldr	r1, [pc, #344]	; (80a1170 <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x184>)
 80a1018:	f002 fe6f 	bl	80a3cfa <_ZN5Print7printlnEPKc>
    return;
 80a101c:	e09f      	b.n	80a115e <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x172>
 80a101e:	4955      	ldr	r1, [pc, #340]	; (80a1174 <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x188>)
 80a1020:	4620      	mov	r0, r4
 80a1022:	f7ff fcdb 	bl	80a09dc <_ZNK11ArduinoJson10JsonObject8get_implIPKcRNS_9JsonArrayEEENS_9Internals13JsonVariantAsIT0_E4typeET_>
 80a1026:	4683      	mov	fp, r0
  }

  JsonArray& items = json["Result"];

  setDisplay(ON);
 80a1028:	2001      	movs	r0, #1
 80a102a:	f7ff f9a3 	bl	80a0374 <_Z10setDisplayb>
  GFX_clear();
 80a102e:	f001 fe79 	bl	80a2d24 <_Z9GFX_clearv>

  for (int i = 0; i < count; i++)
 80a1032:	2500      	movs	r5, #0
  }

  // Gets the value at the specified index.
  template <typename T>
  typename Internals::JsonVariantAs<T>::type get(size_t index) const {
    const_iterator it = begin() += index;
 80a1034:	f8db 3004 	ldr.w	r3, [fp, #4]
 80a1038:	ac08      	add	r4, sp, #32
 80a103a:	f844 3d04 	str.w	r3, [r4, #-4]!
 80a103e:	4629      	mov	r1, r5
 80a1040:	4620      	mov	r0, r4
 80a1042:	f7ff fae3 	bl	80a060c <_ZN11ArduinoJson9Internals17ListConstIteratorINS_11JsonVariantEEpLEj>
 80a1046:	6803      	ldr	r3, [r0, #0]
    return it != end() ? it->as<T>() : Internals::JsonVariantDefault<T>::get();
 80a1048:	b12b      	cbz	r3, 80a1056 <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x6a>
    _content.asObject = 0;  // <- prevent warning 'maybe-uninitialized'
  }
}

inline JsonArray &JsonVariant::variantAsArray() const {
  if (_type == Internals::JSON_ARRAY) return *_content.asArray;
 80a104a:	7a1a      	ldrb	r2, [r3, #8]
 80a104c:	2a06      	cmp	r2, #6
 80a104e:	d102      	bne.n	80a1056 <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x6a>
 80a1050:	f8d3 a010 	ldr.w	sl, [r3, #16]
 80a1054:	e002      	b.n	80a105c <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x70>
  return JsonArray::invalid();
 80a1056:	f7ff f8a5 	bl	80a01a4 <_ZN11ArduinoJson9JsonArray7invalidEv>
 80a105a:	4682      	mov	sl, r0
 80a105c:	2100      	movs	r1, #0
 80a105e:	4650      	mov	r0, sl
 80a1060:	f7ff fdd8 	bl	80a0c14 <_ZNK11ArduinoJson9JsonArray3getIiEENS_9Internals13JsonVariantAsIT_E4typeEj>
 80a1064:	2101      	movs	r1, #1
 80a1066:	4607      	mov	r7, r0
 80a1068:	4650      	mov	r0, sl
 80a106a:	f7ff fdd3 	bl	80a0c14 <_ZNK11ArduinoJson9JsonArray3getIiEENS_9Internals13JsonVariantAsIT_E4typeEj>
  }

  // Gets the value at the specified index.
  template <typename T>
  typename Internals::JsonVariantAs<T>::type get(size_t index) const {
    const_iterator it = begin() += index;
 80a106e:	f8da 3004 	ldr.w	r3, [sl, #4]
 80a1072:	4680      	mov	r8, r0
 80a1074:	2102      	movs	r1, #2
 80a1076:	4620      	mov	r0, r4
 80a1078:	9307      	str	r3, [sp, #28]
 80a107a:	f7ff fac7 	bl	80a060c <_ZN11ArduinoJson9Internals17ListConstIteratorINS_11JsonVariantEEpLEj>
 80a107e:	6803      	ldr	r3, [r0, #0]
    return it != end() ? it->as<T>() : Internals::JsonVariantDefault<T>::get();
 80a1080:	b1eb      	cbz	r3, 80a10be <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0xd2>
}

template <typename T>
inline T JsonVariant::variantAsFloat() const {
  using namespace Internals;
  switch (_type) {
 80a1082:	7a1a      	ldrb	r2, [r3, #8]
 80a1084:	2a05      	cmp	r2, #5
 80a1086:	d814      	bhi.n	80a10b2 <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0xc6>
 80a1088:	e8df f002 	tbb	[pc, r2]
 80a108c:	030f0f19 	.word	0x030f0f19
 80a1090:	0803      	.short	0x0803
    case JSON_UNDEFINED:
      return 0;
    case JSON_POSITIVE_INTEGER:
    case JSON_BOOLEAN:
      return static_cast<T>(_content.asInteger);
 80a1092:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 80a1096:	f004 fb1b 	bl	80a56d0 <__aeabi_ul2f>
 80a109a:	e00e      	b.n	80a10ba <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0xce>
    case JSON_NEGATIVE_INTEGER:
      return -static_cast<T>(_content.asInteger);
 80a109c:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 80a10a0:	f004 fb16 	bl	80a56d0 <__aeabi_ul2f>
 80a10a4:	f100 4400 	add.w	r4, r0, #2147483648	; 0x80000000
 80a10a8:	e00a      	b.n	80a10c0 <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0xd4>
    case JSON_STRING:
    case JSON_UNPARSED:
      return parseFloat<T>(_content.asString);
 80a10aa:	6918      	ldr	r0, [r3, #16]
 80a10ac:	f7ff fef2 	bl	80a0e94 <_ZN11ArduinoJson9Internals10parseFloatIfEET_PKc>
 80a10b0:	e003      	b.n	80a10ba <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0xce>
    default:
      return static_cast<T>(_content.asFloat);
 80a10b2:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 80a10b6:	f004 f9f3 	bl	80a54a0 <__aeabi_d2f>
 80a10ba:	4604      	mov	r4, r0
 80a10bc:	e000      	b.n	80a10c0 <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0xd4>
template <typename T>
inline T JsonVariant::variantAsFloat() const {
  using namespace Internals;
  switch (_type) {
    case JSON_UNDEFINED:
      return 0;
 80a10be:	2400      	movs	r4, #0
  {
     //const char* name = items[i]["Name"];
     JsonArray& info = items[i];
     int row = info[0];
     int col = info[1];
     float confidence = ((float)info[2])/numTags;
 80a10c0:	4648      	mov	r0, r9
 80a10c2:	f004 faf7 	bl	80a56b4 <__aeabi_i2f>
 80a10c6:	4601      	mov	r1, r0
 80a10c8:	4620      	mov	r0, r4
 80a10ca:	f004 fbfb 	bl	80a58c4 <__aeabi_fdiv>
 80a10ce:	4604      	mov	r4, r0

     //Serial.printlnf("Name: %s, Row: %d, Col: %d, Confidence: %f", name, row, col, confidence);
     Serial.printlnf("Row: %d, Col: %d, Confidence: %f", row, col, confidence);
 80a10d0:	f003 fa9a 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a10d4:	4682      	mov	sl, r0
 80a10d6:	4620      	mov	r0, r4
 80a10d8:	f003 ff34 	bl	80a4f44 <__aeabi_f2d>
 80a10dc:	4a26      	ldr	r2, [pc, #152]	; (80a1178 <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x18c>)
 80a10de:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80a10e2:	463b      	mov	r3, r7
 80a10e4:	2101      	movs	r1, #1
 80a10e6:	4650      	mov	r0, sl
 80a10e8:	f8cd 8000 	str.w	r8, [sp]
 80a10ec:	f002 fe45 	bl	80a3d7a <_ZN5Print11printf_implEbPKcz>

     GFX_lightBox(row, col, gradientBetween(unlikelyColor, likelyColor, normalize(confidence, 1.0/numTags, 1.0)));
 80a10f0:	4b22      	ldr	r3, [pc, #136]	; (80a117c <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x190>)
 80a10f2:	4648      	mov	r0, r9
 80a10f4:	881b      	ldrh	r3, [r3, #0]
 80a10f6:	9304      	str	r3, [sp, #16]
 80a10f8:	4b21      	ldr	r3, [pc, #132]	; (80a1180 <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x194>)
 80a10fa:	881b      	ldrh	r3, [r3, #0]
 80a10fc:	9305      	str	r3, [sp, #20]
 80a10fe:	f003 ff0f 	bl	80a4f20 <__aeabi_i2d>
 80a1102:	4602      	mov	r2, r0
 80a1104:	460b      	mov	r3, r1
 80a1106:	2000      	movs	r0, #0
 80a1108:	491e      	ldr	r1, [pc, #120]	; (80a1184 <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x198>)
 80a110a:	f004 f899 	bl	80a5240 <__aeabi_ddiv>
 80a110e:	f004 f9c7 	bl	80a54a0 <__aeabi_d2f>
// Normalize a number between a specific range.
// ex: normalize(0.8, 0.5, 1.0) => .8 is 3/5 between range,
// function returns 3/5 => 0.6
float normalize(float value, float start, float end)
{
    if (start == end) return value;
 80a1112:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
     float confidence = ((float)info[2])/numTags;

     //Serial.printlnf("Name: %s, Row: %d, Col: %d, Confidence: %f", name, row, col, confidence);
     Serial.printlnf("Row: %d, Col: %d, Confidence: %f", row, col, confidence);

     GFX_lightBox(row, col, gradientBetween(unlikelyColor, likelyColor, normalize(confidence, 1.0/numTags, 1.0)));
 80a1116:	4682      	mov	sl, r0
// Normalize a number between a specific range.
// ex: normalize(0.8, 0.5, 1.0) => .8 is 3/5 between range,
// function returns 3/5 => 0.6
float normalize(float value, float start, float end)
{
    if (start == end) return value;
 80a1118:	f004 fcb4 	bl	80a5a84 <__aeabi_fcmpeq>
 80a111c:	b978      	cbnz	r0, 80a113e <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x152>
    return (value - start) / (end - start);
 80a111e:	4651      	mov	r1, sl
 80a1120:	4620      	mov	r0, r4
 80a1122:	f004 fa11 	bl	80a5548 <__aeabi_fsub>
 80a1126:	4651      	mov	r1, sl
 80a1128:	4604      	mov	r4, r0
 80a112a:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80a112e:	f004 fa0b 	bl	80a5548 <__aeabi_fsub>
 80a1132:	4601      	mov	r1, r0
 80a1134:	4620      	mov	r0, r4
 80a1136:	f004 fbc5 	bl	80a58c4 <__aeabi_fdiv>
 80a113a:	4602      	mov	r2, r0
 80a113c:	e000      	b.n	80a1140 <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x154>
// Normalize a number between a specific range.
// ex: normalize(0.8, 0.5, 1.0) => .8 is 3/5 between range,
// function returns 3/5 => 0.6
float normalize(float value, float start, float end)
{
    if (start == end) return value;
 80a113e:	4622      	mov	r2, r4
     float confidence = ((float)info[2])/numTags;

     //Serial.printlnf("Name: %s, Row: %d, Col: %d, Confidence: %f", name, row, col, confidence);
     Serial.printlnf("Row: %d, Col: %d, Confidence: %f", row, col, confidence);

     GFX_lightBox(row, col, gradientBetween(unlikelyColor, likelyColor, normalize(confidence, 1.0/numTags, 1.0)));
 80a1140:	9905      	ldr	r1, [sp, #20]
 80a1142:	9804      	ldr	r0, [sp, #16]
 80a1144:	f001 ffbc 	bl	80a30c0 <_Z15gradientBetweenttf>
  JsonArray& items = json["Result"];

  setDisplay(ON);
  GFX_clear();

  for (int i = 0; i < count; i++)
 80a1148:	3501      	adds	r5, #1
     float confidence = ((float)info[2])/numTags;

     //Serial.printlnf("Name: %s, Row: %d, Col: %d, Confidence: %f", name, row, col, confidence);
     Serial.printlnf("Row: %d, Col: %d, Confidence: %f", row, col, confidence);

     GFX_lightBox(row, col, gradientBetween(unlikelyColor, likelyColor, normalize(confidence, 1.0/numTags, 1.0)));
 80a114a:	4602      	mov	r2, r0
 80a114c:	4641      	mov	r1, r8
 80a114e:	4638      	mov	r0, r7
 80a1150:	f001 fdf4 	bl	80a2d3c <_Z12GFX_lightBoxiit>
  JsonArray& items = json["Result"];

  setDisplay(ON);
  GFX_clear();

  for (int i = 0; i < count; i++)
 80a1154:	42b5      	cmp	r5, r6
 80a1156:	f47f af6d 	bne.w	80a1034 <_Z23findTagsResponseHandlerRN11ArduinoJson10JsonObjectE+0x48>
     Serial.printlnf("Row: %d, Col: %d, Confidence: %f", row, col, confidence);

     GFX_lightBox(row, col, gradientBetween(unlikelyColor, likelyColor, normalize(confidence, 1.0/numTags, 1.0)));
  }

  GFX_update();
 80a115a:	f001 fde9 	bl	80a2d30 <_Z10GFX_updatev>
}
 80a115e:	b009      	add	sp, #36	; 0x24
 80a1160:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a1164:	080a6303 	.word	0x080a6303
 80a1168:	080a60ba 	.word	0x080a60ba
 80a116c:	080a6385 	.word	0x080a6385
 80a1170:	080a62c1 	.word	0x080a62c1
 80a1174:	080a60cf 	.word	0x080a60cf
 80a1178:	080a62db 	.word	0x080a62db
 80a117c:	20001374 	.word	0x20001374
 80a1180:	20001366 	.word	0x20001366
 80a1184:	3ff00000 	.word	0x3ff00000

080a1188 <_GLOBAL__sub_I_jsonBuffer>:

// Generate a random number between minRand and maxRand
int r(int minRand, int maxRand)
{
  return rand() % (maxRand-minRand+1) + minRand;
 80a1188:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
} // namespace particle

// particle::Flag<TagT, ValueT>
template<typename TagT, typename ValueT>
inline particle::Flag<TagT, ValueT>::Flag(ValueT val) :
        val_(val) {
 80a118c:	4b2e      	ldr	r3, [pc, #184]	; (80a1248 <_GLOBAL__sub_I_jsonBuffer+0xc0>)
 80a118e:	2201      	movs	r2, #1
 80a1190:	701a      	strb	r2, [r3, #0]
inline int32_t pinReadFast(pin_t _pin)
{
	return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static STM32_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a1192:	f002 fadb 	bl	80a374c <HAL_Pin_Map>
    StaticJsonBufferBase* _parent;
    char* _start;
  };

  StaticJsonBufferBase(char* buffer, size_t capa)
      : _buffer(buffer), _capacity(capa), _size(0) {}
 80a1196:	482d      	ldr	r0, [pc, #180]	; (80a124c <_GLOBAL__sub_I_jsonBuffer+0xc4>)
// Libraries
#include <ArduinoJson.h>
#include "gfx.h"
#include "defines.h"

StaticJsonBuffer<3000> jsonBuffer;
 80a1198:	4a2d      	ldr	r2, [pc, #180]	; (80a1250 <_GLOBAL__sub_I_jsonBuffer+0xc8>)
 80a119a:	f100 0310 	add.w	r3, r0, #16
 80a119e:	6043      	str	r3, [r0, #4]
 80a11a0:	f640 33b8 	movw	r3, #3000	; 0xbb8
 80a11a4:	6083      	str	r3, [r0, #8]
 80a11a6:	2300      	movs	r3, #0
 80a11a8:	60c3      	str	r3, [r0, #12]
// bytes.
template <size_t CAPACITY>
class StaticJsonBuffer : public Internals::StaticJsonBufferBase {
 public:
  explicit StaticJsonBuffer()
      : Internals::StaticJsonBufferBase(_buffer, CAPACITY) {}
 80a11aa:	4b2a      	ldr	r3, [pc, #168]	; (80a1254 <_GLOBAL__sub_I_jsonBuffer+0xcc>)
 80a11ac:	492a      	ldr	r1, [pc, #168]	; (80a1258 <_GLOBAL__sub_I_jsonBuffer+0xd0>)
 80a11ae:	6003      	str	r3, [r0, #0]
  { ShowAllBoxes, showAllBoxes },
  { BundleWith, bundleWith },
  { HowMany, howMany },
  { ChangeColors, changeColors },
  { Welcome, welcome }
};
 80a11b0:	4f2a      	ldr	r7, [pc, #168]	; (80a125c <_GLOBAL__sub_I_jsonBuffer+0xd4>)
// Libraries
#include <ArduinoJson.h>
#include "gfx.h"
#include "defines.h"

StaticJsonBuffer<3000> jsonBuffer;
 80a11b2:	f003 fc13 	bl	80a49dc <__aeabi_atexit>
  { ShowAllBoxes, showAllBoxes },
  { BundleWith, bundleWith },
  { HowMany, howMany },
  { ChangeColors, changeColors },
  { Welcome, welcome }
};
 80a11b6:	4b2a      	ldr	r3, [pc, #168]	; (80a1260 <_GLOBAL__sub_I_jsonBuffer+0xd8>)
 80a11b8:	683f      	ldr	r7, [r7, #0]
 80a11ba:	f8d3 e000 	ldr.w	lr, [r3]
 80a11be:	4b29      	ldr	r3, [pc, #164]	; (80a1264 <_GLOBAL__sub_I_jsonBuffer+0xdc>)
 80a11c0:	4a29      	ldr	r2, [pc, #164]	; (80a1268 <_GLOBAL__sub_I_jsonBuffer+0xe0>)
 80a11c2:	639f      	str	r7, [r3, #56]	; 0x38
 80a11c4:	4f29      	ldr	r7, [pc, #164]	; (80a126c <_GLOBAL__sub_I_jsonBuffer+0xe4>)
 80a11c6:	6816      	ldr	r6, [r2, #0]
 80a11c8:	683f      	ldr	r7, [r7, #0]
 80a11ca:	4a29      	ldr	r2, [pc, #164]	; (80a1270 <_GLOBAL__sub_I_jsonBuffer+0xe8>)
 80a11cc:	641f      	str	r7, [r3, #64]	; 0x40
 80a11ce:	4f29      	ldr	r7, [pc, #164]	; (80a1274 <_GLOBAL__sub_I_jsonBuffer+0xec>)
 80a11d0:	6815      	ldr	r5, [r2, #0]
 80a11d2:	683f      	ldr	r7, [r7, #0]
 80a11d4:	4a28      	ldr	r2, [pc, #160]	; (80a1278 <_GLOBAL__sub_I_jsonBuffer+0xf0>)
 80a11d6:	649f      	str	r7, [r3, #72]	; 0x48
 80a11d8:	4f28      	ldr	r7, [pc, #160]	; (80a127c <_GLOBAL__sub_I_jsonBuffer+0xf4>)
 80a11da:	6814      	ldr	r4, [r2, #0]
 80a11dc:	f8d7 9000 	ldr.w	r9, [r7]
 80a11e0:	4f27      	ldr	r7, [pc, #156]	; (80a1280 <_GLOBAL__sub_I_jsonBuffer+0xf8>)
 80a11e2:	4a28      	ldr	r2, [pc, #160]	; (80a1284 <_GLOBAL__sub_I_jsonBuffer+0xfc>)
 80a11e4:	f8d7 8000 	ldr.w	r8, [r7]
 80a11e8:	4f27      	ldr	r7, [pc, #156]	; (80a1288 <_GLOBAL__sub_I_jsonBuffer+0x100>)
 80a11ea:	6810      	ldr	r0, [r2, #0]
 80a11ec:	f8d7 c000 	ldr.w	ip, [r7]
 80a11f0:	4f26      	ldr	r7, [pc, #152]	; (80a128c <_GLOBAL__sub_I_jsonBuffer+0x104>)
 80a11f2:	4a27      	ldr	r2, [pc, #156]	; (80a1290 <_GLOBAL__sub_I_jsonBuffer+0x108>)
 80a11f4:	683f      	ldr	r7, [r7, #0]
 80a11f6:	6811      	ldr	r1, [r2, #0]
 80a11f8:	669f      	str	r7, [r3, #104]	; 0x68
 80a11fa:	4a26      	ldr	r2, [pc, #152]	; (80a1294 <_GLOBAL__sub_I_jsonBuffer+0x10c>)
 80a11fc:	4f26      	ldr	r7, [pc, #152]	; (80a1298 <_GLOBAL__sub_I_jsonBuffer+0x110>)
 80a11fe:	6812      	ldr	r2, [r2, #0]
 80a1200:	683f      	ldr	r7, [r7, #0]
 80a1202:	f8c3 e000 	str.w	lr, [r3]
 80a1206:	609e      	str	r6, [r3, #8]
 80a1208:	631a      	str	r2, [r3, #48]	; 0x30
 80a120a:	611d      	str	r5, [r3, #16]
 80a120c:	619c      	str	r4, [r3, #24]
 80a120e:	6218      	str	r0, [r3, #32]
 80a1210:	6299      	str	r1, [r3, #40]	; 0x28
 80a1212:	f8c3 9050 	str.w	r9, [r3, #80]	; 0x50
 80a1216:	f8c3 8058 	str.w	r8, [r3, #88]	; 0x58
 80a121a:	f8c3 c060 	str.w	ip, [r3, #96]	; 0x60
 80a121e:	671f      	str	r7, [r3, #112]	; 0x70
  { UpdateQuantity, updateQuantityResponseHandler },
  { ShowAllBoxes, showAllBoxesResponseHandler },
  { BundleWith, bundleWithResponseHandler },
  { HowMany, howManyResponseHandler },
  { UnknownCommand, unknownCommandResponseHandler }
};
 80a1220:	4b1e      	ldr	r3, [pc, #120]	; (80a129c <_GLOBAL__sub_I_jsonBuffer+0x114>)
 80a1222:	f8c3 e000 	str.w	lr, [r3]
 80a1226:	609e      	str	r6, [r3, #8]
 80a1228:	611d      	str	r5, [r3, #16]
 80a122a:	631a      	str	r2, [r3, #48]	; 0x30
 80a122c:	4a1c      	ldr	r2, [pc, #112]	; (80a12a0 <_GLOBAL__sub_I_jsonBuffer+0x118>)
 80a122e:	619c      	str	r4, [r3, #24]
 80a1230:	6812      	ldr	r2, [r2, #0]
 80a1232:	6218      	str	r0, [r3, #32]
 80a1234:	6299      	str	r1, [r3, #40]	; 0x28
 80a1236:	f8c3 9038 	str.w	r9, [r3, #56]	; 0x38
 80a123a:	f8c3 8040 	str.w	r8, [r3, #64]	; 0x40
 80a123e:	f8c3 c048 	str.w	ip, [r3, #72]	; 0x48
 80a1242:	651a      	str	r2, [r3, #80]	; 0x50
 80a1244:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80a1248:	20000765 	.word	0x20000765
 80a124c:	20000768 	.word	0x20000768
 80a1250:	200004f0 	.word	0x200004f0
 80a1254:	080a5f54 	.word	0x080a5f54
 80a1258:	080a00c9 	.word	0x080a00c9
 80a125c:	200003ac 	.word	0x200003ac
 80a1260:	200003a0 	.word	0x200003a0
 80a1264:	200003c4 	.word	0x200003c4
 80a1268:	200003a4 	.word	0x200003a4
 80a126c:	20000330 	.word	0x20000330
 80a1270:	2000039c 	.word	0x2000039c
 80a1274:	2000043c 	.word	0x2000043c
 80a1278:	20000340 	.word	0x20000340
 80a127c:	200003b8 	.word	0x200003b8
 80a1280:	20000334 	.word	0x20000334
 80a1284:	200003bc 	.word	0x200003bc
 80a1288:	2000033c 	.word	0x2000033c
 80a128c:	200003c0 	.word	0x200003c0
 80a1290:	200003b4 	.word	0x200003b4
 80a1294:	200003a8 	.word	0x200003a8
 80a1298:	20000338 	.word	0x20000338
 80a129c:	20000344 	.word	0x20000344
 80a12a0:	200003b0 	.word	0x200003b0

080a12a4 <_ZN12Adafruit_GFX8drawLineEsssst>:
}

// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0,
			    int16_t x1, int16_t y1,
			    uint16_t color) {
 80a12a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a12a8:	461e      	mov	r6, r3
 80a12aa:	b085      	sub	sp, #20
 80a12ac:	f9bd 3038 	ldrsh.w	r3, [sp, #56]	; 0x38
 80a12b0:	4615      	mov	r5, r2
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
 80a12b2:	1a9a      	subs	r2, r3, r2
 80a12b4:	2a00      	cmp	r2, #0
 80a12b6:	bfb8      	it	lt
 80a12b8:	4252      	neglt	r2, r2
 80a12ba:	9200      	str	r2, [sp, #0]
 80a12bc:	1a72      	subs	r2, r6, r1
 80a12be:	2a00      	cmp	r2, #0
 80a12c0:	bfb8      	it	lt
 80a12c2:	4252      	neglt	r2, r2
 80a12c4:	9201      	str	r2, [sp, #4]
}

// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0,
			    int16_t x1, int16_t y1,
			    uint16_t color) {
 80a12c6:	460c      	mov	r4, r1
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
 80a12c8:	9a00      	ldr	r2, [sp, #0]
 80a12ca:	9901      	ldr	r1, [sp, #4]
}

// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0,
			    int16_t x1, int16_t y1,
			    uint16_t color) {
 80a12cc:	4681      	mov	r9, r0
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
 80a12ce:	428a      	cmp	r2, r1
}

// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0,
			    int16_t x1, int16_t y1,
			    uint16_t color) {
 80a12d0:	f8bd a03c 	ldrh.w	sl, [sp, #60]	; 0x3c
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
 80a12d4:	dd05      	ble.n	80a12e2 <_ZN12Adafruit_GFX8drawLineEsssst+0x3e>
 80a12d6:	4632      	mov	r2, r6
    swap(x0, y0);
    swap(x1, y1);
 80a12d8:	461e      	mov	r6, r3
 80a12da:	4613      	mov	r3, r2
// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0,
			    int16_t x1, int16_t y1,
			    uint16_t color) {
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
 80a12dc:	4622      	mov	r2, r4
    swap(x0, y0);
 80a12de:	462c      	mov	r4, r5
 80a12e0:	4615      	mov	r5, r2
    swap(x1, y1);
  }

  if (x0 > x1) {
 80a12e2:	42b4      	cmp	r4, r6
 80a12e4:	dd05      	ble.n	80a12f2 <_ZN12Adafruit_GFX8drawLineEsssst+0x4e>
 80a12e6:	462a      	mov	r2, r5
    swap(x0, x1);
    swap(y0, y1);
 80a12e8:	461d      	mov	r5, r3
 80a12ea:	4613      	mov	r3, r2
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
 80a12ec:	4622      	mov	r2, r4
 80a12ee:	4634      	mov	r4, r6
 80a12f0:	4616      	mov	r6, r2
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);
 80a12f2:	1b5a      	subs	r2, r3, r5
 80a12f4:	2a00      	cmp	r2, #0
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
 80a12f6:	ebc4 0806 	rsb	r8, r4, r6
  dy = abs(y1 - y0);
 80a12fa:	bfb8      	it	lt
 80a12fc:	4252      	neglt	r2, r2
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
 80a12fe:	fa1f f888 	uxth.w	r8, r8
  dy = abs(y1 - y0);
 80a1302:	9203      	str	r2, [sp, #12]

  int16_t err = dx / 2;
 80a1304:	fa0f f788 	sxth.w	r7, r8
 80a1308:	2202      	movs	r2, #2
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
 80a130a:	429d      	cmp	r5, r3
 80a130c:	bfb4      	ite	lt
 80a130e:	2301      	movlt	r3, #1
 80a1310:	f04f 33ff 	movge.w	r3, #4294967295

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
 80a1314:	fb97 f7f2 	sdiv	r7, r7, r2
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
 80a1318:	9302      	str	r3, [sp, #8]
  }

  for (; x0<=x1; x0++) {
 80a131a:	42b4      	cmp	r4, r6
 80a131c:	dc1f      	bgt.n	80a135e <_ZN12Adafruit_GFX8drawLineEsssst+0xba>
    if (steep) {
 80a131e:	9a01      	ldr	r2, [sp, #4]
 80a1320:	9b00      	ldr	r3, [sp, #0]
      drawPixel(y0, x0, color);
    } else {
      drawPixel(x0, y0, color);
 80a1322:	4648      	mov	r0, r9
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    if (steep) {
 80a1324:	4293      	cmp	r3, r2
 80a1326:	f8d9 3000 	ldr.w	r3, [r9]
      drawPixel(y0, x0, color);
 80a132a:	bfc8      	it	gt
 80a132c:	4622      	movgt	r2, r4
 80a132e:	f8d3 b010 	ldr.w	fp, [r3, #16]
 80a1332:	bfc8      	it	gt
 80a1334:	4629      	movgt	r1, r5
 80a1336:	4653      	mov	r3, sl
    } else {
      drawPixel(x0, y0, color);
 80a1338:	bfdc      	itt	le
 80a133a:	462a      	movle	r2, r5
 80a133c:	4621      	movle	r1, r4
 80a133e:	47d8      	blx	fp
    }
    err -= dy;
 80a1340:	9b03      	ldr	r3, [sp, #12]
 80a1342:	1aff      	subs	r7, r7, r3
 80a1344:	b2bb      	uxth	r3, r7
 80a1346:	b21f      	sxth	r7, r3
    if (err < 0) {
 80a1348:	2f00      	cmp	r7, #0
 80a134a:	da05      	bge.n	80a1358 <_ZN12Adafruit_GFX8drawLineEsssst+0xb4>
      y0 += ystep;
 80a134c:	9a02      	ldr	r2, [sp, #8]
      err += dx;
 80a134e:	eb08 0703 	add.w	r7, r8, r3
    } else {
      drawPixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
      y0 += ystep;
 80a1352:	4415      	add	r5, r2
 80a1354:	b22d      	sxth	r5, r5
      err += dx;
 80a1356:	b23f      	sxth	r7, r7
 80a1358:	3401      	adds	r4, #1
 80a135a:	b224      	sxth	r4, r4
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
 80a135c:	e7dd      	b.n	80a131a <_ZN12Adafruit_GFX8drawLineEsssst+0x76>
    if (err < 0) {
      y0 += ystep;
      err += dx;
    }
  }
}
 80a135e:	b005      	add	sp, #20
 80a1360:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a1364 <_ZN12Adafruit_GFX8drawRectEsssst>:

// Draw a rectangle
void Adafruit_GFX::drawRect(int16_t x, int16_t y,
			    int16_t w, int16_t h,
			    uint16_t color) {
 80a1364:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 80a1368:	4604      	mov	r4, r0
 80a136a:	4691      	mov	r9, r2
 80a136c:	460d      	mov	r5, r1
 80a136e:	4698      	mov	r8, r3
 80a1370:	f8bd 602c 	ldrh.w	r6, [sp, #44]	; 0x2c
  drawFastHLine(x, y, w, color);
 80a1374:	6807      	ldr	r7, [r0, #0]
}

// Draw a rectangle
void Adafruit_GFX::drawRect(int16_t x, int16_t y,
			    int16_t w, int16_t h,
			    uint16_t color) {
 80a1376:	f9bd a028 	ldrsh.w	sl, [sp, #40]	; 0x28
  drawFastHLine(x, y, w, color);
 80a137a:	9600      	str	r6, [sp, #0]
 80a137c:	69ff      	ldr	r7, [r7, #28]
 80a137e:	47b8      	blx	r7
  drawFastHLine(x, y+h-1, w, color);
 80a1380:	6823      	ldr	r3, [r4, #0]
 80a1382:	f10a 32ff 	add.w	r2, sl, #4294967295
 80a1386:	9600      	str	r6, [sp, #0]
 80a1388:	444a      	add	r2, r9
 80a138a:	69df      	ldr	r7, [r3, #28]
 80a138c:	4629      	mov	r1, r5
 80a138e:	4643      	mov	r3, r8
 80a1390:	4620      	mov	r0, r4
 80a1392:	b212      	sxth	r2, r2
 80a1394:	47b8      	blx	r7
  drawFastVLine(x, y, h, color);
 80a1396:	6823      	ldr	r3, [r4, #0]
 80a1398:	9600      	str	r6, [sp, #0]
 80a139a:	699f      	ldr	r7, [r3, #24]
 80a139c:	464a      	mov	r2, r9
 80a139e:	4653      	mov	r3, sl
 80a13a0:	4629      	mov	r1, r5
 80a13a2:	4620      	mov	r0, r4
 80a13a4:	47b8      	blx	r7
  drawFastVLine(x+w-1, y, h, color);
 80a13a6:	6823      	ldr	r3, [r4, #0]
 80a13a8:	f108 31ff 	add.w	r1, r8, #4294967295
 80a13ac:	960a      	str	r6, [sp, #40]	; 0x28
 80a13ae:	4429      	add	r1, r5
 80a13b0:	699d      	ldr	r5, [r3, #24]
 80a13b2:	464a      	mov	r2, r9
 80a13b4:	4653      	mov	r3, sl
 80a13b6:	4620      	mov	r0, r4
 80a13b8:	46ac      	mov	ip, r5
 80a13ba:	b209      	sxth	r1, r1
}
 80a13bc:	b002      	add	sp, #8
 80a13be:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			    int16_t w, int16_t h,
			    uint16_t color) {
  drawFastHLine(x, y, w, color);
  drawFastHLine(x, y+h-1, w, color);
  drawFastVLine(x, y, h, color);
  drawFastVLine(x+w-1, y, h, color);
 80a13c2:	4760      	bx	ip

080a13c4 <_ZN12Adafruit_GFX13drawFastVLineEssst>:
}

void Adafruit_GFX::drawFastVLine(int16_t x, int16_t y,
				 int16_t h, uint16_t color) {
 80a13c4:	b537      	push	{r0, r1, r2, r4, r5, lr}
  // Update in subclasses if desired!
  drawLine(x, y, x, y+h-1, color);
 80a13c6:	3b01      	subs	r3, #1
 80a13c8:	f8bd 5018 	ldrh.w	r5, [sp, #24]
 80a13cc:	4413      	add	r3, r2
 80a13ce:	6804      	ldr	r4, [r0, #0]
 80a13d0:	b21b      	sxth	r3, r3
 80a13d2:	9300      	str	r3, [sp, #0]
 80a13d4:	9501      	str	r5, [sp, #4]
 80a13d6:	6964      	ldr	r4, [r4, #20]
 80a13d8:	460b      	mov	r3, r1
 80a13da:	47a0      	blx	r4
}
 80a13dc:	b003      	add	sp, #12
 80a13de:	bd30      	pop	{r4, r5, pc}

080a13e0 <_ZN12Adafruit_GFX13drawFastHLineEssst>:

void Adafruit_GFX::drawFastHLine(int16_t x, int16_t y,
				 int16_t w, uint16_t color) {
 80a13e0:	b537      	push	{r0, r1, r2, r4, r5, lr}
  // Update in subclasses if desired!
  drawLine(x, y, x+w-1, y, color);
 80a13e2:	f8bd 5018 	ldrh.w	r5, [sp, #24]
 80a13e6:	6804      	ldr	r4, [r0, #0]
 80a13e8:	e88d 0024 	stmia.w	sp, {r2, r5}
 80a13ec:	3b01      	subs	r3, #1
 80a13ee:	440b      	add	r3, r1
 80a13f0:	6964      	ldr	r4, [r4, #20]
 80a13f2:	b21b      	sxth	r3, r3
 80a13f4:	47a0      	blx	r4
}
 80a13f6:	b003      	add	sp, #12
 80a13f8:	bd30      	pop	{r4, r5, pc}

080a13fa <_ZN12Adafruit_GFX8fillRectEsssst>:

void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
			    uint16_t color) {
 80a13fa:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 80a13fe:	4605      	mov	r5, r0
 80a1400:	4617      	mov	r7, r2
  // Update in subclasses if desired!
  for (int16_t i=x; i<x+w; i++) {
 80a1402:	460c      	mov	r4, r1
  // Update in subclasses if desired!
  drawLine(x, y, x+w-1, y, color);
}

void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
			    uint16_t color) {
 80a1404:	f9bd 8028 	ldrsh.w	r8, [sp, #40]	; 0x28
 80a1408:	f8bd 902c 	ldrh.w	r9, [sp, #44]	; 0x2c
  // Update in subclasses if desired!
  for (int16_t i=x; i<x+w; i++) {
 80a140c:	eb01 0a03 	add.w	sl, r1, r3
 80a1410:	4554      	cmp	r4, sl
 80a1412:	da0b      	bge.n	80a142c <_ZN12Adafruit_GFX8fillRectEsssst+0x32>
    drawFastVLine(i, y, h, color);
 80a1414:	682b      	ldr	r3, [r5, #0]
 80a1416:	f8cd 9000 	str.w	r9, [sp]
 80a141a:	699e      	ldr	r6, [r3, #24]
 80a141c:	4621      	mov	r1, r4
 80a141e:	4643      	mov	r3, r8
 80a1420:	463a      	mov	r2, r7
 80a1422:	4628      	mov	r0, r5
 80a1424:	3401      	adds	r4, #1
 80a1426:	47b0      	blx	r6
 80a1428:	b224      	sxth	r4, r4
}

void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
			    uint16_t color) {
  // Update in subclasses if desired!
  for (int16_t i=x; i<x+w; i++) {
 80a142a:	e7f1      	b.n	80a1410 <_ZN12Adafruit_GFX8fillRectEsssst+0x16>
    drawFastVLine(i, y, h, color);
  }
}
 80a142c:	b002      	add	sp, #8
 80a142e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080a1432 <_ZN12Adafruit_GFX10fillScreenEt>:

void Adafruit_GFX::fillScreen(uint16_t color) {
 80a1432:	b513      	push	{r0, r1, r4, lr}
  fillRect(0, 0, _width, _height, color);
 80a1434:	f9b0 200e 	ldrsh.w	r2, [r0, #14]
 80a1438:	6804      	ldr	r4, [r0, #0]
 80a143a:	9101      	str	r1, [sp, #4]
 80a143c:	9200      	str	r2, [sp, #0]
 80a143e:	2200      	movs	r2, #0
 80a1440:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
 80a1444:	6a64      	ldr	r4, [r4, #36]	; 0x24
 80a1446:	4611      	mov	r1, r2
 80a1448:	47a0      	blx	r4
}
 80a144a:	b002      	add	sp, #8
 80a144c:	bd10      	pop	{r4, pc}

080a144e <_ZN12Adafruit_GFX13invertDisplayEb>:
 
int16_t Adafruit_GFX::height(void) {
  return _height;
}

void Adafruit_GFX::invertDisplay(boolean i) {
 80a144e:	4770      	bx	lr

080a1450 <_ZN12Adafruit_GFXC1Ess>:
	0x00, 0x3C, 0x3C, 0x3C, 0x3C,
	0x00, 0x00, 0x00, 0x00, 0x00
};

Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h):
  WIDTH(w), HEIGHT(h)
 80a1450:	8101      	strh	r1, [r0, #8]
{
  _width    = WIDTH;
 80a1452:	8181      	strh	r1, [r0, #12]
  _height   = HEIGHT;
  rotation  = 0;
  cursor_y  = cursor_x    = 0;
  textsize  = 1;
  textcolor = textbgcolor = 0xFFFF;
 80a1454:	f64f 71ff 	movw	r1, #65535	; 0xffff
	0x00, 0x19, 0x1D, 0x17, 0x12,
	0x00, 0x3C, 0x3C, 0x3C, 0x3C,
	0x00, 0x00, 0x00, 0x00, 0x00
};

Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h):
 80a1458:	b530      	push	{r4, r5, lr}
  WIDTH(w), HEIGHT(h)
 80a145a:	4d07      	ldr	r5, [pc, #28]	; (80a1478 <_ZN12Adafruit_GFXC1Ess+0x28>)
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a145c:	2400      	movs	r4, #0
 80a145e:	8142      	strh	r2, [r0, #10]
{
  _width    = WIDTH;
  _height   = HEIGHT;
 80a1460:	81c2      	strh	r2, [r0, #14]
  rotation  = 0;
  cursor_y  = cursor_x    = 0;
  textsize  = 1;
 80a1462:	2201      	movs	r2, #1
 80a1464:	6044      	str	r4, [r0, #4]
	0x00, 0x3C, 0x3C, 0x3C, 0x3C,
	0x00, 0x00, 0x00, 0x00, 0x00
};

Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h):
  WIDTH(w), HEIGHT(h)
 80a1466:	6005      	str	r5, [r0, #0]
{
  _width    = WIDTH;
  _height   = HEIGHT;
  rotation  = 0;
 80a1468:	7644      	strb	r4, [r0, #25]
  cursor_y  = cursor_x    = 0;
 80a146a:	8204      	strh	r4, [r0, #16]
 80a146c:	8244      	strh	r4, [r0, #18]
  textsize  = 1;
 80a146e:	7602      	strb	r2, [r0, #24]
  textcolor = textbgcolor = 0xFFFF;
 80a1470:	82c1      	strh	r1, [r0, #22]
 80a1472:	8281      	strh	r1, [r0, #20]
  wrap      = true;
 80a1474:	7682      	strb	r2, [r0, #26]
}
 80a1476:	bd30      	pop	{r4, r5, pc}
 80a1478:	080a63bc 	.word	0x080a63bc

080a147c <_ZN12Adafruit_GFX10drawBitmapEssPKhsst>:
  }
}

void Adafruit_GFX::drawBitmap(int16_t x, int16_t y,
			      const uint8_t *bitmap, int16_t w, int16_t h,
			      uint16_t color) {
 80a147c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a1480:	b087      	sub	sp, #28
 80a1482:	469a      	mov	sl, r3
 80a1484:	f9bd 3044 	ldrsh.w	r3, [sp, #68]	; 0x44
 80a1488:	f9bd 8040 	ldrsh.w	r8, [sp, #64]	; 0x40
 80a148c:	9302      	str	r3, [sp, #8]
 80a148e:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
 80a1492:	4691      	mov	r9, r2
 80a1494:	9303      	str	r3, [sp, #12]
 80a1496:	f108 0207 	add.w	r2, r8, #7
 80a149a:	2308      	movs	r3, #8

  int16_t i, j, byteWidth = (w + 7) / 8;
 80a149c:	2400      	movs	r4, #0
 80a149e:	fb92 fbf3 	sdiv	fp, r2, r3
 80a14a2:	4625      	mov	r5, r4
  }
}

void Adafruit_GFX::drawBitmap(int16_t x, int16_t y,
			      const uint8_t *bitmap, int16_t w, int16_t h,
			      uint16_t color) {
 80a14a4:	e88d 0003 	stmia.w	sp, {r0, r1}

  int16_t i, j, byteWidth = (w + 7) / 8;

  for(j=0; j<h; j++) {
    for(i=0; i<w; i++ ) {
      if(pgm_read_byte(bitmap + j * byteWidth + i / 8) & (128 >> (i & 7))) {
 80a14a8:	9305      	str	r3, [sp, #20]
			      const uint8_t *bitmap, int16_t w, int16_t h,
			      uint16_t color) {

  int16_t i, j, byteWidth = (w + 7) / 8;

  for(j=0; j<h; j++) {
 80a14aa:	9a02      	ldr	r2, [sp, #8]
 80a14ac:	b22b      	sxth	r3, r5
 80a14ae:	429a      	cmp	r2, r3
 80a14b0:	dd25      	ble.n	80a14fe <_ZN12Adafruit_GFX10drawBitmapEssPKhsst+0x82>
    for(i=0; i<w; i++ ) {
      if(pgm_read_byte(bitmap + j * byteWidth + i / 8) & (128 >> (i & 7))) {
	drawPixel(x+i, y+j, color);
 80a14b2:	eb09 0305 	add.w	r3, r9, r5
 80a14b6:	b21b      	sxth	r3, r3
 80a14b8:	2600      	movs	r6, #0
 80a14ba:	9304      	str	r3, [sp, #16]
 80a14bc:	b233      	sxth	r3, r6
			      uint16_t color) {

  int16_t i, j, byteWidth = (w + 7) / 8;

  for(j=0; j<h; j++) {
    for(i=0; i<w; i++ ) {
 80a14be:	4543      	cmp	r3, r8
 80a14c0:	da1a      	bge.n	80a14f8 <_ZN12Adafruit_GFX10drawBitmapEssPKhsst+0x7c>
      if(pgm_read_byte(bitmap + j * byteWidth + i / 8) & (128 >> (i & 7))) {
 80a14c2:	9a05      	ldr	r2, [sp, #20]
 80a14c4:	b2b1      	uxth	r1, r6
 80a14c6:	fb93 f3f2 	sdiv	r3, r3, r2
 80a14ca:	eb0a 0204 	add.w	r2, sl, r4
 80a14ce:	5cd2      	ldrb	r2, [r2, r3]
 80a14d0:	2080      	movs	r0, #128	; 0x80
 80a14d2:	f001 0307 	and.w	r3, r1, #7
 80a14d6:	fa40 f303 	asr.w	r3, r0, r3
 80a14da:	421a      	tst	r2, r3
 80a14dc:	d00a      	beq.n	80a14f4 <_ZN12Adafruit_GFX10drawBitmapEssPKhsst+0x78>
	drawPixel(x+i, y+j, color);
 80a14de:	9b01      	ldr	r3, [sp, #4]
 80a14e0:	9a04      	ldr	r2, [sp, #16]
 80a14e2:	4419      	add	r1, r3
 80a14e4:	9b00      	ldr	r3, [sp, #0]
 80a14e6:	b209      	sxth	r1, r1
 80a14e8:	681b      	ldr	r3, [r3, #0]
 80a14ea:	9800      	ldr	r0, [sp, #0]
 80a14ec:	691b      	ldr	r3, [r3, #16]
 80a14ee:	461f      	mov	r7, r3
 80a14f0:	9b03      	ldr	r3, [sp, #12]
 80a14f2:	47b8      	blx	r7
 80a14f4:	3601      	adds	r6, #1
			      uint16_t color) {

  int16_t i, j, byteWidth = (w + 7) / 8;

  for(j=0; j<h; j++) {
    for(i=0; i<w; i++ ) {
 80a14f6:	e7e1      	b.n	80a14bc <_ZN12Adafruit_GFX10drawBitmapEssPKhsst+0x40>
 80a14f8:	3501      	adds	r5, #1
 80a14fa:	445c      	add	r4, fp
			      const uint8_t *bitmap, int16_t w, int16_t h,
			      uint16_t color) {

  int16_t i, j, byteWidth = (w + 7) / 8;

  for(j=0; j<h; j++) {
 80a14fc:	e7d5      	b.n	80a14aa <_ZN12Adafruit_GFX10drawBitmapEssPKhsst+0x2e>
      if(pgm_read_byte(bitmap + j * byteWidth + i / 8) & (128 >> (i & 7))) {
	drawPixel(x+i, y+j, color);
      }
    }
  }
}
 80a14fe:	b007      	add	sp, #28
 80a1500:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a1504 <_ZN12Adafruit_GFX8drawCharEsshtth>:
  return 1;
}

// Draw a character
void Adafruit_GFX::drawChar(int16_t x, int16_t y, unsigned char c,
			    uint16_t color, uint16_t bg, uint8_t size) {
 80a1504:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a1508:	b08f      	sub	sp, #60	; 0x3c
 80a150a:	9106      	str	r1, [sp, #24]
 80a150c:	f8bd 1060 	ldrh.w	r1, [sp, #96]	; 0x60
 80a1510:	4604      	mov	r4, r0
 80a1512:	9107      	str	r1, [sp, #28]
 80a1514:	f8bd 1064 	ldrh.w	r1, [sp, #100]	; 0x64
 80a1518:	f89d 8068 	ldrb.w	r8, [sp, #104]	; 0x68
 80a151c:	9108      	str	r1, [sp, #32]

  if((x >= _width)            || // Clip right
 80a151e:	f9b0 100c 	ldrsh.w	r1, [r0, #12]
 80a1522:	9806      	ldr	r0, [sp, #24]
 80a1524:	4281      	cmp	r1, r0
 80a1526:	dd7d      	ble.n	80a1624 <_ZN12Adafruit_GFX8drawCharEsshtth+0x120>
 80a1528:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80a152c:	4291      	cmp	r1, r2
 80a152e:	dd79      	ble.n	80a1624 <_ZN12Adafruit_GFX8drawCharEsshtth+0x120>
     (y >= _height)           || // Clip bottom
 80a1530:	2106      	movs	r1, #6
 80a1532:	fb01 0008 	mla	r0, r1, r8, r0
 80a1536:	2800      	cmp	r0, #0
 80a1538:	dd74      	ble.n	80a1624 <_ZN12Adafruit_GFX8drawCharEsshtth+0x120>
     ((x + 6 * size - 1) < 0) || // Clip left
 80a153a:	eb02 00c8 	add.w	r0, r2, r8, lsl #3
 80a153e:	2800      	cmp	r0, #0
 80a1540:	dd70      	ble.n	80a1624 <_ZN12Adafruit_GFX8drawCharEsshtth+0x120>
  for (int8_t i=0; i<6; i++ ) {
    uint8_t line;
    if (i == 5) 
      line = 0x0;
    else 
      line = pgm_read_byte(font+(c*5)+i);
 80a1542:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80a1546:	b295      	uxth	r5, r2
 80a1548:	930c      	str	r3, [sp, #48]	; 0x30
 80a154a:	f105 0308 	add.w	r3, r5, #8
 80a154e:	b29b      	uxth	r3, r3
 80a1550:	9109      	str	r1, [sp, #36]	; 0x24
 80a1552:	2600      	movs	r6, #0
 80a1554:	930d      	str	r3, [sp, #52]	; 0x34
 80a1556:	462f      	mov	r7, r5
    for (int8_t j = 0; j<8; j++) {
      if (line & 0x1) {
        if (size == 1) // default size
          drawPixel(x+i, y+j, color);
        else {  // big size
          fillRect(x+(i*size), y+(j*size), size, size, color);
 80a1558:	46a9      	mov	r9, r5
     ((y + 8 * size - 1) < 0))   // Clip top
    return;

  for (int8_t i=0; i<6; i++ ) {
    uint8_t line;
    if (i == 5) 
 80a155a:	2e05      	cmp	r6, #5
      line = 0x0;
    else 
      line = pgm_read_byte(font+(c*5)+i);
 80a155c:	bf1f      	itttt	ne
 80a155e:	4b33      	ldrne	r3, [pc, #204]	; (80a162c <_ZN12Adafruit_GFX8drawCharEsshtth+0x128>)
 80a1560:	9a0c      	ldrne	r2, [sp, #48]	; 0x30
 80a1562:	199b      	addne	r3, r3, r6
 80a1564:	f813 a002 	ldrbne.w	sl, [r3, r2]
    for (int8_t j = 0; j<8; j++) {
      if (line & 0x1) {
        if (size == 1) // default size
          drawPixel(x+i, y+j, color);
        else {  // big size
          fillRect(x+(i*size), y+(j*size), size, size, color);
 80a1568:	fa1f f388 	uxth.w	r3, r8
 80a156c:	9304      	str	r3, [sp, #16]
 80a156e:	9904      	ldr	r1, [sp, #16]
 80a1570:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 80a1574:	b2b2      	uxth	r2, r6
 80a1576:	fb01 3102 	mla	r1, r1, r2, r3
        } 
      } else if (bg != color) {
        if (size == 1) // default size
          drawPixel(x+i, y+j, bg);
 80a157a:	4413      	add	r3, r2
    for (int8_t j = 0; j<8; j++) {
      if (line & 0x1) {
        if (size == 1) // default size
          drawPixel(x+i, y+j, color);
        else {  // big size
          fillRect(x+(i*size), y+(j*size), size, size, color);
 80a157c:	b209      	sxth	r1, r1
 80a157e:	910a      	str	r1, [sp, #40]	; 0x28
        } 
      } else if (bg != color) {
        if (size == 1) // default size
          drawPixel(x+i, y+j, bg);
 80a1580:	b21b      	sxth	r3, r3
        else {  // big size
          fillRect(x+i*size, y+j*size, size, size, bg);
 80a1582:	fa0f f188 	sxth.w	r1, r8
    return;

  for (int8_t i=0; i<6; i++ ) {
    uint8_t line;
    if (i == 5) 
      line = 0x0;
 80a1586:	bf08      	it	eq
 80a1588:	f04f 0a00 	moveq.w	sl, #0
    for (int8_t j = 0; j<8; j++) {
      if (line & 0x1) {
        if (size == 1) // default size
          drawPixel(x+i, y+j, color);
        else {  // big size
          fillRect(x+(i*size), y+(j*size), size, size, color);
 80a158c:	9505      	str	r5, [sp, #20]
        } 
      } else if (bg != color) {
        if (size == 1) // default size
          drawPixel(x+i, y+j, bg);
        else {  // big size
          fillRect(x+i*size, y+j*size, size, size, bg);
 80a158e:	9103      	str	r1, [sp, #12]
        else {  // big size
          fillRect(x+(i*size), y+(j*size), size, size, color);
        } 
      } else if (bg != color) {
        if (size == 1) // default size
          drawPixel(x+i, y+j, bg);
 80a1590:	930b      	str	r3, [sp, #44]	; 0x2c
    if (i == 5) 
      line = 0x0;
    else 
      line = pgm_read_byte(font+(c*5)+i);
    for (int8_t j = 0; j<8; j++) {
      if (line & 0x1) {
 80a1592:	f01a 0f01 	tst.w	sl, #1
 80a1596:	d011      	beq.n	80a15bc <_ZN12Adafruit_GFX8drawCharEsshtth+0xb8>
        if (size == 1) // default size
 80a1598:	f1b8 0f01 	cmp.w	r8, #1
 80a159c:	6823      	ldr	r3, [r4, #0]
 80a159e:	d103      	bne.n	80a15a8 <_ZN12Adafruit_GFX8drawCharEsshtth+0xa4>
          drawPixel(x+i, y+j, color);
 80a15a0:	f8d3 b010 	ldr.w	fp, [r3, #16]
 80a15a4:	9b07      	ldr	r3, [sp, #28]
 80a15a6:	e014      	b.n	80a15d2 <_ZN12Adafruit_GFX8drawCharEsshtth+0xce>
        else {  // big size
          fillRect(x+(i*size), y+(j*size), size, size, color);
 80a15a8:	9a07      	ldr	r2, [sp, #28]
 80a15aa:	9201      	str	r2, [sp, #4]
 80a15ac:	9a03      	ldr	r2, [sp, #12]
 80a15ae:	9200      	str	r2, [sp, #0]
 80a15b0:	f8d3 b024 	ldr.w	fp, [r3, #36]	; 0x24
 80a15b4:	4613      	mov	r3, r2
 80a15b6:	fa0f f289 	sxth.w	r2, r9
 80a15ba:	e018      	b.n	80a15ee <_ZN12Adafruit_GFX8drawCharEsshtth+0xea>
        } 
      } else if (bg != color) {
 80a15bc:	9b07      	ldr	r3, [sp, #28]
 80a15be:	9a08      	ldr	r2, [sp, #32]
 80a15c0:	4293      	cmp	r3, r2
 80a15c2:	d017      	beq.n	80a15f4 <_ZN12Adafruit_GFX8drawCharEsshtth+0xf0>
        if (size == 1) // default size
 80a15c4:	f1b8 0f01 	cmp.w	r8, #1
 80a15c8:	6823      	ldr	r3, [r4, #0]
 80a15ca:	d107      	bne.n	80a15dc <_ZN12Adafruit_GFX8drawCharEsshtth+0xd8>
          drawPixel(x+i, y+j, bg);
 80a15cc:	f8d3 b010 	ldr.w	fp, [r3, #16]
 80a15d0:	4613      	mov	r3, r2
 80a15d2:	b23a      	sxth	r2, r7
 80a15d4:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80a15d6:	4620      	mov	r0, r4
 80a15d8:	47d8      	blx	fp
 80a15da:	e00b      	b.n	80a15f4 <_ZN12Adafruit_GFX8drawCharEsshtth+0xf0>
        else {  // big size
          fillRect(x+i*size, y+j*size, size, size, bg);
 80a15dc:	9a08      	ldr	r2, [sp, #32]
 80a15de:	9201      	str	r2, [sp, #4]
 80a15e0:	9a03      	ldr	r2, [sp, #12]
 80a15e2:	9200      	str	r2, [sp, #0]
 80a15e4:	f8d3 b024 	ldr.w	fp, [r3, #36]	; 0x24
 80a15e8:	4613      	mov	r3, r2
 80a15ea:	f9bd 2014 	ldrsh.w	r2, [sp, #20]
 80a15ee:	990a      	ldr	r1, [sp, #40]	; 0x28
 80a15f0:	4620      	mov	r0, r4
 80a15f2:	47d8      	blx	fp
 80a15f4:	9b04      	ldr	r3, [sp, #16]
 80a15f6:	9a04      	ldr	r2, [sp, #16]
 80a15f8:	4499      	add	r9, r3
 80a15fa:	9b05      	ldr	r3, [sp, #20]
 80a15fc:	3701      	adds	r7, #1
 80a15fe:	4413      	add	r3, r2
 80a1600:	b29b      	uxth	r3, r3
 80a1602:	9305      	str	r3, [sp, #20]
    uint8_t line;
    if (i == 5) 
      line = 0x0;
    else 
      line = pgm_read_byte(font+(c*5)+i);
    for (int8_t j = 0; j<8; j++) {
 80a1604:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80a1606:	b2bf      	uxth	r7, r7
 80a1608:	429f      	cmp	r7, r3
          drawPixel(x+i, y+j, bg);
        else {  // big size
          fillRect(x+i*size, y+j*size, size, size, bg);
        }
      }
      line >>= 1;
 80a160a:	ea4f 0a5a 	mov.w	sl, sl, lsr #1
 80a160e:	fa1f f989 	uxth.w	r9, r9
    uint8_t line;
    if (i == 5) 
      line = 0x0;
    else 
      line = pgm_read_byte(font+(c*5)+i);
    for (int8_t j = 0; j<8; j++) {
 80a1612:	d1be      	bne.n	80a1592 <_ZN12Adafruit_GFX8drawCharEsshtth+0x8e>
 80a1614:	9b09      	ldr	r3, [sp, #36]	; 0x24
     (y >= _height)           || // Clip bottom
     ((x + 6 * size - 1) < 0) || // Clip left
     ((y + 8 * size - 1) < 0))   // Clip top
    return;

  for (int8_t i=0; i<6; i++ ) {
 80a1616:	3601      	adds	r6, #1
 80a1618:	3b01      	subs	r3, #1
 80a161a:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 80a161e:	b276      	sxtb	r6, r6
 80a1620:	9309      	str	r3, [sp, #36]	; 0x24
 80a1622:	d198      	bne.n	80a1556 <_ZN12Adafruit_GFX8drawCharEsshtth+0x52>
        }
      }
      line >>= 1;
    }
  }
}
 80a1624:	b00f      	add	sp, #60	; 0x3c
 80a1626:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a162a:	bf00      	nop
 80a162c:	080a63ec 	.word	0x080a63ec

080a1630 <_ZN12Adafruit_GFX5writeEh>:
      }
    }
  }
}

size_t Adafruit_GFX::write(uint8_t c) {
 80a1630:	b530      	push	{r4, r5, lr}

  if (c == '\n') {
 80a1632:	290a      	cmp	r1, #10
      }
    }
  }
}

size_t Adafruit_GFX::write(uint8_t c) {
 80a1634:	b085      	sub	sp, #20
 80a1636:	4604      	mov	r4, r0
 80a1638:	460b      	mov	r3, r1

  if (c == '\n') {
 80a163a:	d104      	bne.n	80a1646 <_ZN12Adafruit_GFX5writeEh+0x16>
    cursor_y += textsize*8;
 80a163c:	7e02      	ldrb	r2, [r0, #24]
 80a163e:	8a43      	ldrh	r3, [r0, #18]
 80a1640:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80a1644:	e023      	b.n	80a168e <_ZN12Adafruit_GFX5writeEh+0x5e>
    cursor_x  = 0;
  } else if (c == '\r') {
 80a1646:	290d      	cmp	r1, #13
 80a1648:	d024      	beq.n	80a1694 <_ZN12Adafruit_GFX5writeEh+0x64>
    // skip em
  } else {
    drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);
 80a164a:	7e05      	ldrb	r5, [r0, #24]
 80a164c:	f9b0 2012 	ldrsh.w	r2, [r0, #18]
 80a1650:	f9b0 1010 	ldrsh.w	r1, [r0, #16]
 80a1654:	9502      	str	r5, [sp, #8]
 80a1656:	8ac5      	ldrh	r5, [r0, #22]
 80a1658:	9501      	str	r5, [sp, #4]
 80a165a:	8a85      	ldrh	r5, [r0, #20]
 80a165c:	9500      	str	r5, [sp, #0]
 80a165e:	f7ff ff51 	bl	80a1504 <_ZN12Adafruit_GFX8drawCharEsshtth>
    cursor_x += textsize*6;
 80a1662:	7e22      	ldrb	r2, [r4, #24]
 80a1664:	8a23      	ldrh	r3, [r4, #16]
 80a1666:	b291      	uxth	r1, r2
 80a1668:	eb01 0041 	add.w	r0, r1, r1, lsl #1
 80a166c:	eb03 0340 	add.w	r3, r3, r0, lsl #1
    if (wrap && (cursor_x > (_width - textsize*6))) {
 80a1670:	7ea0      	ldrb	r0, [r4, #26]
    cursor_x  = 0;
  } else if (c == '\r') {
    // skip em
  } else {
    drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);
    cursor_x += textsize*6;
 80a1672:	b21b      	sxth	r3, r3
 80a1674:	8223      	strh	r3, [r4, #16]
    if (wrap && (cursor_x > (_width - textsize*6))) {
 80a1676:	b168      	cbz	r0, 80a1694 <_ZN12Adafruit_GFX5writeEh+0x64>
 80a1678:	f9b4 000c 	ldrsh.w	r0, [r4, #12]
 80a167c:	f06f 0505 	mvn.w	r5, #5
 80a1680:	fb05 0202 	mla	r2, r5, r2, r0
 80a1684:	4293      	cmp	r3, r2
 80a1686:	dd05      	ble.n	80a1694 <_ZN12Adafruit_GFX5writeEh+0x64>
      cursor_y += textsize*8;
 80a1688:	8a63      	ldrh	r3, [r4, #18]
 80a168a:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 80a168e:	8263      	strh	r3, [r4, #18]
      cursor_x = 0;
 80a1690:	2300      	movs	r3, #0
 80a1692:	8223      	strh	r3, [r4, #16]
    }
  }
  return 1;
}
 80a1694:	2001      	movs	r0, #1
 80a1696:	b005      	add	sp, #20
 80a1698:	bd30      	pop	{r4, r5, pc}

080a169a <_ZN12Adafruit_GFX9setCursorEss>:
    }
  }
}

void Adafruit_GFX::setCursor(int16_t x, int16_t y) {
  cursor_x = x;
 80a169a:	8201      	strh	r1, [r0, #16]
  cursor_y = y;
 80a169c:	8242      	strh	r2, [r0, #18]
 80a169e:	4770      	bx	lr

080a16a0 <_ZN12Adafruit_GFX12setTextColorEt>:
}

void Adafruit_GFX::setTextColor(uint16_t c) {
  // For 'transparent' background, we'll set the bg 
  // to the same as fg instead of using a flag
  textcolor = textbgcolor = c;
 80a16a0:	82c1      	strh	r1, [r0, #22]
 80a16a2:	8281      	strh	r1, [r0, #20]
 80a16a4:	4770      	bx	lr

080a16a6 <_ZN12Adafruit_GFX11setTextWrapEb>:
  textcolor   = c;
  textbgcolor = b; 
}

void Adafruit_GFX::setTextWrap(boolean w) {
  wrap = w;
 80a16a6:	7681      	strb	r1, [r0, #26]
 80a16a8:	4770      	bx	lr

080a16aa <_ZN12Adafruit_GFX5widthEv>:
}

// Return the size of the display (per current rotation)
int16_t Adafruit_GFX::width(void) {
  return _width;
}
 80a16aa:	f9b0 000c 	ldrsh.w	r0, [r0, #12]
 80a16ae:	4770      	bx	lr

080a16b0 <_GLOBAL__sub_I__ZN12Adafruit_GFXC2Ess>:
 80a16b0:	f002 b84c 	b.w	80a374c <HAL_Pin_Map>

080a16b4 <micros>:

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
 80a16b4:	f002 b88a 	b.w	80a37cc <HAL_Timer_Get_Micro_Seconds>

080a16b8 <_ZN17Adafruit_NeoPixelD1Ev>:
{
  updateLength(n);
  setPin(p);
}

Adafruit_NeoPixel::~Adafruit_NeoPixel() {
 80a16b8:	b510      	push	{r4, lr}
 80a16ba:	4604      	mov	r4, r0
  if (pixels) free(pixels);
 80a16bc:	68c0      	ldr	r0, [r0, #12]
 80a16be:	b108      	cbz	r0, 80a16c4 <_ZN17Adafruit_NeoPixelD1Ev+0xc>
 80a16c0:	f002 f9ba 	bl	80a3a38 <free>
  if (begun) pinMode(pin, INPUT);
 80a16c4:	7823      	ldrb	r3, [r4, #0]
 80a16c6:	b11b      	cbz	r3, 80a16d0 <_ZN17Adafruit_NeoPixelD1Ev+0x18>
 80a16c8:	2100      	movs	r1, #0
 80a16ca:	79e0      	ldrb	r0, [r4, #7]
 80a16cc:	f003 f902 	bl	80a48d4 <pinMode>
}
 80a16d0:	4620      	mov	r0, r4
 80a16d2:	bd10      	pop	{r4, pc}

080a16d4 <_ZN17Adafruit_NeoPixel12updateLengthEt>:

void Adafruit_NeoPixel::updateLength(uint16_t n) {
 80a16d4:	b538      	push	{r3, r4, r5, lr}
 80a16d6:	4604      	mov	r4, r0
  if (pixels) free(pixels); // Free existing data (if any)
 80a16d8:	68c0      	ldr	r0, [r0, #12]
Adafruit_NeoPixel::~Adafruit_NeoPixel() {
  if (pixels) free(pixels);
  if (begun) pinMode(pin, INPUT);
}

void Adafruit_NeoPixel::updateLength(uint16_t n) {
 80a16da:	460d      	mov	r5, r1
  if (pixels) free(pixels); // Free existing data (if any)
 80a16dc:	b108      	cbz	r0, 80a16e2 <_ZN17Adafruit_NeoPixel12updateLengthEt+0xe>
 80a16de:	f002 f9ab 	bl	80a3a38 <free>

  // Allocate new data -- note: ALL PIXELS ARE CLEARED
  numBytes = n * ((type == SK6812RGBW) ? 4 : 3);
 80a16e2:	79a3      	ldrb	r3, [r4, #6]
 80a16e4:	2b06      	cmp	r3, #6
 80a16e6:	bf0c      	ite	eq
 80a16e8:	2004      	moveq	r0, #4
 80a16ea:	2003      	movne	r0, #3
 80a16ec:	4368      	muls	r0, r5
 80a16ee:	b280      	uxth	r0, r0
 80a16f0:	80a0      	strh	r0, [r4, #4]
  if ((pixels = (uint8_t *)malloc(numBytes))) {
 80a16f2:	f002 f999 	bl	80a3a28 <malloc>
 80a16f6:	60e0      	str	r0, [r4, #12]
 80a16f8:	b128      	cbz	r0, 80a1706 <_ZN17Adafruit_NeoPixel12updateLengthEt+0x32>
    memset(pixels, 0, numBytes);
 80a16fa:	88a2      	ldrh	r2, [r4, #4]
 80a16fc:	2100      	movs	r1, #0
 80a16fe:	f004 fa56 	bl	80a5bae <memset>
    numLEDs = n;
 80a1702:	8065      	strh	r5, [r4, #2]
 80a1704:	bd38      	pop	{r3, r4, r5, pc}
  } else {
    numLEDs = numBytes = 0;
 80a1706:	80a0      	strh	r0, [r4, #4]
 80a1708:	8060      	strh	r0, [r4, #2]
 80a170a:	bd38      	pop	{r3, r4, r5, pc}

080a170c <_ZN17Adafruit_NeoPixel5beginEv>:
  }
}

void Adafruit_NeoPixel::begin(void) {
 80a170c:	b510      	push	{r4, lr}
 80a170e:	4604      	mov	r4, r0
  pinMode(pin, OUTPUT);
 80a1710:	2101      	movs	r1, #1
 80a1712:	79c0      	ldrb	r0, [r0, #7]
 80a1714:	f003 f8de 	bl	80a48d4 <pinMode>
  digitalWrite(pin, LOW);
 80a1718:	2100      	movs	r1, #0
 80a171a:	79e0      	ldrb	r0, [r4, #7]
 80a171c:	f003 f8eb 	bl	80a48f6 <digitalWrite>
  begun = true;
 80a1720:	2301      	movs	r3, #1
 80a1722:	7023      	strb	r3, [r4, #0]
 80a1724:	bd10      	pop	{r4, pc}

080a1726 <_ZN17Adafruit_NeoPixel6setPinEh>:
}

// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
 80a1726:	b538      	push	{r3, r4, r5, lr}
    if (begun) {
 80a1728:	7803      	ldrb	r3, [r0, #0]
  digitalWrite(pin, LOW);
  begun = true;
}

// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
 80a172a:	4605      	mov	r5, r0
 80a172c:	460c      	mov	r4, r1
    if (begun) {
 80a172e:	b11b      	cbz	r3, 80a1738 <_ZN17Adafruit_NeoPixel6setPinEh+0x12>
        pinMode(pin, INPUT);
 80a1730:	2100      	movs	r1, #0
 80a1732:	79c0      	ldrb	r0, [r0, #7]
 80a1734:	f003 f8ce 	bl	80a48d4 <pinMode>
    }
    pin = p;
    if (begun) {
 80a1738:	782b      	ldrb	r3, [r5, #0]
// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
    if (begun) {
        pinMode(pin, INPUT);
    }
    pin = p;
 80a173a:	71ec      	strb	r4, [r5, #7]
    if (begun) {
 80a173c:	b153      	cbz	r3, 80a1754 <_ZN17Adafruit_NeoPixel6setPinEh+0x2e>
        pinMode(p, OUTPUT);
 80a173e:	b2a4      	uxth	r4, r4
 80a1740:	4620      	mov	r0, r4
 80a1742:	2101      	movs	r1, #1
 80a1744:	f003 f8c6 	bl	80a48d4 <pinMode>
        digitalWrite(p, LOW);
 80a1748:	4620      	mov	r0, r4
    }
}
 80a174a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        pinMode(pin, INPUT);
    }
    pin = p;
    if (begun) {
        pinMode(p, OUTPUT);
        digitalWrite(p, LOW);
 80a174e:	2100      	movs	r1, #0
 80a1750:	f003 b8d1 	b.w	80a48f6 <digitalWrite>
 80a1754:	bd38      	pop	{r3, r4, r5, pc}

080a1756 <_ZN17Adafruit_NeoPixelC1Ethh>:
  #error "*** PLATFORM_ID not supported by this library. PLATFORM should be Particle Core, Photon, Electron, Argon, Boron, Xenon and RedBear Duo ***"
#endif
// fast pin access
#define pinSet(_pin, _hilo) (_hilo ? pinHI(_pin) : pinLO(_pin))

Adafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, uint8_t p, uint8_t t) :
 80a1756:	b570      	push	{r4, r5, r6, lr}
 80a1758:	4604      	mov	r4, r0
 80a175a:	4616      	mov	r6, r2
  begun(false), type(t), brightness(0), pixels(NULL), endTime(0)
 80a175c:	2500      	movs	r5, #0
 80a175e:	7183      	strb	r3, [r0, #6]
 80a1760:	7005      	strb	r5, [r0, #0]
 80a1762:	7205      	strb	r5, [r0, #8]
 80a1764:	60c5      	str	r5, [r0, #12]
 80a1766:	6105      	str	r5, [r0, #16]
{
  updateLength(n);
 80a1768:	f7ff ffb4 	bl	80a16d4 <_ZN17Adafruit_NeoPixel12updateLengthEt>
  setPin(p);
 80a176c:	4620      	mov	r0, r4
 80a176e:	4631      	mov	r1, r6
 80a1770:	f7ff ffd9 	bl	80a1726 <_ZN17Adafruit_NeoPixel6setPinEh>
}
 80a1774:	4620      	mov	r0, r4
 80a1776:	bd70      	pop	{r4, r5, r6, pc}

080a1778 <_ZN17Adafruit_NeoPixel4showEv>:
        digitalWrite(p, LOW);
    }
}

void Adafruit_NeoPixel::show(void) {
  if(!pixels) return;
 80a1778:	68c3      	ldr	r3, [r0, #12]
 80a177a:	2b00      	cmp	r3, #0
 80a177c:	f000 858e 	beq.w	80a229c <_ZN17Adafruit_NeoPixel4showEv+0xb24>
        pinMode(p, OUTPUT);
        digitalWrite(p, LOW);
    }
}

void Adafruit_NeoPixel::show(void) {
 80a1780:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a1784:	4604      	mov	r4, r0
 80a1786:	7983      	ldrb	r3, [r0, #6]
 80a1788:	b086      	sub	sp, #24
 80a178a:	3b02      	subs	r3, #2
 80a178c:	b2db      	uxtb	r3, r3
 80a178e:	2b04      	cmp	r3, #4
 80a1790:	bf96      	itet	ls
 80a1792:	4a29      	ldrls	r2, [pc, #164]	; (80a1838 <_ZN17Adafruit_NeoPixel4showEv+0xc0>)
  // the function will simply hold off (if needed) on issuing the
  // subsequent round of data until the latch time has elapsed.  This
  // allows the mainline code to start generating the next frame of data
  // rather than stalling for the latch.
  uint32_t wait_time; // wait time in microseconds.
  switch(type) {
 80a1794:	2532      	movhi	r5, #50	; 0x32
 80a1796:	f852 5023 	ldrls.w	r5, [r2, r3, lsl #2]
    case WS2812B2_FAST:
    default: {   // default = 50us reset pulse
        wait_time = 50L;
      } break;
  }
  while((micros() - endTime) < wait_time);
 80a179a:	f7ff ff8b 	bl	80a16b4 <micros>
 80a179e:	6923      	ldr	r3, [r4, #16]
 80a17a0:	1ac0      	subs	r0, r0, r3
 80a17a2:	42a8      	cmp	r0, r5
 80a17a4:	d3f9      	bcc.n	80a179a <_ZN17Adafruit_NeoPixel4showEv+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 80a17a6:	b672      	cpsid	i
    g,              // Current green byte value
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a17a8:	79a1      	ldrb	r1, [r4, #6]
  __disable_irq(); // Need 100% focus on instruction timing

  volatile uint32_t
    c,    // 24-bit/32-bit pixel color
    mask; // 1-bit mask
  volatile uint16_t i = numBytes; // Output loop counter
 80a17aa:	88a3      	ldrh	r3, [r4, #4]
    g,              // Current green byte value
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a17ac:	2902      	cmp	r1, #2
  __disable_irq(); // Need 100% focus on instruction timing

  volatile uint32_t
    c,    // 24-bit/32-bit pixel color
    mask; // 1-bit mask
  volatile uint16_t i = numBytes; // Output loop counter
 80a17ae:	f8ad 300a 	strh.w	r3, [sp, #10]
  volatile uint8_t
    j,              // 8-bit inner loop counter
   *ptr = pixels,   // Pointer to next byte
 80a17b2:	f8d4 e00c 	ldr.w	lr, [r4, #12]
    g,              // Current green byte value
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a17b6:	f000 8272 	beq.w	80a1c9e <_ZN17Adafruit_NeoPixel4showEv+0x526>
 80a17ba:	2907      	cmp	r1, #7
 80a17bc:	f000 826f 	beq.w	80a1c9e <_ZN17Adafruit_NeoPixel4showEv+0x526>
        }
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == SK6812RGBW) { // similar to WS2812, 800 KHz bitstream but with RGB+W components
 80a17c0:	2906      	cmp	r1, #6
 80a17c2:	f000 8432 	beq.w	80a202a <_ZN17Adafruit_NeoPixel4showEv+0x8b2>
        }
        mask >>= 1;
      } while ( ++j < 32 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == WS2812B2 || type == WS2812B2_FAST) { // WS2812B with DWT timer
 80a17c6:	2905      	cmp	r1, #5
 80a17c8:	f000 83ab 	beq.w	80a1f22 <_ZN17Adafruit_NeoPixel4showEv+0x7aa>
 80a17cc:	2908      	cmp	r1, #8
 80a17ce:	f000 83a8 	beq.w	80a1f22 <_ZN17Adafruit_NeoPixel4showEv+0x7aa>
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
#endif
  }
  else if(type == WS2811) { // WS2811, 400 KHz bitstream
 80a17d2:	2900      	cmp	r1, #0
 80a17d4:	f040 8563 	bne.w	80a229e <_ZN17Adafruit_NeoPixel4showEv+0xb26>
 80a17d8:	4a18      	ldr	r2, [pc, #96]	; (80a183c <_ZN17Adafruit_NeoPixel4showEv+0xc4>)
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
 80a17da:	f44f 0600 	mov.w	r6, #8388608	; 0x800000
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
#endif
  }
  else if(type == WS2811) { // WS2811, 400 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a17de:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a17e2:	b29b      	uxth	r3, r3
 80a17e4:	2b00      	cmp	r3, #0
 80a17e6:	f000 8395 	beq.w	80a1f14 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a17ea:	9604      	str	r6, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a17ec:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a17f0:	f10e 0503 	add.w	r5, lr, #3
 80a17f4:	3b03      	subs	r3, #3
 80a17f6:	b29b      	uxth	r3, r3
 80a17f8:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a17fc:	f89e 3000 	ldrb.w	r3, [lr]
 80a1800:	b2db      	uxtb	r3, r3
 80a1802:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next green byte value
 80a1806:	f89e 3001 	ldrb.w	r3, [lr, #1]
 80a180a:	b2db      	uxtb	r3, r3
 80a180c:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next blue byte value
 80a1810:	f89e 3002 	ldrb.w	r3, [lr, #2]
 80a1814:	b2db      	uxtb	r3, r3
 80a1816:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a181a:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a181e:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a1822:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a1826:	021b      	lsls	r3, r3, #8
 80a1828:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a182c:	4303      	orrs	r3, r0
 80a182e:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a1830:	f88d 1005 	strb.w	r1, [sp, #5]
 80a1834:	e11b      	b.n	80a1a6e <_ZN17Adafruit_NeoPixel4showEv+0x2f6>
 80a1836:	bf00      	nop
 80a1838:	080a68e8 	.word	0x080a68e8
 80a183c:	20001330 	.word	0x20001330
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1840:	4600      	mov	r0, r0
 80a1842:	bf00      	nop
 80a1844:	bf00      	nop
 80a1846:	bf00      	nop
 80a1848:	bf00      	nop
 80a184a:	bf00      	nop
 80a184c:	bf00      	nop
 80a184e:	bf00      	nop
 80a1850:	bf00      	nop
 80a1852:	bf00      	nop
 80a1854:	bf00      	nop
 80a1856:	bf00      	nop
 80a1858:	bf00      	nop
 80a185a:	bf00      	nop
 80a185c:	bf00      	nop
 80a185e:	bf00      	nop
 80a1860:	bf00      	nop
 80a1862:	bf00      	nop
 80a1864:	bf00      	nop
 80a1866:	bf00      	nop
 80a1868:	bf00      	nop
 80a186a:	bf00      	nop
 80a186c:	bf00      	nop
 80a186e:	bf00      	nop
 80a1870:	bf00      	nop
 80a1872:	bf00      	nop
 80a1874:	bf00      	nop
 80a1876:	bf00      	nop
 80a1878:	bf00      	nop
 80a187a:	bf00      	nop
 80a187c:	bf00      	nop
 80a187e:	bf00      	nop
 80a1880:	bf00      	nop
 80a1882:	bf00      	nop
 80a1884:	bf00      	nop
 80a1886:	bf00      	nop
 80a1888:	bf00      	nop
 80a188a:	bf00      	nop
 80a188c:	bf00      	nop
 80a188e:	bf00      	nop
 80a1890:	bf00      	nop
 80a1892:	bf00      	nop
 80a1894:	bf00      	nop
 80a1896:	bf00      	nop
 80a1898:	bf00      	nop
 80a189a:	bf00      	nop
 80a189c:	bf00      	nop
 80a189e:	bf00      	nop
 80a18a0:	bf00      	nop
 80a18a2:	bf00      	nop
 80a18a4:	bf00      	nop
 80a18a6:	bf00      	nop
 80a18a8:	bf00      	nop
 80a18aa:	bf00      	nop
 80a18ac:	bf00      	nop
 80a18ae:	bf00      	nop
 80a18b0:	bf00      	nop
 80a18b2:	bf00      	nop
 80a18b4:	bf00      	nop
 80a18b6:	bf00      	nop
 80a18b8:	bf00      	nop
 80a18ba:	bf00      	nop
 80a18bc:	bf00      	nop
 80a18be:	bf00      	nop
 80a18c0:	bf00      	nop
 80a18c2:	bf00      	nop
 80a18c4:	bf00      	nop
 80a18c6:	bf00      	nop
 80a18c8:	bf00      	nop
 80a18ca:	bf00      	nop
 80a18cc:	bf00      	nop
 80a18ce:	bf00      	nop
 80a18d0:	bf00      	nop
 80a18d2:	bf00      	nop
 80a18d4:	bf00      	nop
 80a18d6:	bf00      	nop
 80a18d8:	bf00      	nop
 80a18da:	bf00      	nop
 80a18dc:	bf00      	nop
 80a18de:	bf00      	nop
 80a18e0:	bf00      	nop
 80a18e2:	bf00      	nop
 80a18e4:	bf00      	nop
 80a18e6:	bf00      	nop
 80a18e8:	bf00      	nop
 80a18ea:	bf00      	nop
 80a18ec:	bf00      	nop
 80a18ee:	bf00      	nop
 80a18f0:	bf00      	nop
 80a18f2:	bf00      	nop
 80a18f4:	bf00      	nop
 80a18f6:	bf00      	nop
 80a18f8:	bf00      	nop
 80a18fa:	bf00      	nop
 80a18fc:	bf00      	nop
 80a18fe:	bf00      	nop
 80a1900:	bf00      	nop
 80a1902:	bf00      	nop
 80a1904:	bf00      	nop
 80a1906:	bf00      	nop
 80a1908:	bf00      	nop
 80a190a:	bf00      	nop
 80a190c:	bf00      	nop
 80a190e:	bf00      	nop
 80a1910:	bf00      	nop
 80a1912:	bf00      	nop
 80a1914:	bf00      	nop
 80a1916:	bf00      	nop
 80a1918:	bf00      	nop
 80a191a:	bf00      	nop
 80a191c:	bf00      	nop
 80a191e:	bf00      	nop
 80a1920:	bf00      	nop
 80a1922:	bf00      	nop
 80a1924:	bf00      	nop
 80a1926:	bf00      	nop
 80a1928:	bf00      	nop
 80a192a:	bf00      	nop
 80a192c:	bf00      	nop
 80a192e:	bf00      	nop
 80a1930:	bf00      	nop
 80a1932:	bf00      	nop
 80a1934:	bf00      	nop
 80a1936:	bf00      	nop
 80a1938:	bf00      	nop
 80a193a:	bf00      	nop
 80a193c:	bf00      	nop
 80a193e:	bf00      	nop
 80a1940:	bf00      	nop
 80a1942:	bf00      	nop
 80a1944:	bf00      	nop
 80a1946:	bf00      	nop
          // WS2811 spec             1.30us LOW
          // Adafruit on Arduino    (meas. 1.25us)
          // This lib on Spark Core (meas. 1.24us)
          // This lib on Photon     (meas. 1.24us)
          pinSet(pin, LOW); // LOW
 80a1948:	79e3      	ldrb	r3, [r4, #7]
 80a194a:	6810      	ldr	r0, [r2, #0]
 80a194c:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a1950:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a1954:	88bf      	ldrh	r7, [r7, #4]
 80a1956:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a195a:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a195c:	4600      	mov	r0, r0
 80a195e:	bf00      	nop
 80a1960:	bf00      	nop
 80a1962:	bf00      	nop
 80a1964:	bf00      	nop
 80a1966:	bf00      	nop
 80a1968:	bf00      	nop
 80a196a:	bf00      	nop
 80a196c:	bf00      	nop
 80a196e:	bf00      	nop
 80a1970:	bf00      	nop
 80a1972:	bf00      	nop
 80a1974:	bf00      	nop
 80a1976:	bf00      	nop
 80a1978:	bf00      	nop
 80a197a:	bf00      	nop
 80a197c:	bf00      	nop
 80a197e:	bf00      	nop
 80a1980:	bf00      	nop
 80a1982:	bf00      	nop
 80a1984:	bf00      	nop
 80a1986:	bf00      	nop
 80a1988:	bf00      	nop
 80a198a:	bf00      	nop
 80a198c:	bf00      	nop
 80a198e:	bf00      	nop
 80a1990:	bf00      	nop
 80a1992:	bf00      	nop
 80a1994:	bf00      	nop
 80a1996:	bf00      	nop
 80a1998:	bf00      	nop
 80a199a:	bf00      	nop
 80a199c:	bf00      	nop
 80a199e:	bf00      	nop
 80a19a0:	bf00      	nop
 80a19a2:	bf00      	nop
 80a19a4:	bf00      	nop
 80a19a6:	bf00      	nop
 80a19a8:	bf00      	nop
 80a19aa:	bf00      	nop
 80a19ac:	bf00      	nop
 80a19ae:	bf00      	nop
 80a19b0:	bf00      	nop
 80a19b2:	bf00      	nop
 80a19b4:	bf00      	nop
 80a19b6:	bf00      	nop
 80a19b8:	bf00      	nop
 80a19ba:	bf00      	nop
 80a19bc:	bf00      	nop
 80a19be:	bf00      	nop
 80a19c0:	bf00      	nop
 80a19c2:	bf00      	nop
 80a19c4:	bf00      	nop
 80a19c6:	bf00      	nop
 80a19c8:	bf00      	nop
 80a19ca:	bf00      	nop
 80a19cc:	bf00      	nop
 80a19ce:	bf00      	nop
 80a19d0:	bf00      	nop
 80a19d2:	bf00      	nop
 80a19d4:	bf00      	nop
 80a19d6:	bf00      	nop
 80a19d8:	bf00      	nop
 80a19da:	bf00      	nop
 80a19dc:	bf00      	nop
 80a19de:	bf00      	nop
 80a19e0:	bf00      	nop
 80a19e2:	bf00      	nop
 80a19e4:	bf00      	nop
 80a19e6:	bf00      	nop
 80a19e8:	bf00      	nop
 80a19ea:	bf00      	nop
 80a19ec:	bf00      	nop
 80a19ee:	bf00      	nop
 80a19f0:	bf00      	nop
 80a19f2:	bf00      	nop
 80a19f4:	bf00      	nop
 80a19f6:	bf00      	nop
 80a19f8:	bf00      	nop
 80a19fa:	bf00      	nop
 80a19fc:	bf00      	nop
 80a19fe:	bf00      	nop
 80a1a00:	bf00      	nop
 80a1a02:	bf00      	nop
 80a1a04:	bf00      	nop
 80a1a06:	bf00      	nop
 80a1a08:	bf00      	nop
 80a1a0a:	bf00      	nop
 80a1a0c:	bf00      	nop
 80a1a0e:	bf00      	nop
 80a1a10:	bf00      	nop
 80a1a12:	bf00      	nop
 80a1a14:	bf00      	nop
 80a1a16:	bf00      	nop
 80a1a18:	bf00      	nop
 80a1a1a:	bf00      	nop
 80a1a1c:	bf00      	nop
 80a1a1e:	bf00      	nop
 80a1a20:	bf00      	nop
 80a1a22:	bf00      	nop
 80a1a24:	bf00      	nop
 80a1a26:	bf00      	nop
 80a1a28:	bf00      	nop
 80a1a2a:	bf00      	nop
 80a1a2c:	bf00      	nop
 80a1a2e:	bf00      	nop
 80a1a30:	bf00      	nop
 80a1a32:	bf00      	nop
 80a1a34:	bf00      	nop
 80a1a36:	bf00      	nop
 80a1a38:	bf00      	nop
 80a1a3a:	bf00      	nop
 80a1a3c:	bf00      	nop
 80a1a3e:	bf00      	nop
 80a1a40:	bf00      	nop
 80a1a42:	bf00      	nop
 80a1a44:	bf00      	nop
 80a1a46:	bf00      	nop
 80a1a48:	bf00      	nop
 80a1a4a:	bf00      	nop
 80a1a4c:	bf00      	nop
 80a1a4e:	bf00      	nop
 80a1a50:	bf00      	nop
 80a1a52:	bf00      	nop
 80a1a54:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a1a56:	9b04      	ldr	r3, [sp, #16]
 80a1a58:	085b      	lsrs	r3, r3, #1
 80a1a5a:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a1a5c:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a1a60:	3301      	adds	r3, #1
 80a1a62:	b2db      	uxtb	r3, r3
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
 80a1a64:	2b17      	cmp	r3, #23
 80a1a66:	f88d 3005 	strb.w	r3, [sp, #5]
 80a1a6a:	f200 82db 	bhi.w	80a2024 <_ZN17Adafruit_NeoPixel4showEv+0x8ac>
        pinSet(pin, HIGH); // HIGH
 80a1a6e:	79e3      	ldrb	r3, [r4, #7]
 80a1a70:	6810      	ldr	r0, [r2, #0]
 80a1a72:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a1a76:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a1a7a:	88bf      	ldrh	r7, [r7, #4]
 80a1a7c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1a80:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a1a82:	9803      	ldr	r0, [sp, #12]
 80a1a84:	9b04      	ldr	r3, [sp, #16]
 80a1a86:	4218      	tst	r0, r3
 80a1a88:	f47f aeda 	bne.w	80a1840 <_ZN17Adafruit_NeoPixel4showEv+0xc8>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            "nop" "\n\t" "nop" "\n\t"
            ::: "r0", "cc", "memory");
 80a1a8c:	4600      	mov	r0, r0
 80a1a8e:	bf00      	nop
 80a1a90:	bf00      	nop
 80a1a92:	bf00      	nop
 80a1a94:	bf00      	nop
 80a1a96:	bf00      	nop
 80a1a98:	bf00      	nop
 80a1a9a:	bf00      	nop
 80a1a9c:	bf00      	nop
 80a1a9e:	bf00      	nop
 80a1aa0:	bf00      	nop
 80a1aa2:	bf00      	nop
 80a1aa4:	bf00      	nop
 80a1aa6:	bf00      	nop
 80a1aa8:	bf00      	nop
 80a1aaa:	bf00      	nop
 80a1aac:	bf00      	nop
 80a1aae:	bf00      	nop
 80a1ab0:	bf00      	nop
 80a1ab2:	bf00      	nop
 80a1ab4:	bf00      	nop
 80a1ab6:	bf00      	nop
 80a1ab8:	bf00      	nop
 80a1aba:	bf00      	nop
 80a1abc:	bf00      	nop
 80a1abe:	bf00      	nop
 80a1ac0:	bf00      	nop
 80a1ac2:	bf00      	nop
 80a1ac4:	bf00      	nop
 80a1ac6:	bf00      	nop
 80a1ac8:	bf00      	nop
 80a1aca:	bf00      	nop
 80a1acc:	bf00      	nop
 80a1ace:	bf00      	nop
 80a1ad0:	bf00      	nop
 80a1ad2:	bf00      	nop
 80a1ad4:	bf00      	nop
 80a1ad6:	bf00      	nop
 80a1ad8:	bf00      	nop
 80a1ada:	bf00      	nop
 80a1adc:	bf00      	nop
          // WS2811 spec             2.000us LOW
          // Adafruit on Arduino    (meas. 2.000us)
          // This lib on Spark Core (meas. 2.000us)
          // This lib on Photon     (meas. 2.000us)
          pinSet(pin, LOW); // LOW
 80a1ade:	79e3      	ldrb	r3, [r4, #7]
 80a1ae0:	6810      	ldr	r0, [r2, #0]
 80a1ae2:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a1ae6:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a1aea:	88bf      	ldrh	r7, [r7, #4]
 80a1aec:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1af0:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1af2:	4600      	mov	r0, r0
 80a1af4:	bf00      	nop
 80a1af6:	bf00      	nop
 80a1af8:	bf00      	nop
 80a1afa:	bf00      	nop
 80a1afc:	bf00      	nop
 80a1afe:	bf00      	nop
 80a1b00:	bf00      	nop
 80a1b02:	bf00      	nop
 80a1b04:	bf00      	nop
 80a1b06:	bf00      	nop
 80a1b08:	bf00      	nop
 80a1b0a:	bf00      	nop
 80a1b0c:	bf00      	nop
 80a1b0e:	bf00      	nop
 80a1b10:	bf00      	nop
 80a1b12:	bf00      	nop
 80a1b14:	bf00      	nop
 80a1b16:	bf00      	nop
 80a1b18:	bf00      	nop
 80a1b1a:	bf00      	nop
 80a1b1c:	bf00      	nop
 80a1b1e:	bf00      	nop
 80a1b20:	bf00      	nop
 80a1b22:	bf00      	nop
 80a1b24:	bf00      	nop
 80a1b26:	bf00      	nop
 80a1b28:	bf00      	nop
 80a1b2a:	bf00      	nop
 80a1b2c:	bf00      	nop
 80a1b2e:	bf00      	nop
 80a1b30:	bf00      	nop
 80a1b32:	bf00      	nop
 80a1b34:	bf00      	nop
 80a1b36:	bf00      	nop
 80a1b38:	bf00      	nop
 80a1b3a:	bf00      	nop
 80a1b3c:	bf00      	nop
 80a1b3e:	bf00      	nop
 80a1b40:	bf00      	nop
 80a1b42:	bf00      	nop
 80a1b44:	bf00      	nop
 80a1b46:	bf00      	nop
 80a1b48:	bf00      	nop
 80a1b4a:	bf00      	nop
 80a1b4c:	bf00      	nop
 80a1b4e:	bf00      	nop
 80a1b50:	bf00      	nop
 80a1b52:	bf00      	nop
 80a1b54:	bf00      	nop
 80a1b56:	bf00      	nop
 80a1b58:	bf00      	nop
 80a1b5a:	bf00      	nop
 80a1b5c:	bf00      	nop
 80a1b5e:	bf00      	nop
 80a1b60:	bf00      	nop
 80a1b62:	bf00      	nop
 80a1b64:	bf00      	nop
 80a1b66:	bf00      	nop
 80a1b68:	bf00      	nop
 80a1b6a:	bf00      	nop
 80a1b6c:	bf00      	nop
 80a1b6e:	bf00      	nop
 80a1b70:	bf00      	nop
 80a1b72:	bf00      	nop
 80a1b74:	bf00      	nop
 80a1b76:	bf00      	nop
 80a1b78:	bf00      	nop
 80a1b7a:	bf00      	nop
 80a1b7c:	bf00      	nop
 80a1b7e:	bf00      	nop
 80a1b80:	bf00      	nop
 80a1b82:	bf00      	nop
 80a1b84:	bf00      	nop
 80a1b86:	bf00      	nop
 80a1b88:	bf00      	nop
 80a1b8a:	bf00      	nop
 80a1b8c:	bf00      	nop
 80a1b8e:	bf00      	nop
 80a1b90:	bf00      	nop
 80a1b92:	bf00      	nop
 80a1b94:	bf00      	nop
 80a1b96:	bf00      	nop
 80a1b98:	bf00      	nop
 80a1b9a:	bf00      	nop
 80a1b9c:	bf00      	nop
 80a1b9e:	bf00      	nop
 80a1ba0:	bf00      	nop
 80a1ba2:	bf00      	nop
 80a1ba4:	bf00      	nop
 80a1ba6:	bf00      	nop
 80a1ba8:	bf00      	nop
 80a1baa:	bf00      	nop
 80a1bac:	bf00      	nop
 80a1bae:	bf00      	nop
 80a1bb0:	bf00      	nop
 80a1bb2:	bf00      	nop
 80a1bb4:	bf00      	nop
 80a1bb6:	bf00      	nop
 80a1bb8:	bf00      	nop
 80a1bba:	bf00      	nop
 80a1bbc:	bf00      	nop
 80a1bbe:	bf00      	nop
 80a1bc0:	bf00      	nop
 80a1bc2:	bf00      	nop
 80a1bc4:	bf00      	nop
 80a1bc6:	bf00      	nop
 80a1bc8:	bf00      	nop
 80a1bca:	bf00      	nop
 80a1bcc:	bf00      	nop
 80a1bce:	bf00      	nop
 80a1bd0:	bf00      	nop
 80a1bd2:	bf00      	nop
 80a1bd4:	bf00      	nop
 80a1bd6:	bf00      	nop
 80a1bd8:	bf00      	nop
 80a1bda:	bf00      	nop
 80a1bdc:	bf00      	nop
 80a1bde:	bf00      	nop
 80a1be0:	bf00      	nop
 80a1be2:	bf00      	nop
 80a1be4:	bf00      	nop
 80a1be6:	bf00      	nop
 80a1be8:	bf00      	nop
 80a1bea:	bf00      	nop
 80a1bec:	bf00      	nop
 80a1bee:	bf00      	nop
 80a1bf0:	bf00      	nop
 80a1bf2:	bf00      	nop
 80a1bf4:	bf00      	nop
 80a1bf6:	bf00      	nop
 80a1bf8:	bf00      	nop
 80a1bfa:	bf00      	nop
 80a1bfc:	bf00      	nop
 80a1bfe:	bf00      	nop
 80a1c00:	bf00      	nop
 80a1c02:	bf00      	nop
 80a1c04:	bf00      	nop
 80a1c06:	bf00      	nop
 80a1c08:	bf00      	nop
 80a1c0a:	bf00      	nop
 80a1c0c:	bf00      	nop
 80a1c0e:	bf00      	nop
 80a1c10:	bf00      	nop
 80a1c12:	bf00      	nop
 80a1c14:	bf00      	nop
 80a1c16:	bf00      	nop
 80a1c18:	bf00      	nop
 80a1c1a:	bf00      	nop
 80a1c1c:	bf00      	nop
 80a1c1e:	bf00      	nop
 80a1c20:	bf00      	nop
 80a1c22:	bf00      	nop
 80a1c24:	bf00      	nop
 80a1c26:	bf00      	nop
 80a1c28:	bf00      	nop
 80a1c2a:	bf00      	nop
 80a1c2c:	bf00      	nop
 80a1c2e:	bf00      	nop
 80a1c30:	bf00      	nop
 80a1c32:	bf00      	nop
 80a1c34:	bf00      	nop
 80a1c36:	bf00      	nop
 80a1c38:	bf00      	nop
 80a1c3a:	bf00      	nop
 80a1c3c:	bf00      	nop
 80a1c3e:	bf00      	nop
 80a1c40:	bf00      	nop
 80a1c42:	bf00      	nop
 80a1c44:	bf00      	nop
 80a1c46:	bf00      	nop
 80a1c48:	bf00      	nop
 80a1c4a:	bf00      	nop
 80a1c4c:	bf00      	nop
 80a1c4e:	bf00      	nop
 80a1c50:	bf00      	nop
 80a1c52:	bf00      	nop
 80a1c54:	bf00      	nop
 80a1c56:	bf00      	nop
 80a1c58:	bf00      	nop
 80a1c5a:	bf00      	nop
 80a1c5c:	bf00      	nop
 80a1c5e:	bf00      	nop
 80a1c60:	bf00      	nop
 80a1c62:	bf00      	nop
 80a1c64:	bf00      	nop
 80a1c66:	bf00      	nop
 80a1c68:	bf00      	nop
 80a1c6a:	bf00      	nop
 80a1c6c:	bf00      	nop
 80a1c6e:	bf00      	nop
 80a1c70:	bf00      	nop
 80a1c72:	bf00      	nop
 80a1c74:	bf00      	nop
 80a1c76:	bf00      	nop
 80a1c78:	bf00      	nop
 80a1c7a:	bf00      	nop
 80a1c7c:	bf00      	nop
 80a1c7e:	bf00      	nop
 80a1c80:	bf00      	nop
 80a1c82:	bf00      	nop
 80a1c84:	bf00      	nop
 80a1c86:	bf00      	nop
 80a1c88:	bf00      	nop
 80a1c8a:	bf00      	nop
 80a1c8c:	bf00      	nop
 80a1c8e:	bf00      	nop
 80a1c90:	bf00      	nop
 80a1c92:	bf00      	nop
 80a1c94:	bf00      	nop
 80a1c96:	bf00      	nop
 80a1c98:	bf00      	nop
 80a1c9a:	bf00      	nop
 80a1c9c:	e6db      	b.n	80a1a56 <_ZN17Adafruit_NeoPixel4showEv+0x2de>
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a1c9e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a1ca2:	4a17      	ldr	r2, [pc, #92]	; (80a1d00 <_ZN17Adafruit_NeoPixel4showEv+0x588>)
 80a1ca4:	b29b      	uxth	r3, r3
      mask = 0x800000; // reset the mask
 80a1ca6:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      i = i-3;      // decrement bytes remaining
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
 80a1caa:	2600      	movs	r6, #0
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a1cac:	2b00      	cmp	r3, #0
 80a1cae:	f000 8131 	beq.w	80a1f14 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a1cb2:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a1cb4:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a1cb8:	f10e 0103 	add.w	r1, lr, #3
 80a1cbc:	3b03      	subs	r3, #3
 80a1cbe:	b29b      	uxth	r3, r3
 80a1cc0:	f8ad 300a 	strh.w	r3, [sp, #10]
      g = *ptr++;   // Next green byte value
 80a1cc4:	f89e 3000 	ldrb.w	r3, [lr]
 80a1cc8:	b2db      	uxtb	r3, r3
 80a1cca:	f88d 3006 	strb.w	r3, [sp, #6]
      r = *ptr++;   // Next red byte value
 80a1cce:	f89e 3001 	ldrb.w	r3, [lr, #1]
 80a1cd2:	b2db      	uxtb	r3, r3
 80a1cd4:	f88d 3007 	strb.w	r3, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a1cd8:	f89e 3002 	ldrb.w	r3, [lr, #2]
 80a1cdc:	b2db      	uxtb	r3, r3
 80a1cde:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a1ce2:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a1ce6:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80a1cea:	f89d 7008 	ldrb.w	r7, [sp, #8]
 80a1cee:	0200      	lsls	r0, r0, #8
 80a1cf0:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 80a1cf4:	433b      	orrs	r3, r7
 80a1cf6:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a1cf8:	f88d 6005 	strb.w	r6, [sp, #5]
 80a1cfc:	e080      	b.n	80a1e00 <_ZN17Adafruit_NeoPixel4showEv+0x688>
 80a1cfe:	bf00      	nop
 80a1d00:	20001330 	.word	0x20001330
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1d04:	4600      	mov	r0, r0
 80a1d06:	bf00      	nop
 80a1d08:	bf00      	nop
 80a1d0a:	bf00      	nop
 80a1d0c:	bf00      	nop
 80a1d0e:	bf00      	nop
 80a1d10:	bf00      	nop
 80a1d12:	bf00      	nop
 80a1d14:	bf00      	nop
 80a1d16:	bf00      	nop
 80a1d18:	bf00      	nop
 80a1d1a:	bf00      	nop
 80a1d1c:	bf00      	nop
 80a1d1e:	bf00      	nop
 80a1d20:	bf00      	nop
 80a1d22:	bf00      	nop
 80a1d24:	bf00      	nop
 80a1d26:	bf00      	nop
 80a1d28:	bf00      	nop
 80a1d2a:	bf00      	nop
 80a1d2c:	bf00      	nop
 80a1d2e:	bf00      	nop
 80a1d30:	bf00      	nop
 80a1d32:	bf00      	nop
 80a1d34:	bf00      	nop
 80a1d36:	bf00      	nop
 80a1d38:	bf00      	nop
 80a1d3a:	bf00      	nop
 80a1d3c:	bf00      	nop
 80a1d3e:	bf00      	nop
 80a1d40:	bf00      	nop
 80a1d42:	bf00      	nop
 80a1d44:	bf00      	nop
 80a1d46:	bf00      	nop
 80a1d48:	bf00      	nop
 80a1d4a:	bf00      	nop
 80a1d4c:	bf00      	nop
 80a1d4e:	bf00      	nop
 80a1d50:	bf00      	nop
 80a1d52:	bf00      	nop
 80a1d54:	bf00      	nop
 80a1d56:	bf00      	nop
 80a1d58:	bf00      	nop
 80a1d5a:	bf00      	nop
 80a1d5c:	bf00      	nop
 80a1d5e:	bf00      	nop
 80a1d60:	bf00      	nop
 80a1d62:	bf00      	nop
 80a1d64:	bf00      	nop
 80a1d66:	bf00      	nop
 80a1d68:	bf00      	nop
 80a1d6a:	bf00      	nop
 80a1d6c:	bf00      	nop
 80a1d6e:	bf00      	nop
 80a1d70:	bf00      	nop
 80a1d72:	bf00      	nop
 80a1d74:	bf00      	nop
 80a1d76:	bf00      	nop
 80a1d78:	bf00      	nop
 80a1d7a:	bf00      	nop
 80a1d7c:	bf00      	nop
 80a1d7e:	bf00      	nop
 80a1d80:	bf00      	nop
 80a1d82:	bf00      	nop
 80a1d84:	bf00      	nop
 80a1d86:	bf00      	nop
 80a1d88:	bf00      	nop
 80a1d8a:	bf00      	nop
 80a1d8c:	bf00      	nop
 80a1d8e:	bf00      	nop
 80a1d90:	bf00      	nop
 80a1d92:	bf00      	nop
 80a1d94:	bf00      	nop
 80a1d96:	bf00      	nop
 80a1d98:	bf00      	nop
 80a1d9a:	bf00      	nop
 80a1d9c:	bf00      	nop
          // WS2812 spec             600ns LOW
          // Adafruit on Arduino    (meas. 436ns)
          // This lib on Spark Core (meas. 446ns)
          // This lib on Photon     (meas. 434ns)
          pinSet(pin, LOW); // LOW
 80a1d9e:	79e3      	ldrb	r3, [r4, #7]
 80a1da0:	6810      	ldr	r0, [r2, #0]
 80a1da2:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a1da6:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a1daa:	88bf      	ldrh	r7, [r7, #4]
 80a1dac:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1db0:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1db2:	4600      	mov	r0, r0
 80a1db4:	bf00      	nop
 80a1db6:	bf00      	nop
 80a1db8:	bf00      	nop
 80a1dba:	bf00      	nop
 80a1dbc:	bf00      	nop
 80a1dbe:	bf00      	nop
 80a1dc0:	bf00      	nop
 80a1dc2:	bf00      	nop
 80a1dc4:	bf00      	nop
 80a1dc6:	bf00      	nop
 80a1dc8:	bf00      	nop
 80a1dca:	bf00      	nop
 80a1dcc:	bf00      	nop
 80a1dce:	bf00      	nop
 80a1dd0:	bf00      	nop
 80a1dd2:	bf00      	nop
 80a1dd4:	bf00      	nop
 80a1dd6:	bf00      	nop
 80a1dd8:	bf00      	nop
 80a1dda:	bf00      	nop
 80a1ddc:	bf00      	nop
 80a1dde:	bf00      	nop
 80a1de0:	bf00      	nop
 80a1de2:	bf00      	nop
 80a1de4:	bf00      	nop
 80a1de6:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a1de8:	9b04      	ldr	r3, [sp, #16]
 80a1dea:	085b      	lsrs	r3, r3, #1
 80a1dec:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a1dee:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a1df2:	3301      	adds	r3, #1
 80a1df4:	b2db      	uxtb	r3, r3
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
 80a1df6:	2b17      	cmp	r3, #23
 80a1df8:	f88d 3005 	strb.w	r3, [sp, #5]
 80a1dfc:	f200 8083 	bhi.w	80a1f06 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
        pinSet(pin, HIGH); // HIGH
 80a1e00:	79e3      	ldrb	r3, [r4, #7]
 80a1e02:	6810      	ldr	r0, [r2, #0]
 80a1e04:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a1e08:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a1e0c:	88bf      	ldrh	r7, [r7, #4]
 80a1e0e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1e12:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a1e14:	9803      	ldr	r0, [sp, #12]
 80a1e16:	9b04      	ldr	r3, [sp, #16]
 80a1e18:	4218      	tst	r0, r3
 80a1e1a:	f47f af73 	bne.w	80a1d04 <_ZN17Adafruit_NeoPixel4showEv+0x58c>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1e1e:	4600      	mov	r0, r0
 80a1e20:	bf00      	nop
 80a1e22:	bf00      	nop
 80a1e24:	bf00      	nop
 80a1e26:	bf00      	nop
 80a1e28:	bf00      	nop
 80a1e2a:	bf00      	nop
 80a1e2c:	bf00      	nop
 80a1e2e:	bf00      	nop
 80a1e30:	bf00      	nop
 80a1e32:	bf00      	nop
 80a1e34:	bf00      	nop
 80a1e36:	bf00      	nop
 80a1e38:	bf00      	nop
 80a1e3a:	bf00      	nop
 80a1e3c:	bf00      	nop
 80a1e3e:	bf00      	nop
 80a1e40:	bf00      	nop
 80a1e42:	bf00      	nop
 80a1e44:	bf00      	nop
          // WS2812 spec             800ns LOW
          // Adafruit on Arduino    (meas. 938ns)
          // This lib on Spark Core (meas. 944ns)
          // This lib on Photon     (meas. 936ns)
          pinSet(pin, LOW); // LOW
 80a1e46:	79e3      	ldrb	r3, [r4, #7]
 80a1e48:	6810      	ldr	r0, [r2, #0]
 80a1e4a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a1e4e:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a1e52:	88bf      	ldrh	r7, [r7, #4]
 80a1e54:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a1e58:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a1e5a:	4600      	mov	r0, r0
 80a1e5c:	bf00      	nop
 80a1e5e:	bf00      	nop
 80a1e60:	bf00      	nop
 80a1e62:	bf00      	nop
 80a1e64:	bf00      	nop
 80a1e66:	bf00      	nop
 80a1e68:	bf00      	nop
 80a1e6a:	bf00      	nop
 80a1e6c:	bf00      	nop
 80a1e6e:	bf00      	nop
 80a1e70:	bf00      	nop
 80a1e72:	bf00      	nop
 80a1e74:	bf00      	nop
 80a1e76:	bf00      	nop
 80a1e78:	bf00      	nop
 80a1e7a:	bf00      	nop
 80a1e7c:	bf00      	nop
 80a1e7e:	bf00      	nop
 80a1e80:	bf00      	nop
 80a1e82:	bf00      	nop
 80a1e84:	bf00      	nop
 80a1e86:	bf00      	nop
 80a1e88:	bf00      	nop
 80a1e8a:	bf00      	nop
 80a1e8c:	bf00      	nop
 80a1e8e:	bf00      	nop
 80a1e90:	bf00      	nop
 80a1e92:	bf00      	nop
 80a1e94:	bf00      	nop
 80a1e96:	bf00      	nop
 80a1e98:	bf00      	nop
 80a1e9a:	bf00      	nop
 80a1e9c:	bf00      	nop
 80a1e9e:	bf00      	nop
 80a1ea0:	bf00      	nop
 80a1ea2:	bf00      	nop
 80a1ea4:	bf00      	nop
 80a1ea6:	bf00      	nop
 80a1ea8:	bf00      	nop
 80a1eaa:	bf00      	nop
 80a1eac:	bf00      	nop
 80a1eae:	bf00      	nop
 80a1eb0:	bf00      	nop
 80a1eb2:	bf00      	nop
 80a1eb4:	bf00      	nop
 80a1eb6:	bf00      	nop
 80a1eb8:	bf00      	nop
 80a1eba:	bf00      	nop
 80a1ebc:	bf00      	nop
 80a1ebe:	bf00      	nop
 80a1ec0:	bf00      	nop
 80a1ec2:	bf00      	nop
 80a1ec4:	bf00      	nop
 80a1ec6:	bf00      	nop
 80a1ec8:	bf00      	nop
 80a1eca:	bf00      	nop
 80a1ecc:	bf00      	nop
 80a1ece:	bf00      	nop
 80a1ed0:	bf00      	nop
 80a1ed2:	bf00      	nop
 80a1ed4:	bf00      	nop
 80a1ed6:	bf00      	nop
 80a1ed8:	bf00      	nop
 80a1eda:	bf00      	nop
 80a1edc:	bf00      	nop
 80a1ede:	bf00      	nop
 80a1ee0:	bf00      	nop
 80a1ee2:	bf00      	nop
 80a1ee4:	bf00      	nop
 80a1ee6:	bf00      	nop
 80a1ee8:	bf00      	nop
 80a1eea:	bf00      	nop
 80a1eec:	bf00      	nop
 80a1eee:	bf00      	nop
 80a1ef0:	bf00      	nop
 80a1ef2:	bf00      	nop
 80a1ef4:	bf00      	nop
 80a1ef6:	bf00      	nop
 80a1ef8:	bf00      	nop
 80a1efa:	bf00      	nop
 80a1efc:	bf00      	nop
 80a1efe:	bf00      	nop
 80a1f00:	bf00      	nop
 80a1f02:	bf00      	nop
 80a1f04:	e770      	b.n	80a1de8 <_ZN17Adafruit_NeoPixel4showEv+0x670>
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a1f06:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
 80a1f0a:	468e      	mov	lr, r1
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a1f0c:	b29b      	uxth	r3, r3
 80a1f0e:	2b00      	cmp	r3, #0
 80a1f10:	f47f aecf 	bne.w	80a1cb2 <_ZN17Adafruit_NeoPixel4showEv+0x53a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
 80a1f14:	b662      	cpsie	i
  }
// END of NRF52 implementation


#endif
  endTime = micros(); // Save EOD time for latch on next call
 80a1f16:	f7ff fbcd 	bl	80a16b4 <micros>
 80a1f1a:	6120      	str	r0, [r4, #16]
}
 80a1f1c:	b006      	add	sp, #24
 80a1f1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
        cyc = DWT->CYCCNT;
 80a1f22:	4b5e      	ldr	r3, [pc, #376]	; (80a209c <_ZN17Adafruit_NeoPixel4showEv+0x924>)
 80a1f24:	4a5e      	ldr	r2, [pc, #376]	; (80a20a0 <_ZN17Adafruit_NeoPixel4showEv+0x928>)
        pinSet(pin, HIGH); // HIGH
        if (c & mask) { // if masked bit is high
          while(DWT->CYCCNT - cyc < CYCLES_800_T1H);
 80a1f26:	4618      	mov	r0, r3
 80a1f28:	6811      	ldr	r1, [r2, #0]
    #define CYCLES_800_T1L  8  // 436ns (meas. 425ns)

    volatile uint32_t cyc;

    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
 80a1f2a:	f44f 0800 	mov.w	r8, #8388608	; 0x800000
      i = i-3;      // decrement bytes remaining
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
 80a1f2e:	2700      	movs	r7, #0
    #define CYCLES_800_T1H  80 // 812ns (meas. 792ns)
    #define CYCLES_800_T1L  8  // 436ns (meas. 425ns)

    volatile uint32_t cyc;

    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a1f30:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 80a1f34:	b292      	uxth	r2, r2
 80a1f36:	2a00      	cmp	r2, #0
 80a1f38:	d0ec      	beq.n	80a1f14 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a1f3a:	f8cd 8010 	str.w	r8, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a1f3e:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 80a1f42:	f10e 0503 	add.w	r5, lr, #3
 80a1f46:	3a03      	subs	r2, #3
 80a1f48:	b292      	uxth	r2, r2
 80a1f4a:	f8ad 200a 	strh.w	r2, [sp, #10]
      g = *ptr++;   // Next green byte value
 80a1f4e:	f89e 2000 	ldrb.w	r2, [lr]
 80a1f52:	b2d2      	uxtb	r2, r2
 80a1f54:	f88d 2006 	strb.w	r2, [sp, #6]
      r = *ptr++;   // Next red byte value
 80a1f58:	f89e 2001 	ldrb.w	r2, [lr, #1]
 80a1f5c:	b2d2      	uxtb	r2, r2
 80a1f5e:	f88d 2007 	strb.w	r2, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a1f62:	f89e 2002 	ldrb.w	r2, [lr, #2]
 80a1f66:	b2d2      	uxtb	r2, r2
 80a1f68:	f88d 2008 	strb.w	r2, [sp, #8]
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a1f6c:	f89d 2006 	ldrb.w	r2, [sp, #6]
 80a1f70:	f89d e007 	ldrb.w	lr, [sp, #7]
 80a1f74:	f89d c008 	ldrb.w	ip, [sp, #8]
 80a1f78:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 80a1f7c:	ea4e 4202 	orr.w	r2, lr, r2, lsl #16
 80a1f80:	ea42 020c 	orr.w	r2, r2, ip
 80a1f84:	9203      	str	r2, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a1f86:	f88d 7005 	strb.w	r7, [sp, #5]
      do {
        cyc = DWT->CYCCNT;
        pinSet(pin, HIGH); // HIGH
 80a1f8a:	79e2      	ldrb	r2, [r4, #7]
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
        cyc = DWT->CYCCNT;
 80a1f8c:	685e      	ldr	r6, [r3, #4]
        pinSet(pin, HIGH); // HIGH
 80a1f8e:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a1f92:	eb01 0e82 	add.w	lr, r1, r2, lsl #2
 80a1f96:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a1f9a:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
        cyc = DWT->CYCCNT;
 80a1f9e:	9605      	str	r6, [sp, #20]
        pinSet(pin, HIGH); // HIGH
 80a1fa0:	f8a2 e018 	strh.w	lr, [r2, #24]
        if (c & mask) { // if masked bit is high
 80a1fa4:	9e03      	ldr	r6, [sp, #12]
 80a1fa6:	9a04      	ldr	r2, [sp, #16]
 80a1fa8:	4216      	tst	r6, r2
 80a1faa:	d023      	beq.n	80a1ff4 <_ZN17Adafruit_NeoPixel4showEv+0x87c>
          while(DWT->CYCCNT - cyc < CYCLES_800_T1H);
 80a1fac:	685a      	ldr	r2, [r3, #4]
 80a1fae:	9e05      	ldr	r6, [sp, #20]
 80a1fb0:	1b92      	subs	r2, r2, r6
 80a1fb2:	2a4f      	cmp	r2, #79	; 0x4f
 80a1fb4:	d9fa      	bls.n	80a1fac <_ZN17Adafruit_NeoPixel4showEv+0x834>
          pinSet(pin, LOW);
 80a1fb6:	79e2      	ldrb	r2, [r4, #7]
 80a1fb8:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a1fbc:	eb01 0e82 	add.w	lr, r1, r2, lsl #2
 80a1fc0:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a1fc4:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 80a1fc8:	f8a2 e01a 	strh.w	lr, [r2, #26]
          cyc = DWT->CYCCNT;
 80a1fcc:	6842      	ldr	r2, [r0, #4]
 80a1fce:	9205      	str	r2, [sp, #20]
          while(DWT->CYCCNT - cyc < CYCLES_800_T1L);
 80a1fd0:	685a      	ldr	r2, [r3, #4]
 80a1fd2:	9e05      	ldr	r6, [sp, #20]
 80a1fd4:	1b92      	subs	r2, r2, r6
 80a1fd6:	2a07      	cmp	r2, #7
 80a1fd8:	d9fa      	bls.n	80a1fd0 <_ZN17Adafruit_NeoPixel4showEv+0x858>
          while(DWT->CYCCNT - cyc < CYCLES_800_T0H);
          pinSet(pin, LOW);
          cyc = DWT->CYCCNT;
          while(DWT->CYCCNT - cyc < CYCLES_800_T0L);
        }
        mask >>= 1;
 80a1fda:	9a04      	ldr	r2, [sp, #16]
 80a1fdc:	0852      	lsrs	r2, r2, #1
 80a1fde:	9204      	str	r2, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a1fe0:	f89d 2005 	ldrb.w	r2, [sp, #5]
 80a1fe4:	3201      	adds	r2, #1
 80a1fe6:	b2d2      	uxtb	r2, r2
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
 80a1fe8:	2a17      	cmp	r2, #23
 80a1fea:	f88d 2005 	strb.w	r2, [sp, #5]
 80a1fee:	d9cc      	bls.n	80a1f8a <_ZN17Adafruit_NeoPixel4showEv+0x812>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
 80a1ff0:	46ae      	mov	lr, r5
 80a1ff2:	e79d      	b.n	80a1f30 <_ZN17Adafruit_NeoPixel4showEv+0x7b8>
          pinSet(pin, LOW);
          cyc = DWT->CYCCNT;
          while(DWT->CYCCNT - cyc < CYCLES_800_T1L);
        }
        else { // else masked bit is low
          while(DWT->CYCCNT - cyc < CYCLES_800_T0H);
 80a1ff4:	685a      	ldr	r2, [r3, #4]
 80a1ff6:	9e05      	ldr	r6, [sp, #20]
 80a1ff8:	1b92      	subs	r2, r2, r6
 80a1ffa:	2a18      	cmp	r2, #24
 80a1ffc:	d9fa      	bls.n	80a1ff4 <_ZN17Adafruit_NeoPixel4showEv+0x87c>
          pinSet(pin, LOW);
 80a1ffe:	79e2      	ldrb	r2, [r4, #7]
 80a2000:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a2004:	eb01 0e82 	add.w	lr, r1, r2, lsl #2
 80a2008:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a200c:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 80a2010:	f8a2 e01a 	strh.w	lr, [r2, #26]
          cyc = DWT->CYCCNT;
 80a2014:	6842      	ldr	r2, [r0, #4]
 80a2016:	9205      	str	r2, [sp, #20]
          while(DWT->CYCCNT - cyc < CYCLES_800_T0L);
 80a2018:	685a      	ldr	r2, [r3, #4]
 80a201a:	9e05      	ldr	r6, [sp, #20]
 80a201c:	1b92      	subs	r2, r2, r6
 80a201e:	2a45      	cmp	r2, #69	; 0x45
 80a2020:	d9fa      	bls.n	80a2018 <_ZN17Adafruit_NeoPixel4showEv+0x8a0>
 80a2022:	e7da      	b.n	80a1fda <_ZN17Adafruit_NeoPixel4showEv+0x862>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
 80a2024:	46ae      	mov	lr, r5
 80a2026:	f7ff bbda 	b.w	80a17de <_ZN17Adafruit_NeoPixel4showEv+0x66>
 80a202a:	4a1d      	ldr	r2, [pc, #116]	; (80a20a0 <_ZN17Adafruit_NeoPixel4showEv+0x928>)
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == SK6812RGBW) { // similar to WS2812, 800 KHz bitstream but with RGB+W components
    while(i) { // While bytes left... (4 bytes = 1 pixel)
      mask = 0x80000000; // reset the mask
 80a202c:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
      w = *ptr++;   // Next white byte value
      c = ((uint32_t)r << 24) | ((uint32_t)g << 16) | ((uint32_t)b <<  8) | w; // Pack the next 4 bytes to keep timing tight
      j = 0;        // reset the 32-bit counter
 80a2030:	2600      	movs	r6, #0
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == SK6812RGBW) { // similar to WS2812, 800 KHz bitstream but with RGB+W components
    while(i) { // While bytes left... (4 bytes = 1 pixel)
 80a2032:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a2036:	b29b      	uxth	r3, r3
 80a2038:	2b00      	cmp	r3, #0
 80a203a:	f43f af6b 	beq.w	80a1f14 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x80000000; // reset the mask
 80a203e:	9504      	str	r5, [sp, #16]
      i = i-4;      // decrement bytes remaining
 80a2040:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a2044:	f10e 0104 	add.w	r1, lr, #4
 80a2048:	3b04      	subs	r3, #4
 80a204a:	b29b      	uxth	r3, r3
 80a204c:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a2050:	f89e 3000 	ldrb.w	r3, [lr]
 80a2054:	b2db      	uxtb	r3, r3
 80a2056:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next green byte value
 80a205a:	f89e 3001 	ldrb.w	r3, [lr, #1]
 80a205e:	b2db      	uxtb	r3, r3
 80a2060:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next blue byte value
 80a2064:	f89e 3002 	ldrb.w	r3, [lr, #2]
 80a2068:	b2db      	uxtb	r3, r3
 80a206a:	f88d 3008 	strb.w	r3, [sp, #8]
      w = *ptr++;   // Next white byte value
 80a206e:	f89e 3003 	ldrb.w	r3, [lr, #3]
 80a2072:	b2db      	uxtb	r3, r3
 80a2074:	f88d 3009 	strb.w	r3, [sp, #9]
      c = ((uint32_t)r << 24) | ((uint32_t)g << 16) | ((uint32_t)b <<  8) | w; // Pack the next 4 bytes to keep timing tight
 80a2078:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a207c:	f89d 7006 	ldrb.w	r7, [sp, #6]
 80a2080:	f89d e008 	ldrb.w	lr, [sp, #8]
 80a2084:	043f      	lsls	r7, r7, #16
 80a2086:	f89d 0009 	ldrb.w	r0, [sp, #9]
 80a208a:	ea47 6303 	orr.w	r3, r7, r3, lsl #24
 80a208e:	4303      	orrs	r3, r0
 80a2090:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
 80a2094:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 32-bit counter
 80a2096:	f88d 6005 	strb.w	r6, [sp, #5]
 80a209a:	e07e      	b.n	80a219a <_ZN17Adafruit_NeoPixel4showEv+0xa22>
 80a209c:	e0001000 	.word	0xe0001000
 80a20a0:	20001330 	.word	0x20001330
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a20a4:	4600      	mov	r0, r0
 80a20a6:	bf00      	nop
 80a20a8:	bf00      	nop
 80a20aa:	bf00      	nop
 80a20ac:	bf00      	nop
 80a20ae:	bf00      	nop
 80a20b0:	bf00      	nop
 80a20b2:	bf00      	nop
 80a20b4:	bf00      	nop
 80a20b6:	bf00      	nop
 80a20b8:	bf00      	nop
 80a20ba:	bf00      	nop
 80a20bc:	bf00      	nop
 80a20be:	bf00      	nop
 80a20c0:	bf00      	nop
 80a20c2:	bf00      	nop
 80a20c4:	bf00      	nop
 80a20c6:	bf00      	nop
 80a20c8:	bf00      	nop
 80a20ca:	bf00      	nop
 80a20cc:	bf00      	nop
 80a20ce:	bf00      	nop
 80a20d0:	bf00      	nop
 80a20d2:	bf00      	nop
 80a20d4:	bf00      	nop
 80a20d6:	bf00      	nop
 80a20d8:	bf00      	nop
 80a20da:	bf00      	nop
 80a20dc:	bf00      	nop
 80a20de:	bf00      	nop
 80a20e0:	bf00      	nop
 80a20e2:	bf00      	nop
 80a20e4:	bf00      	nop
 80a20e6:	bf00      	nop
 80a20e8:	bf00      	nop
 80a20ea:	bf00      	nop
 80a20ec:	bf00      	nop
 80a20ee:	bf00      	nop
 80a20f0:	bf00      	nop
 80a20f2:	bf00      	nop
 80a20f4:	bf00      	nop
 80a20f6:	bf00      	nop
 80a20f8:	bf00      	nop
 80a20fa:	bf00      	nop
 80a20fc:	bf00      	nop
 80a20fe:	bf00      	nop
 80a2100:	bf00      	nop
 80a2102:	bf00      	nop
 80a2104:	bf00      	nop
 80a2106:	bf00      	nop
 80a2108:	bf00      	nop
 80a210a:	bf00      	nop
 80a210c:	bf00      	nop
 80a210e:	bf00      	nop
 80a2110:	bf00      	nop
          // SK6812RGBW spec         600ns LOW
          // WS2812 spec             600ns LOW
          // Adafruit on Arduino    (meas. 436ns)
          // This lib on Spark Core (meas. 598ns)
          // This lib on Photon     (meas. 600ns)
          pinSet(pin, LOW); // LOW
 80a2112:	79e3      	ldrb	r3, [r4, #7]
 80a2114:	6810      	ldr	r0, [r2, #0]
 80a2116:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a211a:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a211e:	88bf      	ldrh	r7, [r7, #4]
 80a2120:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a2124:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a2126:	4600      	mov	r0, r0
 80a2128:	bf00      	nop
 80a212a:	bf00      	nop
 80a212c:	bf00      	nop
 80a212e:	bf00      	nop
 80a2130:	bf00      	nop
 80a2132:	bf00      	nop
 80a2134:	bf00      	nop
 80a2136:	bf00      	nop
 80a2138:	bf00      	nop
 80a213a:	bf00      	nop
 80a213c:	bf00      	nop
 80a213e:	bf00      	nop
 80a2140:	bf00      	nop
 80a2142:	bf00      	nop
 80a2144:	bf00      	nop
 80a2146:	bf00      	nop
 80a2148:	bf00      	nop
 80a214a:	bf00      	nop
 80a214c:	bf00      	nop
 80a214e:	bf00      	nop
 80a2150:	bf00      	nop
 80a2152:	bf00      	nop
 80a2154:	bf00      	nop
 80a2156:	bf00      	nop
 80a2158:	bf00      	nop
 80a215a:	bf00      	nop
 80a215c:	bf00      	nop
 80a215e:	bf00      	nop
 80a2160:	bf00      	nop
 80a2162:	bf00      	nop
 80a2164:	bf00      	nop
 80a2166:	bf00      	nop
 80a2168:	bf00      	nop
 80a216a:	bf00      	nop
 80a216c:	bf00      	nop
 80a216e:	bf00      	nop
 80a2170:	bf00      	nop
 80a2172:	bf00      	nop
 80a2174:	bf00      	nop
 80a2176:	bf00      	nop
 80a2178:	bf00      	nop
 80a217a:	bf00      	nop
 80a217c:	bf00      	nop
 80a217e:	bf00      	nop
 80a2180:	bf00      	nop
 80a2182:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a2184:	9b04      	ldr	r3, [sp, #16]
 80a2186:	085b      	lsrs	r3, r3, #1
 80a2188:	9304      	str	r3, [sp, #16]
      } while ( ++j < 32 ); // ... pixel done
 80a218a:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a218e:	3301      	adds	r3, #1
 80a2190:	b2db      	uxtb	r3, r3
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
      w = *ptr++;   // Next white byte value
      c = ((uint32_t)r << 24) | ((uint32_t)g << 16) | ((uint32_t)b <<  8) | w; // Pack the next 4 bytes to keep timing tight
      j = 0;        // reset the 32-bit counter
      do {
 80a2192:	2b1f      	cmp	r3, #31
 80a2194:	f88d 3005 	strb.w	r3, [sp, #5]
 80a2198:	d87e      	bhi.n	80a2298 <_ZN17Adafruit_NeoPixel4showEv+0xb20>
        pinSet(pin, HIGH); // HIGH
 80a219a:	79e3      	ldrb	r3, [r4, #7]
 80a219c:	6810      	ldr	r0, [r2, #0]
 80a219e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a21a2:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a21a6:	88bf      	ldrh	r7, [r7, #4]
 80a21a8:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a21ac:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a21ae:	9803      	ldr	r0, [sp, #12]
 80a21b0:	9b04      	ldr	r3, [sp, #16]
 80a21b2:	4218      	tst	r0, r3
 80a21b4:	f47f af76 	bne.w	80a20a4 <_ZN17Adafruit_NeoPixel4showEv+0x92c>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a21b8:	4600      	mov	r0, r0
 80a21ba:	bf00      	nop
 80a21bc:	bf00      	nop
 80a21be:	bf00      	nop
 80a21c0:	bf00      	nop
 80a21c2:	bf00      	nop
 80a21c4:	bf00      	nop
 80a21c6:	bf00      	nop
 80a21c8:	bf00      	nop
 80a21ca:	bf00      	nop
 80a21cc:	bf00      	nop
 80a21ce:	bf00      	nop
 80a21d0:	bf00      	nop
 80a21d2:	bf00      	nop
 80a21d4:	bf00      	nop
 80a21d6:	bf00      	nop
 80a21d8:	bf00      	nop
 80a21da:	bf00      	nop
 80a21dc:	bf00      	nop
 80a21de:	bf00      	nop
          // SK6812RGBW spec         900ns LOW
          // WS2812 spec             800ns LOW
          // Adafruit on Arduino    (meas. 938ns)
          // This lib on Spark Core (meas. 904ns)
          // This lib on Photon     (meas. 900ns)
          pinSet(pin, LOW); // LOW
 80a21e0:	79e3      	ldrb	r3, [r4, #7]
 80a21e2:	6810      	ldr	r0, [r2, #0]
 80a21e4:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a21e8:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a21ec:	88bf      	ldrh	r7, [r7, #4]
 80a21ee:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a21f2:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a21f4:	4600      	mov	r0, r0
 80a21f6:	bf00      	nop
 80a21f8:	bf00      	nop
 80a21fa:	bf00      	nop
 80a21fc:	bf00      	nop
 80a21fe:	bf00      	nop
 80a2200:	bf00      	nop
 80a2202:	bf00      	nop
 80a2204:	bf00      	nop
 80a2206:	bf00      	nop
 80a2208:	bf00      	nop
 80a220a:	bf00      	nop
 80a220c:	bf00      	nop
 80a220e:	bf00      	nop
 80a2210:	bf00      	nop
 80a2212:	bf00      	nop
 80a2214:	bf00      	nop
 80a2216:	bf00      	nop
 80a2218:	bf00      	nop
 80a221a:	bf00      	nop
 80a221c:	bf00      	nop
 80a221e:	bf00      	nop
 80a2220:	bf00      	nop
 80a2222:	bf00      	nop
 80a2224:	bf00      	nop
 80a2226:	bf00      	nop
 80a2228:	bf00      	nop
 80a222a:	bf00      	nop
 80a222c:	bf00      	nop
 80a222e:	bf00      	nop
 80a2230:	bf00      	nop
 80a2232:	bf00      	nop
 80a2234:	bf00      	nop
 80a2236:	bf00      	nop
 80a2238:	bf00      	nop
 80a223a:	bf00      	nop
 80a223c:	bf00      	nop
 80a223e:	bf00      	nop
 80a2240:	bf00      	nop
 80a2242:	bf00      	nop
 80a2244:	bf00      	nop
 80a2246:	bf00      	nop
 80a2248:	bf00      	nop
 80a224a:	bf00      	nop
 80a224c:	bf00      	nop
 80a224e:	bf00      	nop
 80a2250:	bf00      	nop
 80a2252:	bf00      	nop
 80a2254:	bf00      	nop
 80a2256:	bf00      	nop
 80a2258:	bf00      	nop
 80a225a:	bf00      	nop
 80a225c:	bf00      	nop
 80a225e:	bf00      	nop
 80a2260:	bf00      	nop
 80a2262:	bf00      	nop
 80a2264:	bf00      	nop
 80a2266:	bf00      	nop
 80a2268:	bf00      	nop
 80a226a:	bf00      	nop
 80a226c:	bf00      	nop
 80a226e:	bf00      	nop
 80a2270:	bf00      	nop
 80a2272:	bf00      	nop
 80a2274:	bf00      	nop
 80a2276:	bf00      	nop
 80a2278:	bf00      	nop
 80a227a:	bf00      	nop
 80a227c:	bf00      	nop
 80a227e:	bf00      	nop
 80a2280:	bf00      	nop
 80a2282:	bf00      	nop
 80a2284:	bf00      	nop
 80a2286:	bf00      	nop
 80a2288:	bf00      	nop
 80a228a:	bf00      	nop
 80a228c:	bf00      	nop
 80a228e:	bf00      	nop
 80a2290:	bf00      	nop
 80a2292:	bf00      	nop
 80a2294:	bf00      	nop
 80a2296:	e775      	b.n	80a2184 <_ZN17Adafruit_NeoPixel4showEv+0xa0c>
      mask = 0x80000000; // reset the mask
      i = i-4;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
      w = *ptr++;   // Next white byte value
 80a2298:	468e      	mov	lr, r1
 80a229a:	e6ca      	b.n	80a2032 <_ZN17Adafruit_NeoPixel4showEv+0x8ba>
 80a229c:	4770      	bx	lr
        }
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == TM1803) { // TM1803 (Radio Shack Tri-Color Strip), 400 KHz bitstream
 80a229e:	2903      	cmp	r1, #3
 80a22a0:	f000 812e 	beq.w	80a2500 <_ZN17Adafruit_NeoPixel4showEv+0xd88>
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a22a4:	4a1e      	ldr	r2, [pc, #120]	; (80a2320 <_ZN17Adafruit_NeoPixel4showEv+0xba8>)
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else { // must be only other option TM1829, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
 80a22a6:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
 80a22aa:	2600      	movs	r6, #0
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else { // must be only other option TM1829, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a22ac:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a22b0:	b29b      	uxth	r3, r3
 80a22b2:	2b00      	cmp	r3, #0
 80a22b4:	f43f ae2e 	beq.w	80a1f14 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a22b8:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a22ba:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a22be:	79e0      	ldrb	r0, [r4, #7]
    } // end while(i) ... no more pixels
  }
  else { // must be only other option TM1829, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
 80a22c0:	3b03      	subs	r3, #3
 80a22c2:	b29b      	uxth	r3, r3
 80a22c4:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a22c8:	f89e 3000 	ldrb.w	r3, [lr]
 80a22cc:	f10e 0103 	add.w	r1, lr, #3
 80a22d0:	b2db      	uxtb	r3, r3
 80a22d2:	f88d 3007 	strb.w	r3, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a22d6:	f89e 3001 	ldrb.w	r3, [lr, #1]
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a22da:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
  else { // must be only other option TM1829, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
 80a22de:	b2db      	uxtb	r3, r3
 80a22e0:	f88d 3008 	strb.w	r3, [sp, #8]
      g = *ptr++;   // Next green byte value
 80a22e4:	f89e 3002 	ldrb.w	r3, [lr, #2]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a22e8:	f8d2 e000 	ldr.w	lr, [r2]
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
 80a22ec:	b2db      	uxtb	r3, r3
 80a22ee:	f88d 3006 	strb.w	r3, [sp, #6]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a22f2:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a22f6:	f89d 3008 	ldrb.w	r3, [sp, #8]
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a22fa:	eb0e 0c80 	add.w	ip, lr, r0, lsl #2
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a22fe:	021b      	lsls	r3, r3, #8
 80a2300:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a2304:	f89d 7006 	ldrb.w	r7, [sp, #6]
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a2308:	f8bc c004 	ldrh.w	ip, [ip, #4]
 80a230c:	f85e 0020 	ldr.w	r0, [lr, r0, lsl #2]
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a2310:	433b      	orrs	r3, r7
 80a2312:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a2314:	f88d 6005 	strb.w	r6, [sp, #5]
      pinSet(pin, LOW); // LOW
 80a2318:	f8a0 c01a 	strh.w	ip, [r0, #26]
 80a231c:	e07d      	b.n	80a241a <_ZN17Adafruit_NeoPixel4showEv+0xca2>
 80a231e:	bf00      	nop
 80a2320:	20001330 	.word	0x20001330
      for( ;; ) {   // ... pixel done
        if (c & mask) { // if masked bit is high
          // TM1829 spec             800ns LOW
          // This lib on Spark Core (meas. 806ns)
          // This lib on Photon     (meas. 792ns)
          mask >>= 1; // Do this task during the long delay of this bit
 80a2324:	9b04      	ldr	r3, [sp, #16]
 80a2326:	085b      	lsrs	r3, r3, #1
 80a2328:	9304      	str	r3, [sp, #16]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a232a:	4600      	mov	r0, r0
 80a232c:	bf00      	nop
 80a232e:	bf00      	nop
 80a2330:	bf00      	nop
 80a2332:	bf00      	nop
 80a2334:	bf00      	nop
 80a2336:	bf00      	nop
 80a2338:	bf00      	nop
 80a233a:	bf00      	nop
 80a233c:	bf00      	nop
 80a233e:	bf00      	nop
 80a2340:	bf00      	nop
 80a2342:	bf00      	nop
 80a2344:	bf00      	nop
 80a2346:	bf00      	nop
 80a2348:	bf00      	nop
 80a234a:	bf00      	nop
 80a234c:	bf00      	nop
 80a234e:	bf00      	nop
 80a2350:	bf00      	nop
 80a2352:	bf00      	nop
 80a2354:	bf00      	nop
 80a2356:	bf00      	nop
 80a2358:	bf00      	nop
 80a235a:	bf00      	nop
 80a235c:	bf00      	nop
 80a235e:	bf00      	nop
 80a2360:	bf00      	nop
 80a2362:	bf00      	nop
 80a2364:	bf00      	nop
 80a2366:	bf00      	nop
 80a2368:	bf00      	nop
 80a236a:	bf00      	nop
 80a236c:	bf00      	nop
 80a236e:	bf00      	nop
 80a2370:	bf00      	nop
 80a2372:	bf00      	nop
 80a2374:	bf00      	nop
 80a2376:	bf00      	nop
 80a2378:	bf00      	nop
 80a237a:	bf00      	nop
 80a237c:	bf00      	nop
 80a237e:	bf00      	nop
 80a2380:	bf00      	nop
 80a2382:	bf00      	nop
 80a2384:	bf00      	nop
 80a2386:	bf00      	nop
 80a2388:	bf00      	nop
 80a238a:	bf00      	nop
 80a238c:	bf00      	nop
 80a238e:	bf00      	nop
 80a2390:	bf00      	nop
 80a2392:	bf00      	nop
 80a2394:	bf00      	nop
 80a2396:	bf00      	nop
 80a2398:	bf00      	nop
 80a239a:	bf00      	nop
 80a239c:	bf00      	nop
 80a239e:	bf00      	nop
 80a23a0:	bf00      	nop
 80a23a2:	bf00      	nop
 80a23a4:	bf00      	nop
 80a23a6:	bf00      	nop
 80a23a8:	bf00      	nop
 80a23aa:	bf00      	nop
 80a23ac:	bf00      	nop
 80a23ae:	bf00      	nop
          j++;
          // TM1829 spec             300ns HIGH
          // This lib on Spark Core (meas. 305ns)
          // This lib on Photon     (meas. 300ns)
          pinSet(pin, HIGH); // HIGH
 80a23b0:	79e0      	ldrb	r0, [r4, #7]
 80a23b2:	6817      	ldr	r7, [r2, #0]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
          j++;
 80a23b4:	f89d 3005 	ldrb.w	r3, [sp, #5]
          // TM1829 spec             300ns HIGH
          // This lib on Spark Core (meas. 305ns)
          // This lib on Photon     (meas. 300ns)
          pinSet(pin, HIGH); // HIGH
 80a23b8:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 80a23bc:	eb07 0e80 	add.w	lr, r7, r0, lsl #2
 80a23c0:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a23c4:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
          j++;
 80a23c8:	3301      	adds	r3, #1
 80a23ca:	b2db      	uxtb	r3, r3
 80a23cc:	f88d 3005 	strb.w	r3, [sp, #5]
          // TM1829 spec             300ns HIGH
          // This lib on Spark Core (meas. 305ns)
          // This lib on Photon     (meas. 300ns)
          pinSet(pin, HIGH); // HIGH
 80a23d0:	f8a0 e018 	strh.w	lr, [r0, #24]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a23d4:	4600      	mov	r0, r0
 80a23d6:	bf00      	nop
 80a23d8:	bf00      	nop
 80a23da:	bf00      	nop
 80a23dc:	bf00      	nop
 80a23de:	bf00      	nop
 80a23e0:	bf00      	nop
 80a23e2:	bf00      	nop
 80a23e4:	bf00      	nop
 80a23e6:	bf00      	nop
 80a23e8:	bf00      	nop
 80a23ea:	bf00      	nop
 80a23ec:	bf00      	nop
 80a23ee:	bf00      	nop
 80a23f0:	bf00      	nop
 80a23f2:	bf00      	nop
 80a23f4:	bf00      	nop
 80a23f6:	bf00      	nop
 80a23f8:	bf00      	nop
 80a23fa:	bf00      	nop
 80a23fc:	bf00      	nop
          if(j==24) break;
 80a23fe:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a2402:	2b18      	cmp	r3, #24
 80a2404:	d07a      	beq.n	80a24fc <_ZN17Adafruit_NeoPixel4showEv+0xd84>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
          if(j==24) break;
          pinSet(pin, LOW); // LOW
 80a2406:	79e3      	ldrb	r3, [r4, #7]
 80a2408:	6810      	ldr	r0, [r2, #0]
 80a240a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a240e:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a2412:	88bf      	ldrh	r7, [r7, #4]
 80a2414:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a2418:	835f      	strh	r7, [r3, #26]
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
      for( ;; ) {   // ... pixel done
        if (c & mask) { // if masked bit is high
 80a241a:	9803      	ldr	r0, [sp, #12]
 80a241c:	9b04      	ldr	r3, [sp, #16]
 80a241e:	4218      	tst	r0, r3
 80a2420:	d180      	bne.n	80a2324 <_ZN17Adafruit_NeoPixel4showEv+0xbac>
            "mov r0, r0" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
            ::: "r0", "cc", "memory");
 80a2422:	4600      	mov	r0, r0
 80a2424:	bf00      	nop
 80a2426:	bf00      	nop
 80a2428:	bf00      	nop
 80a242a:	bf00      	nop
 80a242c:	bf00      	nop
 80a242e:	bf00      	nop
 80a2430:	bf00      	nop
 80a2432:	bf00      	nop
 80a2434:	bf00      	nop
 80a2436:	bf00      	nop
 80a2438:	bf00      	nop
 80a243a:	bf00      	nop
 80a243c:	bf00      	nop
 80a243e:	bf00      	nop
 80a2440:	bf00      	nop
 80a2442:	bf00      	nop
#endif
          // TM1829 spec             800ns HIGH
          // This lib on Spark Core (meas. 792ns)
          // This lib on Photon     (meas. 800ns)
          pinSet(pin, HIGH); // HIGH
 80a2444:	79e3      	ldrb	r3, [r4, #7]
 80a2446:	6810      	ldr	r0, [r2, #0]
 80a2448:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a244c:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a2450:	88bf      	ldrh	r7, [r7, #4]
 80a2452:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a2456:	831f      	strh	r7, [r3, #24]
          j++;
 80a2458:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a245c:	3301      	adds	r3, #1
 80a245e:	b2db      	uxtb	r3, r3
 80a2460:	f88d 3005 	strb.w	r3, [sp, #5]
          mask >>= 1; // Do this task during the long delay of this bit
 80a2464:	9b04      	ldr	r3, [sp, #16]
 80a2466:	085b      	lsrs	r3, r3, #1
 80a2468:	9304      	str	r3, [sp, #16]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a246a:	4600      	mov	r0, r0
 80a246c:	bf00      	nop
 80a246e:	bf00      	nop
 80a2470:	bf00      	nop
 80a2472:	bf00      	nop
 80a2474:	bf00      	nop
 80a2476:	bf00      	nop
 80a2478:	bf00      	nop
 80a247a:	bf00      	nop
 80a247c:	bf00      	nop
 80a247e:	bf00      	nop
 80a2480:	bf00      	nop
 80a2482:	bf00      	nop
 80a2484:	bf00      	nop
 80a2486:	bf00      	nop
 80a2488:	bf00      	nop
 80a248a:	bf00      	nop
 80a248c:	bf00      	nop
 80a248e:	bf00      	nop
 80a2490:	bf00      	nop
 80a2492:	bf00      	nop
 80a2494:	bf00      	nop
 80a2496:	bf00      	nop
 80a2498:	bf00      	nop
 80a249a:	bf00      	nop
 80a249c:	bf00      	nop
 80a249e:	bf00      	nop
 80a24a0:	bf00      	nop
 80a24a2:	bf00      	nop
 80a24a4:	bf00      	nop
 80a24a6:	bf00      	nop
 80a24a8:	bf00      	nop
 80a24aa:	bf00      	nop
 80a24ac:	bf00      	nop
 80a24ae:	bf00      	nop
 80a24b0:	bf00      	nop
 80a24b2:	bf00      	nop
 80a24b4:	bf00      	nop
 80a24b6:	bf00      	nop
 80a24b8:	bf00      	nop
 80a24ba:	bf00      	nop
 80a24bc:	bf00      	nop
 80a24be:	bf00      	nop
 80a24c0:	bf00      	nop
 80a24c2:	bf00      	nop
 80a24c4:	bf00      	nop
 80a24c6:	bf00      	nop
 80a24c8:	bf00      	nop
 80a24ca:	bf00      	nop
 80a24cc:	bf00      	nop
 80a24ce:	bf00      	nop
 80a24d0:	bf00      	nop
 80a24d2:	bf00      	nop
 80a24d4:	bf00      	nop
 80a24d6:	bf00      	nop
 80a24d8:	bf00      	nop
 80a24da:	bf00      	nop
 80a24dc:	bf00      	nop
 80a24de:	bf00      	nop
 80a24e0:	bf00      	nop
 80a24e2:	bf00      	nop
 80a24e4:	bf00      	nop
 80a24e6:	bf00      	nop
 80a24e8:	bf00      	nop
 80a24ea:	bf00      	nop
 80a24ec:	bf00      	nop
 80a24ee:	bf00      	nop
 80a24f0:	bf00      	nop
 80a24f2:	bf00      	nop
          if(j==24) break;
 80a24f4:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a24f8:	2b18      	cmp	r3, #24
 80a24fa:	d184      	bne.n	80a2406 <_ZN17Adafruit_NeoPixel4showEv+0xc8e>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next blue byte value
      b = *ptr++;   // Next green byte value
 80a24fc:	468e      	mov	lr, r1
 80a24fe:	e6d5      	b.n	80a22ac <_ZN17Adafruit_NeoPixel4showEv+0xb34>
 80a2500:	4a17      	ldr	r2, [pc, #92]	; (80a2560 <_ZN17Adafruit_NeoPixel4showEv+0xde8>)
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == TM1803) { // TM1803 (Radio Shack Tri-Color Strip), 400 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
 80a2502:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next blue byte value
      b = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
 80a2506:	2600      	movs	r6, #0
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == TM1803) { // TM1803 (Radio Shack Tri-Color Strip), 400 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a2508:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a250c:	b29b      	uxth	r3, r3
 80a250e:	2b00      	cmp	r3, #0
 80a2510:	f43f ad00 	beq.w	80a1f14 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a2514:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a2516:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a251a:	f10e 0103 	add.w	r1, lr, #3
 80a251e:	3b03      	subs	r3, #3
 80a2520:	b29b      	uxth	r3, r3
 80a2522:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a2526:	f89e 3000 	ldrb.w	r3, [lr]
 80a252a:	b2db      	uxtb	r3, r3
 80a252c:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next blue byte value
 80a2530:	f89e 3001 	ldrb.w	r3, [lr, #1]
 80a2534:	b2db      	uxtb	r3, r3
 80a2536:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next green byte value
 80a253a:	f89e 3002 	ldrb.w	r3, [lr, #2]
 80a253e:	b2db      	uxtb	r3, r3
 80a2540:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a2544:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a2548:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a254c:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a2550:	021b      	lsls	r3, r3, #8
 80a2552:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a2556:	4303      	orrs	r3, r0
 80a2558:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a255a:	f88d 6005 	strb.w	r6, [sp, #5]
 80a255e:	e0e0      	b.n	80a2722 <_ZN17Adafruit_NeoPixel4showEv+0xfaa>
 80a2560:	20001330 	.word	0x20001330
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a2564:	4600      	mov	r0, r0
 80a2566:	bf00      	nop
 80a2568:	bf00      	nop
 80a256a:	bf00      	nop
 80a256c:	bf00      	nop
 80a256e:	bf00      	nop
 80a2570:	bf00      	nop
 80a2572:	bf00      	nop
 80a2574:	bf00      	nop
 80a2576:	bf00      	nop
 80a2578:	bf00      	nop
 80a257a:	bf00      	nop
 80a257c:	bf00      	nop
 80a257e:	bf00      	nop
 80a2580:	bf00      	nop
 80a2582:	bf00      	nop
 80a2584:	bf00      	nop
 80a2586:	bf00      	nop
 80a2588:	bf00      	nop
 80a258a:	bf00      	nop
 80a258c:	bf00      	nop
 80a258e:	bf00      	nop
 80a2590:	bf00      	nop
 80a2592:	bf00      	nop
 80a2594:	bf00      	nop
 80a2596:	bf00      	nop
 80a2598:	bf00      	nop
 80a259a:	bf00      	nop
 80a259c:	bf00      	nop
 80a259e:	bf00      	nop
 80a25a0:	bf00      	nop
 80a25a2:	bf00      	nop
 80a25a4:	bf00      	nop
 80a25a6:	bf00      	nop
 80a25a8:	bf00      	nop
 80a25aa:	bf00      	nop
 80a25ac:	bf00      	nop
 80a25ae:	bf00      	nop
 80a25b0:	bf00      	nop
 80a25b2:	bf00      	nop
 80a25b4:	bf00      	nop
 80a25b6:	bf00      	nop
 80a25b8:	bf00      	nop
 80a25ba:	bf00      	nop
 80a25bc:	bf00      	nop
 80a25be:	bf00      	nop
 80a25c0:	bf00      	nop
 80a25c2:	bf00      	nop
 80a25c4:	bf00      	nop
 80a25c6:	bf00      	nop
 80a25c8:	bf00      	nop
 80a25ca:	bf00      	nop
 80a25cc:	bf00      	nop
 80a25ce:	bf00      	nop
 80a25d0:	bf00      	nop
 80a25d2:	bf00      	nop
 80a25d4:	bf00      	nop
 80a25d6:	bf00      	nop
 80a25d8:	bf00      	nop
 80a25da:	bf00      	nop
 80a25dc:	bf00      	nop
 80a25de:	bf00      	nop
 80a25e0:	bf00      	nop
 80a25e2:	bf00      	nop
 80a25e4:	bf00      	nop
 80a25e6:	bf00      	nop
 80a25e8:	bf00      	nop
 80a25ea:	bf00      	nop
 80a25ec:	bf00      	nop
 80a25ee:	bf00      	nop
 80a25f0:	bf00      	nop
 80a25f2:	bf00      	nop
 80a25f4:	bf00      	nop
 80a25f6:	bf00      	nop
 80a25f8:	bf00      	nop
 80a25fa:	bf00      	nop
 80a25fc:	bf00      	nop
 80a25fe:	bf00      	nop
 80a2600:	bf00      	nop
 80a2602:	bf00      	nop
 80a2604:	bf00      	nop
 80a2606:	bf00      	nop
 80a2608:	bf00      	nop
 80a260a:	bf00      	nop
 80a260c:	bf00      	nop
 80a260e:	bf00      	nop
 80a2610:	bf00      	nop
 80a2612:	bf00      	nop
 80a2614:	bf00      	nop
 80a2616:	bf00      	nop
 80a2618:	bf00      	nop
 80a261a:	bf00      	nop
 80a261c:	bf00      	nop
 80a261e:	bf00      	nop
 80a2620:	bf00      	nop
 80a2622:	bf00      	nop
 80a2624:	bf00      	nop
 80a2626:	bf00      	nop
 80a2628:	bf00      	nop
 80a262a:	bf00      	nop
 80a262c:	bf00      	nop
 80a262e:	bf00      	nop
 80a2630:	bf00      	nop
 80a2632:	bf00      	nop
 80a2634:	bf00      	nop
 80a2636:	bf00      	nop
 80a2638:	bf00      	nop
 80a263a:	bf00      	nop
 80a263c:	bf00      	nop
 80a263e:	bf00      	nop
 80a2640:	bf00      	nop
 80a2642:	bf00      	nop
 80a2644:	bf00      	nop
 80a2646:	bf00      	nop
 80a2648:	bf00      	nop
 80a264a:	bf00      	nop
 80a264c:	bf00      	nop
 80a264e:	bf00      	nop
 80a2650:	bf00      	nop
 80a2652:	bf00      	nop
 80a2654:	bf00      	nop
 80a2656:	bf00      	nop
 80a2658:	bf00      	nop
 80a265a:	bf00      	nop
 80a265c:	bf00      	nop
 80a265e:	bf00      	nop
 80a2660:	bf00      	nop
 80a2662:	bf00      	nop
 80a2664:	bf00      	nop
 80a2666:	bf00      	nop
 80a2668:	bf00      	nop
 80a266a:	bf00      	nop
 80a266c:	bf00      	nop
 80a266e:	bf00      	nop
 80a2670:	bf00      	nop
 80a2672:	bf00      	nop
 80a2674:	bf00      	nop
 80a2676:	bf00      	nop
 80a2678:	bf00      	nop
 80a267a:	bf00      	nop
 80a267c:	bf00      	nop
 80a267e:	bf00      	nop
 80a2680:	bf00      	nop
 80a2682:	bf00      	nop
 80a2684:	bf00      	nop
          // TM1803 spec             680ns LOW
          // Pololu on Arduino      (meas. 1.024us)
          // This lib on Spark Core (meas. 680ns)
          // This lib on Photon     (meas. 684ns)
          pinSet(pin, LOW); // LOW
 80a2686:	79e3      	ldrb	r3, [r4, #7]
 80a2688:	6810      	ldr	r0, [r2, #0]
 80a268a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a268e:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a2692:	88bf      	ldrh	r7, [r7, #4]
 80a2694:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a2698:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a269a:	4600      	mov	r0, r0
 80a269c:	bf00      	nop
 80a269e:	bf00      	nop
 80a26a0:	bf00      	nop
 80a26a2:	bf00      	nop
 80a26a4:	bf00      	nop
 80a26a6:	bf00      	nop
 80a26a8:	bf00      	nop
 80a26aa:	bf00      	nop
 80a26ac:	bf00      	nop
 80a26ae:	bf00      	nop
 80a26b0:	bf00      	nop
 80a26b2:	bf00      	nop
 80a26b4:	bf00      	nop
 80a26b6:	bf00      	nop
 80a26b8:	bf00      	nop
 80a26ba:	bf00      	nop
 80a26bc:	bf00      	nop
 80a26be:	bf00      	nop
 80a26c0:	bf00      	nop
 80a26c2:	bf00      	nop
 80a26c4:	bf00      	nop
 80a26c6:	bf00      	nop
 80a26c8:	bf00      	nop
 80a26ca:	bf00      	nop
 80a26cc:	bf00      	nop
 80a26ce:	bf00      	nop
 80a26d0:	bf00      	nop
 80a26d2:	bf00      	nop
 80a26d4:	bf00      	nop
 80a26d6:	bf00      	nop
 80a26d8:	bf00      	nop
 80a26da:	bf00      	nop
 80a26dc:	bf00      	nop
 80a26de:	bf00      	nop
 80a26e0:	bf00      	nop
 80a26e2:	bf00      	nop
 80a26e4:	bf00      	nop
 80a26e6:	bf00      	nop
 80a26e8:	bf00      	nop
 80a26ea:	bf00      	nop
 80a26ec:	bf00      	nop
 80a26ee:	bf00      	nop
 80a26f0:	bf00      	nop
 80a26f2:	bf00      	nop
 80a26f4:	bf00      	nop
 80a26f6:	bf00      	nop
 80a26f8:	bf00      	nop
 80a26fa:	bf00      	nop
 80a26fc:	bf00      	nop
 80a26fe:	bf00      	nop
 80a2700:	bf00      	nop
 80a2702:	bf00      	nop
 80a2704:	bf00      	nop
 80a2706:	bf00      	nop
 80a2708:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a270a:	9b04      	ldr	r3, [sp, #16]
 80a270c:	085b      	lsrs	r3, r3, #1
 80a270e:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a2710:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a2714:	3301      	adds	r3, #1
 80a2716:	b2db      	uxtb	r3, r3
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next blue byte value
      b = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
 80a2718:	2b17      	cmp	r3, #23
 80a271a:	f88d 3005 	strb.w	r3, [sp, #5]
 80a271e:	f200 80e3 	bhi.w	80a28e8 <_ZN17Adafruit_NeoPixel4showEv+0x1170>
        pinSet(pin, HIGH); // HIGH
 80a2722:	79e3      	ldrb	r3, [r4, #7]
 80a2724:	6810      	ldr	r0, [r2, #0]
 80a2726:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a272a:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a272e:	88bf      	ldrh	r7, [r7, #4]
 80a2730:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a2734:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a2736:	9803      	ldr	r0, [sp, #12]
 80a2738:	9b04      	ldr	r3, [sp, #16]
 80a273a:	4218      	tst	r0, r3
 80a273c:	f47f af12 	bne.w	80a2564 <_ZN17Adafruit_NeoPixel4showEv+0xdec>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a2740:	4600      	mov	r0, r0
 80a2742:	bf00      	nop
 80a2744:	bf00      	nop
 80a2746:	bf00      	nop
 80a2748:	bf00      	nop
 80a274a:	bf00      	nop
 80a274c:	bf00      	nop
 80a274e:	bf00      	nop
 80a2750:	bf00      	nop
 80a2752:	bf00      	nop
 80a2754:	bf00      	nop
 80a2756:	bf00      	nop
 80a2758:	bf00      	nop
 80a275a:	bf00      	nop
 80a275c:	bf00      	nop
 80a275e:	bf00      	nop
 80a2760:	bf00      	nop
 80a2762:	bf00      	nop
 80a2764:	bf00      	nop
 80a2766:	bf00      	nop
 80a2768:	bf00      	nop
 80a276a:	bf00      	nop
 80a276c:	bf00      	nop
 80a276e:	bf00      	nop
 80a2770:	bf00      	nop
 80a2772:	bf00      	nop
 80a2774:	bf00      	nop
 80a2776:	bf00      	nop
 80a2778:	bf00      	nop
 80a277a:	bf00      	nop
 80a277c:	bf00      	nop
 80a277e:	bf00      	nop
 80a2780:	bf00      	nop
 80a2782:	bf00      	nop
 80a2784:	bf00      	nop
 80a2786:	bf00      	nop
 80a2788:	bf00      	nop
 80a278a:	bf00      	nop
 80a278c:	bf00      	nop
 80a278e:	bf00      	nop
 80a2790:	bf00      	nop
 80a2792:	bf00      	nop
 80a2794:	bf00      	nop
 80a2796:	bf00      	nop
 80a2798:	bf00      	nop
 80a279a:	bf00      	nop
 80a279c:	bf00      	nop
 80a279e:	bf00      	nop
 80a27a0:	bf00      	nop
 80a27a2:	bf00      	nop
 80a27a4:	bf00      	nop
 80a27a6:	bf00      	nop
 80a27a8:	bf00      	nop
 80a27aa:	bf00      	nop
 80a27ac:	bf00      	nop
 80a27ae:	bf00      	nop
 80a27b0:	bf00      	nop
 80a27b2:	bf00      	nop
 80a27b4:	bf00      	nop
 80a27b6:	bf00      	nop
 80a27b8:	bf00      	nop
 80a27ba:	bf00      	nop
 80a27bc:	bf00      	nop
 80a27be:	bf00      	nop
 80a27c0:	bf00      	nop
          // TM1803 spec             1.36us LOW
          // Pololu on Arduino      (meas. 2.00us)
          // This lib on Spark Core (meas. 1.36us)
          // This lib on Photon     (meas. 1.36us)
          pinSet(pin, LOW); // LOW
 80a27c2:	79e3      	ldrb	r3, [r4, #7]
 80a27c4:	6810      	ldr	r0, [r2, #0]
 80a27c6:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a27ca:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a27ce:	88bf      	ldrh	r7, [r7, #4]
 80a27d0:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a27d4:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a27d6:	4600      	mov	r0, r0
 80a27d8:	bf00      	nop
 80a27da:	bf00      	nop
 80a27dc:	bf00      	nop
 80a27de:	bf00      	nop
 80a27e0:	bf00      	nop
 80a27e2:	bf00      	nop
 80a27e4:	bf00      	nop
 80a27e6:	bf00      	nop
 80a27e8:	bf00      	nop
 80a27ea:	bf00      	nop
 80a27ec:	bf00      	nop
 80a27ee:	bf00      	nop
 80a27f0:	bf00      	nop
 80a27f2:	bf00      	nop
 80a27f4:	bf00      	nop
 80a27f6:	bf00      	nop
 80a27f8:	bf00      	nop
 80a27fa:	bf00      	nop
 80a27fc:	bf00      	nop
 80a27fe:	bf00      	nop
 80a2800:	bf00      	nop
 80a2802:	bf00      	nop
 80a2804:	bf00      	nop
 80a2806:	bf00      	nop
 80a2808:	bf00      	nop
 80a280a:	bf00      	nop
 80a280c:	bf00      	nop
 80a280e:	bf00      	nop
 80a2810:	bf00      	nop
 80a2812:	bf00      	nop
 80a2814:	bf00      	nop
 80a2816:	bf00      	nop
 80a2818:	bf00      	nop
 80a281a:	bf00      	nop
 80a281c:	bf00      	nop
 80a281e:	bf00      	nop
 80a2820:	bf00      	nop
 80a2822:	bf00      	nop
 80a2824:	bf00      	nop
 80a2826:	bf00      	nop
 80a2828:	bf00      	nop
 80a282a:	bf00      	nop
 80a282c:	bf00      	nop
 80a282e:	bf00      	nop
 80a2830:	bf00      	nop
 80a2832:	bf00      	nop
 80a2834:	bf00      	nop
 80a2836:	bf00      	nop
 80a2838:	bf00      	nop
 80a283a:	bf00      	nop
 80a283c:	bf00      	nop
 80a283e:	bf00      	nop
 80a2840:	bf00      	nop
 80a2842:	bf00      	nop
 80a2844:	bf00      	nop
 80a2846:	bf00      	nop
 80a2848:	bf00      	nop
 80a284a:	bf00      	nop
 80a284c:	bf00      	nop
 80a284e:	bf00      	nop
 80a2850:	bf00      	nop
 80a2852:	bf00      	nop
 80a2854:	bf00      	nop
 80a2856:	bf00      	nop
 80a2858:	bf00      	nop
 80a285a:	bf00      	nop
 80a285c:	bf00      	nop
 80a285e:	bf00      	nop
 80a2860:	bf00      	nop
 80a2862:	bf00      	nop
 80a2864:	bf00      	nop
 80a2866:	bf00      	nop
 80a2868:	bf00      	nop
 80a286a:	bf00      	nop
 80a286c:	bf00      	nop
 80a286e:	bf00      	nop
 80a2870:	bf00      	nop
 80a2872:	bf00      	nop
 80a2874:	bf00      	nop
 80a2876:	bf00      	nop
 80a2878:	bf00      	nop
 80a287a:	bf00      	nop
 80a287c:	bf00      	nop
 80a287e:	bf00      	nop
 80a2880:	bf00      	nop
 80a2882:	bf00      	nop
 80a2884:	bf00      	nop
 80a2886:	bf00      	nop
 80a2888:	bf00      	nop
 80a288a:	bf00      	nop
 80a288c:	bf00      	nop
 80a288e:	bf00      	nop
 80a2890:	bf00      	nop
 80a2892:	bf00      	nop
 80a2894:	bf00      	nop
 80a2896:	bf00      	nop
 80a2898:	bf00      	nop
 80a289a:	bf00      	nop
 80a289c:	bf00      	nop
 80a289e:	bf00      	nop
 80a28a0:	bf00      	nop
 80a28a2:	bf00      	nop
 80a28a4:	bf00      	nop
 80a28a6:	bf00      	nop
 80a28a8:	bf00      	nop
 80a28aa:	bf00      	nop
 80a28ac:	bf00      	nop
 80a28ae:	bf00      	nop
 80a28b0:	bf00      	nop
 80a28b2:	bf00      	nop
 80a28b4:	bf00      	nop
 80a28b6:	bf00      	nop
 80a28b8:	bf00      	nop
 80a28ba:	bf00      	nop
 80a28bc:	bf00      	nop
 80a28be:	bf00      	nop
 80a28c0:	bf00      	nop
 80a28c2:	bf00      	nop
 80a28c4:	bf00      	nop
 80a28c6:	bf00      	nop
 80a28c8:	bf00      	nop
 80a28ca:	bf00      	nop
 80a28cc:	bf00      	nop
 80a28ce:	bf00      	nop
 80a28d0:	bf00      	nop
 80a28d2:	bf00      	nop
 80a28d4:	bf00      	nop
 80a28d6:	bf00      	nop
 80a28d8:	bf00      	nop
 80a28da:	bf00      	nop
 80a28dc:	bf00      	nop
 80a28de:	bf00      	nop
 80a28e0:	bf00      	nop
 80a28e2:	bf00      	nop
 80a28e4:	bf00      	nop
 80a28e6:	e710      	b.n	80a270a <_ZN17Adafruit_NeoPixel4showEv+0xf92>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next blue byte value
      b = *ptr++;   // Next green byte value
 80a28e8:	468e      	mov	lr, r1
 80a28ea:	e60d      	b.n	80a2508 <_ZN17Adafruit_NeoPixel4showEv+0xd90>

080a28ec <_ZN17Adafruit_NeoPixel13setPixelColorEtm>:
}

// Set pixel color from 'packed' 32-bit RGB color:
// If RGB+W color, order of bytes is WRGB in packed 32-bit form
void Adafruit_NeoPixel::setPixelColor(uint16_t n, uint32_t c) {
  if(n < numLEDs) {
 80a28ec:	8843      	ldrh	r3, [r0, #2]
  }
}

// Set pixel color from 'packed' 32-bit RGB color:
// If RGB+W color, order of bytes is WRGB in packed 32-bit form
void Adafruit_NeoPixel::setPixelColor(uint16_t n, uint32_t c) {
 80a28ee:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(n < numLEDs) {
 80a28f0:	428b      	cmp	r3, r1
 80a28f2:	d945      	bls.n	80a2980 <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x94>
    uint8_t
      r = (uint8_t)(c >> 16),
      g = (uint8_t)(c >>  8),
      b = (uint8_t)c;
    if(brightness) { // See notes in setBrightness()
 80a28f4:	7a05      	ldrb	r5, [r0, #8]
 80a28f6:	f3c2 4307 	ubfx	r3, r2, #16, #8
 80a28fa:	f3c2 2407 	ubfx	r4, r2, #8, #8
 80a28fe:	b2d6      	uxtb	r6, r2
 80a2900:	b145      	cbz	r5, 80a2914 <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x28>
      r = (r * brightness) >> 8;
 80a2902:	436b      	muls	r3, r5
      g = (g * brightness) >> 8;
 80a2904:	436c      	muls	r4, r5
      b = (b * brightness) >> 8;
 80a2906:	436e      	muls	r6, r5
    uint8_t
      r = (uint8_t)(c >> 16),
      g = (uint8_t)(c >>  8),
      b = (uint8_t)c;
    if(brightness) { // See notes in setBrightness()
      r = (r * brightness) >> 8;
 80a2908:	f3c3 2307 	ubfx	r3, r3, #8, #8
      g = (g * brightness) >> 8;
 80a290c:	f3c4 2407 	ubfx	r4, r4, #8, #8
      b = (b * brightness) >> 8;
 80a2910:	f3c6 2607 	ubfx	r6, r6, #8, #8
    }
    uint8_t *p = &pixels[n * (type==SK6812RGBW?4:3)];
 80a2914:	f890 c006 	ldrb.w	ip, [r0, #6]
 80a2918:	68c7      	ldr	r7, [r0, #12]
 80a291a:	f1bc 0f06 	cmp.w	ip, #6
 80a291e:	bf0c      	ite	eq
 80a2920:	2504      	moveq	r5, #4
 80a2922:	2503      	movne	r5, #3
 80a2924:	4369      	muls	r1, r5
 80a2926:	f1bc 0f08 	cmp.w	ip, #8
 80a292a:	eb07 0501 	add.w	r5, r7, r1
 80a292e:	d824      	bhi.n	80a297a <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x8e>
 80a2930:	f04f 0e01 	mov.w	lr, #1
 80a2934:	fa0e fe0c 	lsl.w	lr, lr, ip
 80a2938:	f41e 7fd2 	tst.w	lr, #420	; 0x1a4
 80a293c:	d10c      	bne.n	80a2958 <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x6c>
 80a293e:	f01e 0f40 	tst.w	lr, #64	; 0x40
 80a2942:	d10d      	bne.n	80a2960 <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x74>
 80a2944:	f01e 0f10 	tst.w	lr, #16
 80a2948:	d017      	beq.n	80a297a <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x8e>
          *p++ = g;
          *p++ = r;
          *p = b;
        } break;
      case TM1829: { // TM1829 is special RBG order
          if(r == 255) r = 254; // 255 on RED channel causes display to be in a special mode.
 80a294a:	2bff      	cmp	r3, #255	; 0xff
 80a294c:	bf08      	it	eq
 80a294e:	23fe      	moveq	r3, #254	; 0xfe
          *p++ = r;
 80a2950:	547b      	strb	r3, [r7, r1]
          *p++ = b;
 80a2952:	706e      	strb	r6, [r5, #1]
          *p = g;
 80a2954:	70ac      	strb	r4, [r5, #2]
        } break;
 80a2956:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch(type) {
      case WS2812B: // WS2812, WS2812B & WS2813 is GRB order.
      case WS2812B_FAST:
      case WS2812B2:
      case WS2812B2_FAST: {
          *p++ = g;
 80a2958:	547c      	strb	r4, [r7, r1]
          *p++ = r;
 80a295a:	706b      	strb	r3, [r5, #1]
          *p = b;
 80a295c:	70ae      	strb	r6, [r5, #2]
        } break;
 80a295e:	bdf0      	pop	{r4, r5, r6, r7, pc}
          *p++ = b;
          *p = g;
        } break;
      case SK6812RGBW: { // SK6812RGBW is RGBW order
          uint8_t w = (uint8_t)(c >> 24);
          *p++ = r;
 80a2960:	547b      	strb	r3, [r7, r1]
          *p++ = g;
 80a2962:	706c      	strb	r4, [r5, #1]
          *p++ = b;
 80a2964:	70ae      	strb	r6, [r5, #2]
          *p = brightness ? ((w * brightness) >> 8) : w;
 80a2966:	7a03      	ldrb	r3, [r0, #8]
          *p++ = r;
          *p++ = b;
          *p = g;
        } break;
      case SK6812RGBW: { // SK6812RGBW is RGBW order
          uint8_t w = (uint8_t)(c >> 24);
 80a2968:	0e12      	lsrs	r2, r2, #24
          *p++ = r;
          *p++ = g;
          *p++ = b;
          *p = brightness ? ((w * brightness) >> 8) : w;
 80a296a:	b90b      	cbnz	r3, 80a2970 <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x84>
          *p++ = r;
          *p++ = b;
          *p = g;
        } break;
      case SK6812RGBW: { // SK6812RGBW is RGBW order
          uint8_t w = (uint8_t)(c >> 24);
 80a296c:	b2d2      	uxtb	r2, r2
 80a296e:	e002      	b.n	80a2976 <_ZN17Adafruit_NeoPixel13setPixelColorEtm+0x8a>
          *p++ = r;
          *p++ = g;
          *p++ = b;
          *p = brightness ? ((w * brightness) >> 8) : w;
 80a2970:	435a      	muls	r2, r3
 80a2972:	f3c2 2207 	ubfx	r2, r2, #8, #8
 80a2976:	70ea      	strb	r2, [r5, #3]
        } break;
 80a2978:	bdf0      	pop	{r4, r5, r6, r7, pc}
      case WS2811: // WS2811 is RGB order
      case TM1803: // TM1803 is RGB order
      default: {   // default is RGB order
          *p++ = r;
 80a297a:	547b      	strb	r3, [r7, r1]
          *p++ = g;
 80a297c:	706c      	strb	r4, [r5, #1]
          *p = b;
 80a297e:	70ae      	strb	r6, [r5, #2]
 80a2980:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a2982 <_ZNK17Adafruit_NeoPixel9numPixelsEv>:
 80a2982:	8840      	ldrh	r0, [r0, #2]
 80a2984:	4770      	bx	lr

080a2986 <_ZN17Adafruit_NeoPixel13setBrightnessEh>:
  // This simplifies the actual scaling math later, allowing a fast
  // 8x8-bit multiply and taking the MSB.  'brightness' is a uint8_t,
  // adding 1 here may (intentionally) roll over...so 0 = max brightness
  // (color values are interpreted literally; no scaling), 1 = min
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
 80a2986:	1c4a      	adds	r2, r1, #1
  if(newBrightness != brightness) { // Compare against prior value
 80a2988:	7a03      	ldrb	r3, [r0, #8]
  // This simplifies the actual scaling math later, allowing a fast
  // 8x8-bit multiply and taking the MSB.  'brightness' is a uint8_t,
  // adding 1 here may (intentionally) roll over...so 0 = max brightness
  // (color values are interpreted literally; no scaling), 1 = min
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
 80a298a:	b2d2      	uxtb	r2, r2
  if(newBrightness != brightness) { // Compare against prior value
 80a298c:	429a      	cmp	r2, r3
// and scale it (subsequent graphics commands also work at this
// brightness level).  If there's a significant step up in brightness,
// the limited number of steps (quantization) in the old data will be
// quite visible in the re-scaled version.  For a non-destructive
// change, you'll need to re-render the full strip data.  C'est la vie.
void Adafruit_NeoPixel::setBrightness(uint8_t b) {
 80a298e:	b570      	push	{r4, r5, r6, lr}
  // 8x8-bit multiply and taking the MSB.  'brightness' is a uint8_t,
  // adding 1 here may (intentionally) roll over...so 0 = max brightness
  // (color values are interpreted literally; no scaling), 1 = min
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
  if(newBrightness != brightness) { // Compare against prior value
 80a2990:	d01e      	beq.n	80a29d0 <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x4a>
    // Brightness has changed -- re-scale existing data in RAM
    uint8_t  c,
            *ptr           = pixels,
             oldBrightness = brightness - 1; // De-wrap old brightness value
 80a2992:	3b01      	subs	r3, #1
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
 80a2994:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
  if(newBrightness != brightness) { // Compare against prior value
    // Brightness has changed -- re-scale existing data in RAM
    uint8_t  c,
            *ptr           = pixels,
 80a2998:	68c4      	ldr	r4, [r0, #12]
             oldBrightness = brightness - 1; // De-wrap old brightness value
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
 80a299a:	d00c      	beq.n	80a29b6 <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x30>
    else if(b == 255) scale = 65535 / oldBrightness;
 80a299c:	29ff      	cmp	r1, #255	; 0xff
 80a299e:	bf0f      	iteee	eq
 80a29a0:	f64f 71ff 	movweq	r1, #65535	; 0xffff
    else scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
 80a29a4:	0211      	lslne	r1, r2, #8
 80a29a6:	f101 31ff 	addne.w	r1, r1, #4294967295
 80a29aa:	fb91 f3f3 	sdivne	r3, r1, r3
    uint8_t  c,
            *ptr           = pixels,
             oldBrightness = brightness - 1; // De-wrap old brightness value
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
    else if(b == 255) scale = 65535 / oldBrightness;
 80a29ae:	bf0c      	ite	eq
 80a29b0:	fb91 f3f3 	sdiveq	r3, r1, r3
    else scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
 80a29b4:	b29b      	uxthne	r3, r3
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
  if(newBrightness != brightness) { // Compare against prior value
    // Brightness has changed -- re-scale existing data in RAM
    uint8_t  c,
            *ptr           = pixels,
 80a29b6:	4625      	mov	r5, r4
             oldBrightness = brightness - 1; // De-wrap old brightness value
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
    else if(b == 255) scale = 65535 / oldBrightness;
    else scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
    for(uint16_t i=0; i<numBytes; i++) {
 80a29b8:	1b29      	subs	r1, r5, r4
 80a29ba:	8886      	ldrh	r6, [r0, #4]
 80a29bc:	b289      	uxth	r1, r1
 80a29be:	428e      	cmp	r6, r1
 80a29c0:	d905      	bls.n	80a29ce <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x48>
      c      = *ptr;
 80a29c2:	7829      	ldrb	r1, [r5, #0]
      *ptr++ = (c * scale) >> 8;
 80a29c4:	4359      	muls	r1, r3
 80a29c6:	1209      	asrs	r1, r1, #8
 80a29c8:	f805 1b01 	strb.w	r1, [r5], #1
             oldBrightness = brightness - 1; // De-wrap old brightness value
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
    else if(b == 255) scale = 65535 / oldBrightness;
    else scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
    for(uint16_t i=0; i<numBytes; i++) {
 80a29cc:	e7f4      	b.n	80a29b8 <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x32>
      c      = *ptr;
      *ptr++ = (c * scale) >> 8;
    }
    brightness = newBrightness;
 80a29ce:	7202      	strb	r2, [r0, #8]
 80a29d0:	bd70      	pop	{r4, r5, r6, pc}
	...

080a29d4 <_GLOBAL__sub_I_PIN_MAP2>:
  return brightness - 1;
}

void Adafruit_NeoPixel::clear(void) {
  memset(pixels, 0, numBytes);
}
 80a29d4:	b508      	push	{r3, lr}
 80a29d6:	f000 feb9 	bl	80a374c <HAL_Pin_Map>

#if PLATFORM_ID == 0 // Core (0)
  #define pinLO(_pin) (PIN_MAP[_pin].gpio_peripheral->BRR = PIN_MAP[_pin].gpio_pin)
  #define pinHI(_pin) (PIN_MAP[_pin].gpio_peripheral->BSRR = PIN_MAP[_pin].gpio_pin)
#elif (PLATFORM_ID == 6) || (PLATFORM_ID == 8) || (PLATFORM_ID == 10) || (PLATFORM_ID == 88) // Photon (6), P1 (8), Electron (10) or Redbear Duo (88)
  STM32_Pin_Info* PIN_MAP2 = HAL_Pin_Map(); // Pointer required for highest access speed
 80a29da:	f000 feb7 	bl	80a374c <HAL_Pin_Map>
 80a29de:	4b01      	ldr	r3, [pc, #4]	; (80a29e4 <_GLOBAL__sub_I_PIN_MAP2+0x10>)
 80a29e0:	6018      	str	r0, [r3, #0]
 80a29e2:	bd08      	pop	{r3, pc}
 80a29e4:	20001330 	.word	0x20001330

080a29e8 <_ZL11expandColort>:
  tilesY(tY), remapFn(NULL) { }

// Expand 16-bit input color (Adafruit_GFX colorspace) to 24-bit (NeoPixel)
// (w/gamma adjustment)
static uint32_t expandColor(uint16_t color) {
  return ((uint32_t)pgm_read_byte(&gamma5[ color >> 11       ]) << 16) |
 80a29e8:	4a07      	ldr	r2, [pc, #28]	; (80a2a08 <_ZL11expandColort+0x20>)
 80a29ea:	12c3      	asrs	r3, r0, #11
         ((uint32_t)pgm_read_byte(&gamma6[(color >> 5) & 0x3F]) <<  8) |
                    pgm_read_byte(&gamma5[ color       & 0x1F]);
 80a29ec:	5cd1      	ldrb	r1, [r2, r3]

// Expand 16-bit input color (Adafruit_GFX colorspace) to 24-bit (NeoPixel)
// (w/gamma adjustment)
static uint32_t expandColor(uint16_t color) {
  return ((uint32_t)pgm_read_byte(&gamma5[ color >> 11       ]) << 16) |
         ((uint32_t)pgm_read_byte(&gamma6[(color >> 5) & 0x3F]) <<  8) |
 80a29ee:	f000 031f 	and.w	r3, r0, #31
                    pgm_read_byte(&gamma5[ color       & 0x1F]);
 80a29f2:	5cd3      	ldrb	r3, [r2, r3]
 80a29f4:	4a05      	ldr	r2, [pc, #20]	; (80a2a0c <_ZL11expandColort+0x24>)

// Expand 16-bit input color (Adafruit_GFX colorspace) to 24-bit (NeoPixel)
// (w/gamma adjustment)
static uint32_t expandColor(uint16_t color) {
  return ((uint32_t)pgm_read_byte(&gamma5[ color >> 11       ]) << 16) |
         ((uint32_t)pgm_read_byte(&gamma6[(color >> 5) & 0x3F]) <<  8) |
 80a29f6:	f3c0 1045 	ubfx	r0, r0, #5, #6
                    pgm_read_byte(&gamma5[ color       & 0x1F]);
 80a29fa:	5c10      	ldrb	r0, [r2, r0]
 80a29fc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
}
 80a2a00:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 80a2a04:	4770      	bx	lr
 80a2a06:	bf00      	nop
 80a2a08:	080a6934 	.word	0x080a6934
 80a2a0c:	080a6954 	.word	0x080a6954

080a2a10 <_ZN18Adafruit_NeoMatrix10fillScreenEt>:
  }

  setPixelColor(tileOffset + pixelOffset, passThruFlag ? passThruColor : expandColor(color));
}

void Adafruit_NeoMatrix::fillScreen(uint16_t color) {
 80a2a10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint16_t i, n;
  uint32_t c;

  c = passThruFlag ? passThruColor : expandColor(color);
 80a2a12:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
  }

  setPixelColor(tileOffset + pixelOffset, passThruFlag ? passThruColor : expandColor(color));
}

void Adafruit_NeoMatrix::fillScreen(uint16_t color) {
 80a2a16:	4604      	mov	r4, r0
  uint16_t i, n;
  uint32_t c;

  c = passThruFlag ? passThruColor : expandColor(color);
 80a2a18:	b10b      	cbz	r3, 80a2a1e <_ZN18Adafruit_NeoMatrix10fillScreenEt+0xe>
 80a2a1a:	6bc6      	ldr	r6, [r0, #60]	; 0x3c
 80a2a1c:	e003      	b.n	80a2a26 <_ZN18Adafruit_NeoMatrix10fillScreenEt+0x16>
 80a2a1e:	4608      	mov	r0, r1
 80a2a20:	f7ff ffe2 	bl	80a29e8 <_ZL11expandColort>
 80a2a24:	4606      	mov	r6, r0
  n   = numPixels();
 80a2a26:	341c      	adds	r4, #28
 80a2a28:	4620      	mov	r0, r4
 80a2a2a:	f7ff ffaa 	bl	80a2982 <_ZNK17Adafruit_NeoPixel9numPixelsEv>
 80a2a2e:	4607      	mov	r7, r0
 80a2a30:	2500      	movs	r5, #0
 80a2a32:	b2a9      	uxth	r1, r5
  for(i=0; i<n; i++) setPixelColor(i, c);
 80a2a34:	42b9      	cmp	r1, r7
 80a2a36:	d205      	bcs.n	80a2a44 <_ZN18Adafruit_NeoMatrix10fillScreenEt+0x34>
 80a2a38:	4632      	mov	r2, r6
 80a2a3a:	4620      	mov	r0, r4
 80a2a3c:	f7ff ff56 	bl	80a28ec <_ZN17Adafruit_NeoPixel13setPixelColorEtm>
 80a2a40:	3501      	adds	r5, #1
 80a2a42:	e7f6      	b.n	80a2a32 <_ZN18Adafruit_NeoMatrix10fillScreenEt+0x22>
 80a2a44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080a2a48 <_ZN18Adafruit_NeoMatrixD1Ev>:
#define NEO_TILE_AXIS          0x40 // Bitmask for tile H/V orientation
#define NEO_TILE_PROGRESSIVE   0x00 // Same tile order across each line
#define NEO_TILE_ZIGZAG        0x80 // Tile order reverses between lines
#define NEO_TILE_SEQUENCE      0x80 // Bitmask for tile line order

class Adafruit_NeoMatrix : public Adafruit_GFX, public Adafruit_NeoPixel {
 80a2a48:	b510      	push	{r4, lr}
 80a2a4a:	4604      	mov	r4, r0
 80a2a4c:	4b03      	ldr	r3, [pc, #12]	; (80a2a5c <_ZN18Adafruit_NeoMatrixD1Ev+0x14>)
 80a2a4e:	f840 3b1c 	str.w	r3, [r0], #28
 80a2a52:	f7fe fe31 	bl	80a16b8 <_ZN17Adafruit_NeoPixelD1Ev>
 80a2a56:	4620      	mov	r0, r4
 80a2a58:	bd10      	pop	{r4, pc}
 80a2a5a:	bf00      	nop
 80a2a5c:	080a6904 	.word	0x080a6904

080a2a60 <_ZN18Adafruit_NeoMatrixD0Ev>:
 80a2a60:	b510      	push	{r4, lr}
 80a2a62:	4604      	mov	r4, r0
 80a2a64:	f7ff fff0 	bl	80a2a48 <_ZN18Adafruit_NeoMatrixD1Ev>
 80a2a68:	4620      	mov	r0, r4
 80a2a6a:	f7fd fb18 	bl	80a009e <_ZdlPv>
 80a2a6e:	4620      	mov	r0, r4
 80a2a70:	bd10      	pop	{r4, pc}

080a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>:
// Call without a value to reset (disable passthrough)
void Adafruit_NeoMatrix::setPassThruColor(void) {
  passThruFlag = false;
}

void Adafruit_NeoMatrix::drawPixel(int16_t x, int16_t y, uint16_t color) {
 80a2a72:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80a2a76:	4604      	mov	r4, r0

  if((x < 0) || (y < 0) || (x >= _width) || (y >= _height)) return;
 80a2a78:	1e08      	subs	r0, r1, #0
// Call without a value to reset (disable passthrough)
void Adafruit_NeoMatrix::setPassThruColor(void) {
  passThruFlag = false;
}

void Adafruit_NeoMatrix::drawPixel(int16_t x, int16_t y, uint16_t color) {
 80a2a7a:	461f      	mov	r7, r3

  if((x < 0) || (y < 0) || (x >= _width) || (y >= _height)) return;
 80a2a7c:	f2c0 80ba 	blt.w	80a2bf4 <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x182>
 80a2a80:	2a00      	cmp	r2, #0
 80a2a82:	f2c0 80b7 	blt.w	80a2bf4 <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x182>
 80a2a86:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80a2a8a:	4283      	cmp	r3, r0
 80a2a8c:	f340 80b2 	ble.w	80a2bf4 <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x182>
 80a2a90:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 80a2a94:	4293      	cmp	r3, r2
 80a2a96:	f340 80ad 	ble.w	80a2bf4 <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x182>

  int16_t t;
  switch(rotation) {
 80a2a9a:	7e63      	ldrb	r3, [r4, #25]
 80a2a9c:	2b02      	cmp	r3, #2
 80a2a9e:	d009      	beq.n	80a2ab4 <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x42>
 80a2aa0:	2b03      	cmp	r3, #3
 80a2aa2:	d010      	beq.n	80a2ac6 <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x54>
 80a2aa4:	2b01      	cmp	r3, #1
 80a2aa6:	d113      	bne.n	80a2ad0 <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x5e>
   case 1:
    t = x;
    x = WIDTH  - 1 - y;
 80a2aa8:	8923      	ldrh	r3, [r4, #8]
 80a2aaa:	3b01      	subs	r3, #1
 80a2aac:	1a9b      	subs	r3, r3, r2
 80a2aae:	4602      	mov	r2, r0
 80a2ab0:	b218      	sxth	r0, r3
 80a2ab2:	e00d      	b.n	80a2ad0 <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x5e>
    y = t;
    break;
   case 2:
    x = WIDTH  - 1 - x;
 80a2ab4:	8923      	ldrh	r3, [r4, #8]
 80a2ab6:	3b01      	subs	r3, #1
 80a2ab8:	1a18      	subs	r0, r3, r0
    y = HEIGHT - 1 - y;
 80a2aba:	8963      	ldrh	r3, [r4, #10]
    t = x;
    x = WIDTH  - 1 - y;
    y = t;
    break;
   case 2:
    x = WIDTH  - 1 - x;
 80a2abc:	b200      	sxth	r0, r0
    y = HEIGHT - 1 - y;
 80a2abe:	3b01      	subs	r3, #1
 80a2ac0:	1a9a      	subs	r2, r3, r2
 80a2ac2:	b212      	sxth	r2, r2
 80a2ac4:	e004      	b.n	80a2ad0 <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x5e>
    break;
   case 3:
    t = x;
    x = y;
    y = HEIGHT - 1 - t;
 80a2ac6:	8963      	ldrh	r3, [r4, #10]
 80a2ac8:	3b01      	subs	r3, #1
 80a2aca:	1a1b      	subs	r3, r3, r0
 80a2acc:	4610      	mov	r0, r2
 80a2ace:	b21a      	sxth	r2, r3
    break;
  }

  int tileOffset = 0, pixelOffset;

  if(remapFn) { // Custom X/Y remapping function
 80a2ad0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a2ad2:	b123      	cbz	r3, 80a2ade <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x6c>
    pixelOffset = (*remapFn)(x, y);
 80a2ad4:	b291      	uxth	r1, r2
 80a2ad6:	b280      	uxth	r0, r0
 80a2ad8:	4798      	blx	r3
    x = y;
    y = HEIGHT - 1 - t;
    break;
  }

  int tileOffset = 0, pixelOffset;
 80a2ada:	2500      	movs	r5, #0
 80a2adc:	e077      	b.n	80a2bce <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x15c>

  if(remapFn) { // Custom X/Y remapping function
    pixelOffset = (*remapFn)(x, y);
  } else {      // Standard single matrix or tiled matrices

    uint8_t  corner = type & NEO_MATRIX_CORNER;
 80a2ade:	f894 e030 	ldrb.w	lr, [r4, #48]	; 0x30
    uint16_t minor, major, majorScale;

    if(tilesX) { // Tiled display, multiple matrices
 80a2ae2:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33

  if(remapFn) { // Custom X/Y remapping function
    pixelOffset = (*remapFn)(x, y);
  } else {      // Standard single matrix or tiled matrices

    uint8_t  corner = type & NEO_MATRIX_CORNER;
 80a2ae6:	f00e 0803 	and.w	r8, lr, #3
    uint16_t minor, major, majorScale;

    if(tilesX) { // Tiled display, multiple matrices
 80a2aea:	2b00      	cmp	r3, #0
 80a2aec:	d041      	beq.n	80a2b72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x100>
      uint16_t tile;

      minor = x / matrixWidth;            // Tile # X/Y; presume row major to
 80a2aee:	f894 c031 	ldrb.w	ip, [r4, #49]	; 0x31
      major = y / matrixHeight,           // start (will swap later if needed)
 80a2af2:	f894 9032 	ldrb.w	r9, [r4, #50]	; 0x32
    uint16_t minor, major, majorScale;

    if(tilesX) { // Tiled display, multiple matrices
      uint16_t tile;

      minor = x / matrixWidth;            // Tile # X/Y; presume row major to
 80a2af6:	fb90 f5fc 	sdiv	r5, r0, ip
      major = y / matrixHeight,           // start (will swap later if needed)
      x     = x - (minor * matrixWidth);  // Pixel X/Y within tile
 80a2afa:	fb92 f6f9 	sdiv	r6, r2, r9
      y     = y - (major * matrixHeight); // (-* is less math than modulo)

      // Determine corner of entry, flip axes if needed
      if(type & NEO_TILE_RIGHT)  minor = tilesX - 1 - minor;
 80a2afe:	f01e 0f20 	tst.w	lr, #32
 80a2b02:	bf18      	it	ne
 80a2b04:	f103 31ff 	addne.w	r1, r3, #4294967295
    uint16_t minor, major, majorScale;

    if(tilesX) { // Tiled display, multiple matrices
      uint16_t tile;

      minor = x / matrixWidth;            // Tile # X/Y; presume row major to
 80a2b08:	b2ad      	uxth	r5, r5
      major = y / matrixHeight,           // start (will swap later if needed)
      x     = x - (minor * matrixWidth);  // Pixel X/Y within tile
 80a2b0a:	fb0c 0015 	mls	r0, ip, r5, r0
      y     = y - (major * matrixHeight); // (-* is less math than modulo)

      // Determine corner of entry, flip axes if needed
      if(type & NEO_TILE_RIGHT)  minor = tilesX - 1 - minor;
 80a2b0e:	bf1c      	itt	ne
 80a2b10:	1b4d      	subne	r5, r1, r5
 80a2b12:	b2ad      	uxthne	r5, r5
      if(type & NEO_TILE_BOTTOM) major = tilesY - 1 - major;
 80a2b14:	f01e 0f10 	tst.w	lr, #16
 80a2b18:	bf18      	it	ne
 80a2b1a:	f894 1034 	ldrbne.w	r1, [r4, #52]	; 0x34
    if(tilesX) { // Tiled display, multiple matrices
      uint16_t tile;

      minor = x / matrixWidth;            // Tile # X/Y; presume row major to
      major = y / matrixHeight,           // start (will swap later if needed)
      x     = x - (minor * matrixWidth);  // Pixel X/Y within tile
 80a2b1e:	b2b6      	uxth	r6, r6
      y     = y - (major * matrixHeight); // (-* is less math than modulo)

      // Determine corner of entry, flip axes if needed
      if(type & NEO_TILE_RIGHT)  minor = tilesX - 1 - minor;
      if(type & NEO_TILE_BOTTOM) major = tilesY - 1 - major;
 80a2b20:	bf18      	it	ne
 80a2b22:	f101 31ff 	addne.w	r1, r1, #4294967295
      uint16_t tile;

      minor = x / matrixWidth;            // Tile # X/Y; presume row major to
      major = y / matrixHeight,           // start (will swap later if needed)
      x     = x - (minor * matrixWidth);  // Pixel X/Y within tile
      y     = y - (major * matrixHeight); // (-* is less math than modulo)
 80a2b26:	fb09 2216 	mls	r2, r9, r6, r2

      // Determine corner of entry, flip axes if needed
      if(type & NEO_TILE_RIGHT)  minor = tilesX - 1 - minor;
      if(type & NEO_TILE_BOTTOM) major = tilesY - 1 - major;
 80a2b2a:	bf1c      	itt	ne
 80a2b2c:	1b8e      	subne	r6, r1, r6
 80a2b2e:	b2b6      	uxthne	r6, r6

      // Determine actual major axis of tiling
      if((type & NEO_TILE_AXIS) == NEO_TILE_ROWS) {
 80a2b30:	f01e 0f40 	tst.w	lr, #64	; 0x40
        majorScale = tilesX;
 80a2b34:	bf03      	ittte	eq
 80a2b36:	4631      	moveq	r1, r6
 80a2b38:	b29b      	uxtheq	r3, r3
 80a2b3a:	462e      	moveq	r6, r5
      } else {
        swap(major, minor);
        majorScale = tilesY;
 80a2b3c:	f894 3034 	ldrbne.w	r3, [r4, #52]	; 0x34
      if(type & NEO_TILE_RIGHT)  minor = tilesX - 1 - minor;
      if(type & NEO_TILE_BOTTOM) major = tilesY - 1 - major;

      // Determine actual major axis of tiling
      if((type & NEO_TILE_AXIS) == NEO_TILE_ROWS) {
        majorScale = tilesX;
 80a2b40:	bf08      	it	eq
 80a2b42:	460d      	moveq	r5, r1
        swap(major, minor);
        majorScale = tilesY;
      }

      // Determine tile number
      if((type & NEO_TILE_SEQUENCE) == NEO_TILE_PROGRESSIVE) {
 80a2b44:	f01e 0f80 	tst.w	lr, #128	; 0x80
    if(tilesX) { // Tiled display, multiple matrices
      uint16_t tile;

      minor = x / matrixWidth;            // Tile # X/Y; presume row major to
      major = y / matrixHeight,           // start (will swap later if needed)
      x     = x - (minor * matrixWidth);  // Pixel X/Y within tile
 80a2b48:	b200      	sxth	r0, r0
      y     = y - (major * matrixHeight); // (-* is less math than modulo)
 80a2b4a:	b212      	sxth	r2, r2
        swap(major, minor);
        majorScale = tilesY;
      }

      // Determine tile number
      if((type & NEO_TILE_SEQUENCE) == NEO_TILE_PROGRESSIVE) {
 80a2b4c:	d009      	beq.n	80a2b62 <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0xf0>
        tile = major * majorScale + minor;
      } else {
        // Zigzag; alternate rows change direction.  On these rows,
        // this also flips the starting corner of the matrix for the
        // pixel math later.
        if(major & 1) {
 80a2b4e:	07e9      	lsls	r1, r5, #31
 80a2b50:	d507      	bpl.n	80a2b62 <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0xf0>
          corner ^= NEO_MATRIX_CORNER;
          tile = (major + 1) * majorScale - 1 - minor;
 80a2b52:	43f6      	mvns	r6, r6
 80a2b54:	fb05 3503 	mla	r5, r5, r3, r3
 80a2b58:	4435      	add	r5, r6
      } else {
        // Zigzag; alternate rows change direction.  On these rows,
        // this also flips the starting corner of the matrix for the
        // pixel math later.
        if(major & 1) {
          corner ^= NEO_MATRIX_CORNER;
 80a2b5a:	f088 0803 	eor.w	r8, r8, #3
          tile = (major + 1) * majorScale - 1 - minor;
 80a2b5e:	b2ad      	uxth	r5, r5
 80a2b60:	e002      	b.n	80a2b68 <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0xf6>
        } else {
          tile =  major      * majorScale     + minor;
 80a2b62:	fb03 6505 	mla	r5, r3, r5, r6
 80a2b66:	b2ad      	uxth	r5, r5
        }
      }

      // Index of first pixel in tile
      tileOffset = tile * matrixWidth * matrixHeight;
 80a2b68:	fb0c f505 	mul.w	r5, ip, r5
 80a2b6c:	fb09 f505 	mul.w	r5, r9, r5
 80a2b70:	e000      	b.n	80a2b74 <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x102>
    x = y;
    y = HEIGHT - 1 - t;
    break;
  }

  int tileOffset = 0, pixelOffset;
 80a2b72:	461d      	mov	r5, r3
    // Find pixel number within tile
    minor = x; // Presume row major to start (will swap later if needed)
    major = y;

    // Determine corner of entry, flip axes if needed
    if(corner & NEO_MATRIX_RIGHT)  minor = matrixWidth  - 1 - minor;
 80a2b74:	f018 0f02 	tst.w	r8, #2
 80a2b78:	bf18      	it	ne
 80a2b7a:	f894 3031 	ldrbne.w	r3, [r4, #49]	; 0x31
      tileOffset = tile * matrixWidth * matrixHeight;

    } // else no tiling (handle as single tile)

    // Find pixel number within tile
    minor = x; // Presume row major to start (will swap later if needed)
 80a2b7e:	b280      	uxth	r0, r0
    major = y;

    // Determine corner of entry, flip axes if needed
    if(corner & NEO_MATRIX_RIGHT)  minor = matrixWidth  - 1 - minor;
 80a2b80:	bf1e      	ittt	ne
 80a2b82:	f103 33ff 	addne.w	r3, r3, #4294967295
 80a2b86:	1a18      	subne	r0, r3, r0
 80a2b88:	b280      	uxthne	r0, r0
    if(corner & NEO_MATRIX_BOTTOM) major = matrixHeight - 1 - major;
 80a2b8a:	f018 0f01 	tst.w	r8, #1
 80a2b8e:	bf18      	it	ne
 80a2b90:	f894 3032 	ldrbne.w	r3, [r4, #50]	; 0x32

    } // else no tiling (handle as single tile)

    // Find pixel number within tile
    minor = x; // Presume row major to start (will swap later if needed)
    major = y;
 80a2b94:	b292      	uxth	r2, r2

    // Determine corner of entry, flip axes if needed
    if(corner & NEO_MATRIX_RIGHT)  minor = matrixWidth  - 1 - minor;
    if(corner & NEO_MATRIX_BOTTOM) major = matrixHeight - 1 - major;
 80a2b96:	bf1e      	ittt	ne
 80a2b98:	f103 33ff 	addne.w	r3, r3, #4294967295
 80a2b9c:	1a9a      	subne	r2, r3, r2
 80a2b9e:	b292      	uxthne	r2, r2

    // Determine actual major axis of matrix
    if((type & NEO_MATRIX_AXIS) == NEO_MATRIX_ROWS) {
 80a2ba0:	f01e 0f04 	tst.w	lr, #4
      majorScale = matrixWidth;
 80a2ba4:	bf03      	ittte	eq
 80a2ba6:	4611      	moveq	r1, r2
 80a2ba8:	f894 3031 	ldrbeq.w	r3, [r4, #49]	; 0x31
 80a2bac:	4602      	moveq	r2, r0
    } else {
      swap(major, minor);
      majorScale = matrixHeight;
 80a2bae:	f894 3032 	ldrbne.w	r3, [r4, #50]	; 0x32
    if(corner & NEO_MATRIX_RIGHT)  minor = matrixWidth  - 1 - minor;
    if(corner & NEO_MATRIX_BOTTOM) major = matrixHeight - 1 - major;

    // Determine actual major axis of matrix
    if((type & NEO_MATRIX_AXIS) == NEO_MATRIX_ROWS) {
      majorScale = matrixWidth;
 80a2bb2:	bf08      	it	eq
 80a2bb4:	4608      	moveq	r0, r1
      swap(major, minor);
      majorScale = matrixHeight;
    }

    // Determine pixel number within tile/matrix
    if((type & NEO_MATRIX_SEQUENCE) == NEO_MATRIX_PROGRESSIVE) {
 80a2bb6:	f01e 0f08 	tst.w	lr, #8
 80a2bba:	d006      	beq.n	80a2bca <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x158>
      // All lines in same order
      pixelOffset = major * majorScale + minor;
    } else {
      // Zigzag; alternate rows change direction.
      if(major & 1) pixelOffset = (major + 1) * majorScale - 1 - minor;
 80a2bbc:	07c1      	lsls	r1, r0, #31
 80a2bbe:	d504      	bpl.n	80a2bca <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x158>
 80a2bc0:	fb00 3303 	mla	r3, r0, r3, r3
 80a2bc4:	3b01      	subs	r3, #1
 80a2bc6:	1a98      	subs	r0, r3, r2
 80a2bc8:	e001      	b.n	80a2bce <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x15c>
      else          pixelOffset =  major      * majorScale     + minor;
 80a2bca:	fb03 2000 	mla	r0, r3, r0, r2
    }
  }

  setPixelColor(tileOffset + pixelOffset, passThruFlag ? passThruColor : expandColor(color));
 80a2bce:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80a2bd2:	4428      	add	r0, r5
 80a2bd4:	f104 061c 	add.w	r6, r4, #28
 80a2bd8:	b285      	uxth	r5, r0
 80a2bda:	b10b      	cbz	r3, 80a2be0 <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x16e>
 80a2bdc:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80a2bde:	e003      	b.n	80a2be8 <_ZN18Adafruit_NeoMatrix9drawPixelEsst+0x176>
 80a2be0:	4638      	mov	r0, r7
 80a2be2:	f7ff ff01 	bl	80a29e8 <_ZL11expandColort>
 80a2be6:	4602      	mov	r2, r0
 80a2be8:	4629      	mov	r1, r5
 80a2bea:	4630      	mov	r0, r6
}
 80a2bec:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
      if(major & 1) pixelOffset = (major + 1) * majorScale - 1 - minor;
      else          pixelOffset =  major      * majorScale     + minor;
    }
  }

  setPixelColor(tileOffset + pixelOffset, passThruFlag ? passThruColor : expandColor(color));
 80a2bf0:	f7ff be7c 	b.w	80a28ec <_ZN17Adafruit_NeoPixel13setPixelColorEtm>
 80a2bf4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080a2bf8 <_ZN18Adafruit_NeoMatrixC1Eiihhh>:
#include "gamma.h"

#define pgm_read_byte(addr) (*(const unsigned char *)(addr))

// Constructor for single matrix:
Adafruit_NeoMatrix::Adafruit_NeoMatrix(int w, int h, uint8_t pin,
 80a2bf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2bfa:	460e      	mov	r6, r1
 80a2bfc:	4615      	mov	r5, r2
 80a2bfe:	4604      	mov	r4, r0
 80a2c00:	461f      	mov	r7, r3
  uint8_t matrixType, uint8_t ledType) : Adafruit_GFX(w, h),
  Adafruit_NeoPixel(w * h, pin, ledType), type(matrixType), matrixWidth(w),
  matrixHeight(h), tilesX(0), tilesY(0), remapFn(NULL) { }
 80a2c02:	b212      	sxth	r2, r2
 80a2c04:	b209      	sxth	r1, r1
 80a2c06:	f7fe fc23 	bl	80a1450 <_ZN12Adafruit_GFXC1Ess>
 80a2c0a:	fb06 f105 	mul.w	r1, r6, r5
 80a2c0e:	f89d 301c 	ldrb.w	r3, [sp, #28]
 80a2c12:	463a      	mov	r2, r7
 80a2c14:	b289      	uxth	r1, r1
 80a2c16:	f104 001c 	add.w	r0, r4, #28
 80a2c1a:	f7fe fd9c 	bl	80a1756 <_ZN17Adafruit_NeoPixelC1Ethh>
 80a2c1e:	4b0a      	ldr	r3, [pc, #40]	; (80a2c48 <_ZN18Adafruit_NeoMatrixC1Eiihhh+0x50>)
 80a2c20:	f884 6031 	strb.w	r6, [r4, #49]	; 0x31
 80a2c24:	6023      	str	r3, [r4, #0]
 80a2c26:	f89d 3018 	ldrb.w	r3, [sp, #24]
 80a2c2a:	f884 5032 	strb.w	r5, [r4, #50]	; 0x32
 80a2c2e:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
 80a2c32:	2300      	movs	r3, #0
 80a2c34:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
 80a2c38:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 80a2c3c:	63a3      	str	r3, [r4, #56]	; 0x38
 80a2c3e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 80a2c42:	4620      	mov	r0, r4
 80a2c44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a2c46:	bf00      	nop
 80a2c48:	080a6904 	.word	0x080a6904

080a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>:

// Downgrade 24-bit color to 16-bit (add reverse gamma lookup here?)
uint16_t Adafruit_NeoMatrix::Color(uint8_t r, uint8_t g, uint8_t b) {
  return ((uint16_t)(r & 0xF8) << 8) |
         ((uint16_t)(g & 0xFC) << 3) |
                    (b         >> 3);
 80a2c4c:	00c9      	lsls	r1, r1, #3
 80a2c4e:	f401 61fc 	and.w	r1, r1, #2016	; 0x7e0
 80a2c52:	0200      	lsls	r0, r0, #8
 80a2c54:	ea41 02d2 	orr.w	r2, r1, r2, lsr #3
 80a2c58:	f400 4078 	and.w	r0, r0, #63488	; 0xf800
}
 80a2c5c:	4310      	orrs	r0, r2
 80a2c5e:	4770      	bx	lr

080a2c60 <_GLOBAL__sub_I__ZN18Adafruit_NeoMatrixC2Eiihhh>:
 80a2c60:	f000 bd74 	b.w	80a374c <HAL_Pin_Map>

080a2c64 <_Z9GFX_setupv>:
void rainbowLeds();
int rr(int minRand, int maxRand);
uint32_t Wheel(uint8_t WheelPos);

/********************* FUNCTIONS *********************** */
void GFX_setup() {    
 80a2c64:	b538      	push	{r3, r4, r5, lr}
    textLength = text.length();
    matrix.begin();
 80a2c66:	4c0e      	ldr	r4, [pc, #56]	; (80a2ca0 <_Z9GFX_setupv+0x3c>)
 80a2c68:	4b0e      	ldr	r3, [pc, #56]	; (80a2ca4 <_Z9GFX_setupv+0x40>)
 80a2c6a:	f104 051c 	add.w	r5, r4, #28
int rr(int minRand, int maxRand);
uint32_t Wheel(uint8_t WheelPos);

/********************* FUNCTIONS *********************** */
void GFX_setup() {    
    textLength = text.length();
 80a2c6e:	689a      	ldr	r2, [r3, #8]
 80a2c70:	4b0d      	ldr	r3, [pc, #52]	; (80a2ca8 <_Z9GFX_setupv+0x44>)
    matrix.begin();
 80a2c72:	4628      	mov	r0, r5
int rr(int minRand, int maxRand);
uint32_t Wheel(uint8_t WheelPos);

/********************* FUNCTIONS *********************** */
void GFX_setup() {    
    textLength = text.length();
 80a2c74:	601a      	str	r2, [r3, #0]
    matrix.begin();
 80a2c76:	f7fe fd49 	bl	80a170c <_ZN17Adafruit_NeoPixel5beginEv>
    matrix.setTextWrap(false);
 80a2c7a:	4620      	mov	r0, r4
 80a2c7c:	2100      	movs	r1, #0
 80a2c7e:	f7fe fd12 	bl	80a16a6 <_ZN12Adafruit_GFX11setTextWrapEb>
    matrix.setBrightness(30);
 80a2c82:	4628      	mov	r0, r5
 80a2c84:	211e      	movs	r1, #30
 80a2c86:	f7ff fe7e 	bl	80a2986 <_ZN17Adafruit_NeoPixel13setBrightnessEh>
    matrix.setTextColor(matrix.Color(255,0,255));
 80a2c8a:	22ff      	movs	r2, #255	; 0xff
 80a2c8c:	2100      	movs	r1, #0
 80a2c8e:	4610      	mov	r0, r2
 80a2c90:	f7ff ffdc 	bl	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
 80a2c94:	4601      	mov	r1, r0
 80a2c96:	4620      	mov	r0, r4
}
 80a2c98:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
void GFX_setup() {    
    textLength = text.length();
    matrix.begin();
    matrix.setTextWrap(false);
    matrix.setBrightness(30);
    matrix.setTextColor(matrix.Color(255,0,255));
 80a2c9c:	f7fe bd00 	b.w	80a16a0 <_ZN12Adafruit_GFX12setTextColorEt>
 80a2ca0:	20001378 	.word	0x20001378
 80a2ca4:	20001354 	.word	0x20001354
 80a2ca8:	200013c8 	.word	0x200013c8

080a2cac <_Z13GFX_setString6String>:
    if (enableLightAllBoxes) lightBoxes();
    if (enableTextScrolling) scrollDisplay();
    if (enableRainbowLeds)   rainbowLeds();
}

void GFX_setString(String s) {
 80a2cac:	b538      	push	{r3, r4, r5, lr}
 80a2cae:	4605      	mov	r5, r0
  for(int i = 0; i < s.length(); i++) {
 80a2cb0:	2400      	movs	r4, #0
 80a2cb2:	68ab      	ldr	r3, [r5, #8]
 80a2cb4:	429c      	cmp	r4, r3
 80a2cb6:	d20d      	bcs.n	80a2cd4 <_Z13GFX_setString6String+0x28>

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
	String & operator += (char c)			{concat(c); return (*this);}
 80a2cb8:	2120      	movs	r1, #32
 80a2cba:	480a      	ldr	r0, [pc, #40]	; (80a2ce4 <_Z13GFX_setString6String+0x38>)
 80a2cbc:	f000 ffb7 	bl	80a3c2e <_ZN6String6concatEc>
    text += ' ';
    text += s[i];
 80a2cc0:	4621      	mov	r1, r4
 80a2cc2:	4628      	mov	r0, r5
 80a2cc4:	f000 ffc0 	bl	80a3c48 <_ZN6StringixEj>
 80a2cc8:	7801      	ldrb	r1, [r0, #0]
 80a2cca:	4806      	ldr	r0, [pc, #24]	; (80a2ce4 <_Z13GFX_setString6String+0x38>)
 80a2ccc:	f000 ffaf 	bl	80a3c2e <_ZN6String6concatEc>
    if (enableTextScrolling) scrollDisplay();
    if (enableRainbowLeds)   rainbowLeds();
}

void GFX_setString(String s) {
  for(int i = 0; i < s.length(); i++) {
 80a2cd0:	3401      	adds	r4, #1
 80a2cd2:	e7ee      	b.n	80a2cb2 <_Z13GFX_setString6String+0x6>
 80a2cd4:	4b03      	ldr	r3, [pc, #12]	; (80a2ce4 <_Z13GFX_setString6String+0x38>)
    text += ' ';
    text += s[i];
  }

  textLength = text.length();
 80a2cd6:	689a      	ldr	r2, [r3, #8]
 80a2cd8:	4b03      	ldr	r3, [pc, #12]	; (80a2ce8 <_Z13GFX_setString6String+0x3c>)
 80a2cda:	601a      	str	r2, [r3, #0]
  enableTextScrolling = true;
 80a2cdc:	4b03      	ldr	r3, [pc, #12]	; (80a2cec <_Z13GFX_setString6String+0x40>)
 80a2cde:	2201      	movs	r2, #1
 80a2ce0:	701a      	strb	r2, [r3, #0]
 80a2ce2:	bd38      	pop	{r3, r4, r5, pc}
 80a2ce4:	20001354 	.word	0x20001354
 80a2ce8:	200013c8 	.word	0x200013c8
 80a2cec:	200013cc 	.word	0x200013cc

080a2cf0 <_Z17GFX_setBrightnessi>:
}

void GFX_setBrightness(int brightness) {
    if (0 < brightness && brightness <= 100) {
 80a2cf0:	1e43      	subs	r3, r0, #1
 80a2cf2:	2b63      	cmp	r3, #99	; 0x63

  textLength = text.length();
  enableTextScrolling = true;
}

void GFX_setBrightness(int brightness) {
 80a2cf4:	b507      	push	{r0, r1, r2, lr}
    if (0 < brightness && brightness <= 100) {
 80a2cf6:	d810      	bhi.n	80a2d1a <_Z17GFX_setBrightnessi+0x2a>
    matrix.setBrightness(map(brightness, 0, 100, 0, 255));
 80a2cf8:	23ff      	movs	r3, #255	; 0xff
 80a2cfa:	9300      	str	r3, [sp, #0]
 80a2cfc:	2300      	movs	r3, #0
 80a2cfe:	4619      	mov	r1, r3
 80a2d00:	2264      	movs	r2, #100	; 0x64
 80a2d02:	f001 f8a3 	bl	80a3e4c <_Z3mapiiiii>
 80a2d06:	b2c1      	uxtb	r1, r0
 80a2d08:	4805      	ldr	r0, [pc, #20]	; (80a2d20 <_Z17GFX_setBrightnessi+0x30>)
 80a2d0a:	f7ff fe3c 	bl	80a2986 <_ZN17Adafruit_NeoPixel13setBrightnessEh>
    matrix.show();
 80a2d0e:	4804      	ldr	r0, [pc, #16]	; (80a2d20 <_Z17GFX_setBrightnessi+0x30>)
  }
}
 80a2d10:	b003      	add	sp, #12
 80a2d12:	f85d eb04 	ldr.w	lr, [sp], #4
}

void GFX_setBrightness(int brightness) {
    if (0 < brightness && brightness <= 100) {
    matrix.setBrightness(map(brightness, 0, 100, 0, 255));
    matrix.show();
 80a2d16:	f7fe bd2f 	b.w	80a1778 <_ZN17Adafruit_NeoPixel4showEv>
  }
}
 80a2d1a:	b003      	add	sp, #12
 80a2d1c:	f85d fb04 	ldr.w	pc, [sp], #4
 80a2d20:	20001394 	.word	0x20001394

080a2d24 <_Z9GFX_clearv>:

void GFX_clear() {
    matrix.fillScreen(0);
 80a2d24:	2100      	movs	r1, #0
 80a2d26:	4801      	ldr	r0, [pc, #4]	; (80a2d2c <_Z9GFX_clearv+0x8>)
 80a2d28:	f7ff be72 	b.w	80a2a10 <_ZN18Adafruit_NeoMatrix10fillScreenEt>
 80a2d2c:	20001378 	.word	0x20001378

080a2d30 <_Z10GFX_updatev>:
}

void GFX_update() {
    matrix.show();
 80a2d30:	4801      	ldr	r0, [pc, #4]	; (80a2d38 <_Z10GFX_updatev+0x8>)
 80a2d32:	f7fe bd21 	b.w	80a1778 <_ZN17Adafruit_NeoPixel4showEv>
 80a2d36:	bf00      	nop
 80a2d38:	20001394 	.word	0x20001394

080a2d3c <_Z12GFX_lightBoxiit>:
  //     || (8 <= row && row < 14 && 0 <= col && col < 8))) return;

  int ledCount;
  int ledOffset;

    sRow = row;
 80a2d3c:	4b1f      	ldr	r3, [pc, #124]	; (80a2dbc <_Z12GFX_lightBoxiit+0x80>)
void GFX_update() {
    matrix.show();
}

void GFX_lightBox(int row, int col, uint16_t color)
{
 80a2d3e:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  //     || (8 <= row && row < 14 && 0 <= col && col < 8))) return;

  int ledCount;
  int ledOffset;

    sRow = row;
 80a2d42:	6018      	str	r0, [r3, #0]
    sCol = col;
 80a2d44:	4b1e      	ldr	r3, [pc, #120]	; (80a2dc0 <_Z12GFX_lightBoxiit+0x84>)
void GFX_update() {
    matrix.show();
}

void GFX_lightBox(int row, int col, uint16_t color)
{
 80a2d46:	4690      	mov	r8, r2

  int ledCount;
  int ledOffset;

    sRow = row;
    sCol = col;
 80a2d48:	6019      	str	r1, [r3, #0]
    sColor = green;
 80a2d4a:	4b1e      	ldr	r3, [pc, #120]	; (80a2dc4 <_Z12GFX_lightBoxiit+0x88>)
    sSet = true;

  if (row < 8 && col < 16) {
 80a2d4c:	2807      	cmp	r0, #7
  int ledCount;
  int ledOffset;

    sRow = row;
    sCol = col;
    sColor = green;
 80a2d4e:	881a      	ldrh	r2, [r3, #0]
 80a2d50:	4b1d      	ldr	r3, [pc, #116]	; (80a2dc8 <_Z12GFX_lightBoxiit+0x8c>)
void GFX_update() {
    matrix.show();
}

void GFX_lightBox(int row, int col, uint16_t color)
{
 80a2d52:	4605      	mov	r5, r0
  int ledCount;
  int ledOffset;

    sRow = row;
    sCol = col;
    sColor = green;
 80a2d54:	801a      	strh	r2, [r3, #0]
    sSet = true;
 80a2d56:	4b1d      	ldr	r3, [pc, #116]	; (80a2dcc <_Z12GFX_lightBoxiit+0x90>)
 80a2d58:	f04f 0201 	mov.w	r2, #1
void GFX_update() {
    matrix.show();
}

void GFX_lightBox(int row, int col, uint16_t color)
{
 80a2d5c:	460c      	mov	r4, r1
  int ledOffset;

    sRow = row;
    sCol = col;
    sColor = green;
    sSet = true;
 80a2d5e:	701a      	strb	r2, [r3, #0]

  if (row < 8 && col < 16) {
 80a2d60:	dc08      	bgt.n	80a2d74 <_Z12GFX_lightBoxiit+0x38>
 80a2d62:	290f      	cmp	r1, #15
 80a2d64:	dc11      	bgt.n	80a2d8a <_Z12GFX_lightBoxiit+0x4e>
    ledCount = boxLedWidthByColumnTop[col];
 80a2d66:	4b1a      	ldr	r3, [pc, #104]	; (80a2dd0 <_Z12GFX_lightBoxiit+0x94>)
 80a2d68:	f853 7021 	ldr.w	r7, [r3, r1, lsl #2]
    ledOffset = boxLedOffsetByColumnTop[col];
 80a2d6c:	4b19      	ldr	r3, [pc, #100]	; (80a2dd4 <_Z12GFX_lightBoxiit+0x98>)
 80a2d6e:	f853 6021 	ldr.w	r6, [r3, r1, lsl #2]
 80a2d72:	e012      	b.n	80a2d9a <_Z12GFX_lightBoxiit+0x5e>
  } else if (row < 16 && col < 8) {
 80a2d74:	280f      	cmp	r0, #15
 80a2d76:	dc08      	bgt.n	80a2d8a <_Z12GFX_lightBoxiit+0x4e>
 80a2d78:	2907      	cmp	r1, #7
 80a2d7a:	dc06      	bgt.n	80a2d8a <_Z12GFX_lightBoxiit+0x4e>
    ledCount = boxLedWidthByColumnBottom[col];
 80a2d7c:	4b16      	ldr	r3, [pc, #88]	; (80a2dd8 <_Z12GFX_lightBoxiit+0x9c>)
 80a2d7e:	f853 7021 	ldr.w	r7, [r3, r1, lsl #2]
    ledOffset = boxLedOffsetByColumnBottom[col];
 80a2d82:	4b16      	ldr	r3, [pc, #88]	; (80a2ddc <_Z12GFX_lightBoxiit+0xa0>)
 80a2d84:	f853 6021 	ldr.w	r6, [r3, r1, lsl #2]
 80a2d88:	e007      	b.n	80a2d9a <_Z12GFX_lightBoxiit+0x5e>
  } else {
    Serial.printlnf("Invalid. Row: %d, Col: %d\n", row, col);
 80a2d8a:	f001 fc3d 	bl	80a4608 <_Z16_fetch_usbserialv>
    }

    template <typename... Args>
    inline size_t printlnf(const char* format, Args... args)
    {
        return this->printf_impl(true, format, args...);
 80a2d8e:	9400      	str	r4, [sp, #0]
 80a2d90:	462b      	mov	r3, r5
 80a2d92:	4a13      	ldr	r2, [pc, #76]	; (80a2de0 <_Z12GFX_lightBoxiit+0xa4>)
 80a2d94:	2101      	movs	r1, #1
 80a2d96:	f000 fff0 	bl	80a3d7a <_ZN5Print11printf_implEbPKcz>

  //Serial.printlnf("row: %d, col: %d, count: %d, offset: %d", row, col, ledCount, ledOffset);

  //matrix.fillScreen(0);

  for (int i = 0; i < ledCount; i++) {
 80a2d9a:	2400      	movs	r4, #0
    matrix.drawPixel(ledOffset + i, row, color);
 80a2d9c:	b22d      	sxth	r5, r5

  //Serial.printlnf("row: %d, col: %d, count: %d, offset: %d", row, col, ledCount, ledOffset);

  //matrix.fillScreen(0);

  for (int i = 0; i < ledCount; i++) {
 80a2d9e:	42a7      	cmp	r7, r4
 80a2da0:	dd08      	ble.n	80a2db4 <_Z12GFX_lightBoxiit+0x78>
    matrix.drawPixel(ledOffset + i, row, color);
 80a2da2:	1931      	adds	r1, r6, r4
 80a2da4:	4643      	mov	r3, r8
 80a2da6:	462a      	mov	r2, r5
 80a2da8:	b209      	sxth	r1, r1
 80a2daa:	480e      	ldr	r0, [pc, #56]	; (80a2de4 <_Z12GFX_lightBoxiit+0xa8>)
 80a2dac:	f7ff fe61 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>

  //Serial.printlnf("row: %d, col: %d, count: %d, offset: %d", row, col, ledCount, ledOffset);

  //matrix.fillScreen(0);

  for (int i = 0; i < ledCount; i++) {
 80a2db0:	3401      	adds	r4, #1
 80a2db2:	e7f4      	b.n	80a2d9e <_Z12GFX_lightBoxiit+0x62>
    matrix.drawPixel(ledOffset + i, row, color);
  }

  //matrix.show();
}
 80a2db4:	b002      	add	sp, #8
 80a2db6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a2dba:	bf00      	nop
 80a2dbc:	200013bc 	.word	0x200013bc
 80a2dc0:	200013c0 	.word	0x200013c0
 80a2dc4:	20001344 	.word	0x20001344
 80a2dc8:	2000136e 	.word	0x2000136e
 80a2dcc:	20001350 	.word	0x20001350
 80a2dd0:	080a6a7c 	.word	0x080a6a7c
 80a2dd4:	080a69c4 	.word	0x080a69c4
 80a2dd8:	080a6a5c 	.word	0x080a6a5c
 80a2ddc:	080a6994 	.word	0x080a6994
 80a2de0:	080a6a0a 	.word	0x080a6a0a
 80a2de4:	20001378 	.word	0x20001378

080a2de8 <_Z16GFX_showNotFoundv>:

void GFX_showNotFound() {
 80a2de8:	b538      	push	{r3, r4, r5, lr}
    matrix.fillScreen(0);
 80a2dea:	4c0c      	ldr	r4, [pc, #48]	; (80a2e1c <_Z16GFX_showNotFoundv+0x34>)
    matrix.drawPixel(29, 7, red);
 80a2dec:	4d0c      	ldr	r5, [pc, #48]	; (80a2e20 <_Z16GFX_showNotFoundv+0x38>)

  //matrix.show();
}

void GFX_showNotFound() {
    matrix.fillScreen(0);
 80a2dee:	4620      	mov	r0, r4
 80a2df0:	2100      	movs	r1, #0
 80a2df2:	f7ff fe0d 	bl	80a2a10 <_ZN18Adafruit_NeoMatrix10fillScreenEt>
    matrix.drawPixel(29, 7, red);
 80a2df6:	882b      	ldrh	r3, [r5, #0]
 80a2df8:	4620      	mov	r0, r4
 80a2dfa:	2207      	movs	r2, #7
 80a2dfc:	211d      	movs	r1, #29
 80a2dfe:	f7ff fe38 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>
    matrix.drawPixel(30, 7, red);
 80a2e02:	4620      	mov	r0, r4
 80a2e04:	882b      	ldrh	r3, [r5, #0]
 80a2e06:	2207      	movs	r2, #7
 80a2e08:	211e      	movs	r1, #30
 80a2e0a:	f7ff fe32 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>
    matrix.show();
 80a2e0e:	f104 001c 	add.w	r0, r4, #28
}
 80a2e12:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

void GFX_showNotFound() {
    matrix.fillScreen(0);
    matrix.drawPixel(29, 7, red);
    matrix.drawPixel(30, 7, red);
    matrix.show();
 80a2e16:	f7fe bcaf 	b.w	80a1778 <_ZN17Adafruit_NeoPixel4showEv>
 80a2e1a:	bf00      	nop
 80a2e1c:	20001378 	.word	0x20001378
 80a2e20:	2000136c 	.word	0x2000136c

080a2e24 <_Z13scrollDisplayv>:
}

void scrollDisplay()
{
 80a2e24:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  static const int smileOffset = 16+8;

  matrix.fillScreen(0);
  matrix.setCursor(scrollPosition, 0);
 80a2e28:	4c3a      	ldr	r4, [pc, #232]	; (80a2f14 <_Z13scrollDisplayv+0xf0>)
    matrix.drawPixel(30, 7, red);
    matrix.show();
}

void scrollDisplay()
{
 80a2e2a:	b085      	sub	sp, #20
  static const int smileOffset = 16+8;

  matrix.fillScreen(0);
 80a2e2c:	2100      	movs	r1, #0
 80a2e2e:	483a      	ldr	r0, [pc, #232]	; (80a2f18 <_Z13scrollDisplayv+0xf4>)
 80a2e30:	f7ff fdee 	bl	80a2a10 <_ZN18Adafruit_NeoMatrix10fillScreenEt>
  matrix.setCursor(scrollPosition, 0);
 80a2e34:	2200      	movs	r2, #0
 80a2e36:	f9b4 1000 	ldrsh.w	r1, [r4]
 80a2e3a:	4837      	ldr	r0, [pc, #220]	; (80a2f18 <_Z13scrollDisplayv+0xf4>)
 80a2e3c:	f7fe fc2d 	bl	80a169a <_ZN12Adafruit_GFX9setCursorEss>
 80a2e40:	4b36      	ldr	r3, [pc, #216]	; (80a2f1c <_Z13scrollDisplayv+0xf8>)
  matrix.print(text);
 80a2e42:	4835      	ldr	r0, [pc, #212]	; (80a2f18 <_Z13scrollDisplayv+0xf4>)
 80a2e44:	6819      	ldr	r1, [r3, #0]
 80a2e46:	2500      	movs	r5, #0
 80a2e48:	f000 ff44 	bl	80a3cd4 <_ZN5Print5printEPKc>

  for (int i = 0; i < textLength/2 + (smileOffset/LED_MATRIX_CHAR_WIDTH)-2; i++) {
 80a2e4c:	462f      	mov	r7, r5
 80a2e4e:	f8df 90dc 	ldr.w	r9, [pc, #220]	; 80a2f2c <_Z13scrollDisplayv+0x108>
 80a2e52:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 80a2f20 <_Z13scrollDisplayv+0xfc>
 80a2e56:	f8d9 1000 	ldr.w	r1, [r9]
 80a2e5a:	2302      	movs	r3, #2
 80a2e5c:	fb91 f3f3 	sdiv	r3, r1, r3
 80a2e60:	3301      	adds	r3, #1
 80a2e62:	429f      	cmp	r7, r3
 80a2e64:	4e2e      	ldr	r6, [pc, #184]	; (80a2f20 <_Z13scrollDisplayv+0xfc>)
 80a2e66:	dc11      	bgt.n	80a2e8c <_Z13scrollDisplayv+0x68>
    matrix.drawBitmap(scrollPosition + i*LED_MATRIX_CHAR_WIDTH*2, 8, fire, 8, 6, colors[0 /*(scrollCount+i)%colorCount*/]);
 80a2e68:	f8b8 3000 	ldrh.w	r3, [r8]
 80a2e6c:	6821      	ldr	r1, [r4, #0]
 80a2e6e:	9302      	str	r3, [sp, #8]
 80a2e70:	4429      	add	r1, r5
 80a2e72:	2208      	movs	r2, #8
 80a2e74:	2306      	movs	r3, #6
 80a2e76:	e88d 000c 	stmia.w	sp, {r2, r3}
 80a2e7a:	b209      	sxth	r1, r1
 80a2e7c:	4b29      	ldr	r3, [pc, #164]	; (80a2f24 <_Z13scrollDisplayv+0x100>)
 80a2e7e:	4826      	ldr	r0, [pc, #152]	; (80a2f18 <_Z13scrollDisplayv+0xf4>)
 80a2e80:	350c      	adds	r5, #12
 80a2e82:	f7fe fafb 	bl	80a147c <_ZN12Adafruit_GFX10drawBitmapEssPKhsst>

  matrix.fillScreen(0);
  matrix.setCursor(scrollPosition, 0);
  matrix.print(text);

  for (int i = 0; i < textLength/2 + (smileOffset/LED_MATRIX_CHAR_WIDTH)-2; i++) {
 80a2e86:	3701      	adds	r7, #1
 80a2e88:	b2ad      	uxth	r5, r5
 80a2e8a:	e7e4      	b.n	80a2e56 <_Z13scrollDisplayv+0x32>
    matrix.drawBitmap(scrollPosition + i*LED_MATRIX_CHAR_WIDTH*2, 8, fire, 8, 6, colors[0 /*(scrollCount+i)%colorCount*/]);
  }

  matrix.drawBitmap(scrollPosition + textLength*LED_MATRIX_CHAR_WIDTH + 8, 0, smile, 16, 8, colors[2]);
 80a2e8c:	6823      	ldr	r3, [r4, #0]
 80a2e8e:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80a2e92:	3308      	adds	r3, #8
 80a2e94:	eb03 0141 	add.w	r1, r3, r1, lsl #1
 80a2e98:	88b3      	ldrh	r3, [r6, #4]
 80a2e9a:	2210      	movs	r2, #16
 80a2e9c:	9302      	str	r3, [sp, #8]
 80a2e9e:	2308      	movs	r3, #8
 80a2ea0:	e88d 000c 	stmia.w	sp, {r2, r3}
 80a2ea4:	b209      	sxth	r1, r1
 80a2ea6:	4b20      	ldr	r3, [pc, #128]	; (80a2f28 <_Z13scrollDisplayv+0x104>)
 80a2ea8:	2200      	movs	r2, #0
 80a2eaa:	481b      	ldr	r0, [pc, #108]	; (80a2f18 <_Z13scrollDisplayv+0xf4>)
 80a2eac:	f7fe fae6 	bl	80a147c <_ZN12Adafruit_GFX10drawBitmapEssPKhsst>

  // Change the text color on the next scroll through
  if (--scrollPosition < -textLength*LED_MATRIX_CHAR_WIDTH - smileOffset) {
 80a2eb0:	4b1e      	ldr	r3, [pc, #120]	; (80a2f2c <_Z13scrollDisplayv+0x108>)
 80a2eb2:	6822      	ldr	r2, [r4, #0]
 80a2eb4:	6819      	ldr	r1, [r3, #0]
 80a2eb6:	f06f 0305 	mvn.w	r3, #5
 80a2eba:	434b      	muls	r3, r1
 80a2ebc:	3a01      	subs	r2, #1
 80a2ebe:	3b18      	subs	r3, #24
 80a2ec0:	429a      	cmp	r2, r3
 80a2ec2:	6022      	str	r2, [r4, #0]
 80a2ec4:	da14      	bge.n	80a2ef0 <_Z13scrollDisplayv+0xcc>
    scrollPosition = matrix.width();
 80a2ec6:	4814      	ldr	r0, [pc, #80]	; (80a2f18 <_Z13scrollDisplayv+0xf4>)
 80a2ec8:	f7fe fbef 	bl	80a16aa <_ZN12Adafruit_GFX5widthEv>
 80a2ecc:	4b11      	ldr	r3, [pc, #68]	; (80a2f14 <_Z13scrollDisplayv+0xf0>)
    if(++scrollCount >= colorCount) scrollCount = 0;
 80a2ece:	4918      	ldr	r1, [pc, #96]	; (80a2f30 <_Z13scrollDisplayv+0x10c>)

  matrix.drawBitmap(scrollPosition + textLength*LED_MATRIX_CHAR_WIDTH + 8, 0, smile, 16, 8, colors[2]);

  // Change the text color on the next scroll through
  if (--scrollPosition < -textLength*LED_MATRIX_CHAR_WIDTH - smileOffset) {
    scrollPosition = matrix.width();
 80a2ed0:	6018      	str	r0, [r3, #0]
    if(++scrollCount >= colorCount) scrollCount = 0;
 80a2ed2:	4b18      	ldr	r3, [pc, #96]	; (80a2f34 <_Z13scrollDisplayv+0x110>)
 80a2ed4:	7809      	ldrb	r1, [r1, #0]
 80a2ed6:	681a      	ldr	r2, [r3, #0]
    matrix.setTextColor(colors[scrollCount]);
 80a2ed8:	480f      	ldr	r0, [pc, #60]	; (80a2f18 <_Z13scrollDisplayv+0xf4>)
  matrix.drawBitmap(scrollPosition + textLength*LED_MATRIX_CHAR_WIDTH + 8, 0, smile, 16, 8, colors[2]);

  // Change the text color on the next scroll through
  if (--scrollPosition < -textLength*LED_MATRIX_CHAR_WIDTH - smileOffset) {
    scrollPosition = matrix.width();
    if(++scrollCount >= colorCount) scrollCount = 0;
 80a2eda:	3201      	adds	r2, #1
 80a2edc:	428a      	cmp	r2, r1
 80a2ede:	601a      	str	r2, [r3, #0]
 80a2ee0:	bfa4      	itt	ge
 80a2ee2:	2200      	movge	r2, #0
 80a2ee4:	601a      	strge	r2, [r3, #0]
    matrix.setTextColor(colors[scrollCount]);
 80a2ee6:	681b      	ldr	r3, [r3, #0]
 80a2ee8:	f836 1013 	ldrh.w	r1, [r6, r3, lsl #1]
 80a2eec:	f7fe fbd8 	bl	80a16a0 <_ZN12Adafruit_GFX12setTextColorEt>
  }

  if (sSet) {
 80a2ef0:	4b11      	ldr	r3, [pc, #68]	; (80a2f38 <_Z13scrollDisplayv+0x114>)
 80a2ef2:	781b      	ldrb	r3, [r3, #0]
 80a2ef4:	b13b      	cbz	r3, 80a2f06 <_Z13scrollDisplayv+0xe2>
    GFX_lightBox(sRow, sCol, sColor);
 80a2ef6:	4b11      	ldr	r3, [pc, #68]	; (80a2f3c <_Z13scrollDisplayv+0x118>)
 80a2ef8:	881a      	ldrh	r2, [r3, #0]
 80a2efa:	4b11      	ldr	r3, [pc, #68]	; (80a2f40 <_Z13scrollDisplayv+0x11c>)
 80a2efc:	6819      	ldr	r1, [r3, #0]
 80a2efe:	4b11      	ldr	r3, [pc, #68]	; (80a2f44 <_Z13scrollDisplayv+0x120>)
 80a2f00:	6818      	ldr	r0, [r3, #0]
 80a2f02:	f7ff ff1b 	bl	80a2d3c <_Z12GFX_lightBoxiit>
  }

  matrix.show();
 80a2f06:	4810      	ldr	r0, [pc, #64]	; (80a2f48 <_Z13scrollDisplayv+0x124>)
  //delay(10);
}
 80a2f08:	b005      	add	sp, #20
 80a2f0a:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}

  if (sSet) {
    GFX_lightBox(sRow, sCol, sColor);
  }

  matrix.show();
 80a2f0e:	f7fe bc33 	b.w	80a1778 <_ZN17Adafruit_NeoPixel4showEv>
 80a2f12:	bf00      	nop
 80a2f14:	2000134c 	.word	0x2000134c
 80a2f18:	20001378 	.word	0x20001378
 80a2f1c:	20001354 	.word	0x20001354
 80a2f20:	20001338 	.word	0x20001338
 80a2f24:	080a6a04 	.word	0x080a6a04
 80a2f28:	080a69b4 	.word	0x080a69b4
 80a2f2c:	200013c8 	.word	0x200013c8
 80a2f30:	20000480 	.word	0x20000480
 80a2f34:	20001370 	.word	0x20001370
 80a2f38:	20001350 	.word	0x20001350
 80a2f3c:	2000136e 	.word	0x2000136e
 80a2f40:	200013c0 	.word	0x200013c0
 80a2f44:	200013bc 	.word	0x200013bc
 80a2f48:	20001394 	.word	0x20001394
 80a2f4c:	00000000 	.word	0x00000000

080a2f50 <_Z16getGradientColorttf>:
  }
}

// weight = 0 -> col0, weight = 0.5 -> 50/50 col0/col1, weight = 1 -> col1
uint16_t getGradientColor(uint16_t col0, uint16_t col1, float value)
{
 80a2f50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  if (r > 0) red = r;
  if (g > 0) green = g;
  if (b > 0) blue = b;

  r = (col1 & 0xF800) >> 8;
 80a2f52:	120d      	asrs	r5, r1, #8
  g = (col1 & 0x07E0) >> 3;
 80a2f54:	10ce      	asrs	r6, r1, #3
  b = (col1 & 0x1F) << 3;

  if (r > 0) red = r;
 80a2f56:	f015 05f8 	ands.w	r5, r5, #248	; 0xf8
  if (g > 0) green = g;
  if (b > 0) blue = b;

  r = (col1 & 0xF800) >> 8;
  g = (col1 & 0x07E0) >> 3;
  b = (col1 & 0x1F) << 3;
 80a2f5a:	ea4f 01c1 	mov.w	r1, r1, lsl #3

// weight = 0 -> col0, weight = 0.5 -> 50/50 col0/col1, weight = 1 -> col1
uint16_t getGradientColor(uint16_t col0, uint16_t col1, float value)
{
  uint8_t red = 0, green = 0, blue = 0;
  uint8_t r = (col0 & 0xF800) >> 8;
 80a2f5e:	bf08      	it	eq
 80a2f60:	1205      	asreq	r5, r0, #8
  if (r > 0) red = r;
  if (g > 0) green = g;
  if (b > 0) blue = b;

  r = (col1 & 0xF800) >> 8;
  g = (col1 & 0x07E0) >> 3;
 80a2f62:	f006 06fc 	and.w	r6, r6, #252	; 0xfc
  }
}

// weight = 0 -> col0, weight = 0.5 -> 50/50 col0/col1, weight = 1 -> col1
uint16_t getGradientColor(uint16_t col0, uint16_t col1, float value)
{
 80a2f66:	4617      	mov	r7, r2
  if (g > 0) green = g;
  if (b > 0) blue = b;

  r = (col1 & 0xF800) >> 8;
  g = (col1 & 0x07E0) >> 3;
  b = (col1 & 0x1F) << 3;
 80a2f68:	b2cc      	uxtb	r4, r1

// weight = 0 -> col0, weight = 0.5 -> 50/50 col0/col1, weight = 1 -> col1
uint16_t getGradientColor(uint16_t col0, uint16_t col1, float value)
{
  uint8_t red = 0, green = 0, blue = 0;
  uint8_t r = (col0 & 0xF800) >> 8;
 80a2f6a:	bf08      	it	eq
 80a2f6c:	f005 05f8 	andeq.w	r5, r5, #248	; 0xf8
  r = (col1 & 0xF800) >> 8;
  g = (col1 & 0x07E0) >> 3;
  b = (col1 & 0x1F) << 3;

  if (r > 0) red = r;
  if (g > 0) green = g;
 80a2f70:	b916      	cbnz	r6, 80a2f78 <_Z16getGradientColorttf+0x28>
// weight = 0 -> col0, weight = 0.5 -> 50/50 col0/col1, weight = 1 -> col1
uint16_t getGradientColor(uint16_t col0, uint16_t col1, float value)
{
  uint8_t red = 0, green = 0, blue = 0;
  uint8_t r = (col0 & 0xF800) >> 8;
  uint8_t g = (col0 & 0x07E0) >> 3;
 80a2f72:	10c6      	asrs	r6, r0, #3
 80a2f74:	f006 06fc 	and.w	r6, r6, #252	; 0xfc
  g = (col1 & 0x07E0) >> 3;
  b = (col1 & 0x1F) << 3;

  if (r > 0) red = r;
  if (g > 0) green = g;
  if (b > 0) blue = b;
 80a2f78:	b90c      	cbnz	r4, 80a2f7e <_Z16getGradientColorttf+0x2e>
uint16_t getGradientColor(uint16_t col0, uint16_t col1, float value)
{
  uint8_t red = 0, green = 0, blue = 0;
  uint8_t r = (col0 & 0xF800) >> 8;
  uint8_t g = (col0 & 0x07E0) >> 3;
  uint8_t b = (col0 & 0x1F) << 3;
 80a2f7a:	00c0      	lsls	r0, r0, #3
 80a2f7c:	b2c4      	uxtb	r4, r0

  if (r > 0) red = r;
  if (g > 0) green = g;
  if (b > 0) blue = b;

  if (red & blue) {
 80a2f7e:	4225      	tst	r5, r4
    red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
 80a2f80:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 80a2f84:	4638      	mov	r0, r7

  if (r > 0) red = r;
  if (g > 0) green = g;
  if (b > 0) blue = b;

  if (red & blue) {
 80a2f86:	d026      	beq.n	80a2fd6 <_Z16getGradientColorttf+0x86>
    red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
 80a2f88:	f002 fd90 	bl	80a5aac <__aeabi_fcmple>
 80a2f8c:	bb08      	cbnz	r0, 80a2fd2 <_Z16getGradientColorttf+0x82>
 80a2f8e:	4638      	mov	r0, r7
 80a2f90:	f001 ffd8 	bl	80a4f44 <__aeabi_f2d>
 80a2f94:	2200      	movs	r2, #0
 80a2f96:	4b48      	ldr	r3, [pc, #288]	; (80a30b8 <_Z16getGradientColorttf+0x168>)
 80a2f98:	f001 fe74 	bl	80a4c84 <__aeabi_dsub>
 80a2f9c:	a344      	add	r3, pc, #272	; (adr r3, 80a30b0 <_Z16getGradientColorttf+0x160>)
 80a2f9e:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a2fa2:	f002 f823 	bl	80a4fec <__aeabi_dmul>
 80a2fa6:	4602      	mov	r2, r0
 80a2fa8:	460b      	mov	r3, r1
 80a2faa:	f001 fe6d 	bl	80a4c88 <__adddf3>
 80a2fae:	4602      	mov	r2, r0
 80a2fb0:	460b      	mov	r3, r1
 80a2fb2:	a13f      	add	r1, pc, #252	; (adr r1, 80a30b0 <_Z16getGradientColorttf+0x160>)
 80a2fb4:	e9d1 0100 	ldrd	r0, r1, [r1]
 80a2fb8:	f001 fe64 	bl	80a4c84 <__aeabi_dsub>
 80a2fbc:	f002 fa50 	bl	80a5460 <__aeabi_d2uiz>
    blue = value <= 0.5 ? 255 * (value*2) : 255;
 80a2fc0:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
  if (r > 0) red = r;
  if (g > 0) green = g;
  if (b > 0) blue = b;

  if (red & blue) {
    red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
 80a2fc4:	b2c5      	uxtb	r5, r0
    blue = value <= 0.5 ? 255 * (value*2) : 255;
 80a2fc6:	4638      	mov	r0, r7
 80a2fc8:	f002 fd70 	bl	80a5aac <__aeabi_fcmple>
 80a2fcc:	2800      	cmp	r0, #0
 80a2fce:	d067      	beq.n	80a30a0 <_Z16getGradientColorttf+0x150>
 80a2fd0:	e059      	b.n	80a3086 <_Z16getGradientColorttf+0x136>
  if (r > 0) red = r;
  if (g > 0) green = g;
  if (b > 0) blue = b;

  if (red & blue) {
    red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
 80a2fd2:	25ff      	movs	r5, #255	; 0xff
 80a2fd4:	e057      	b.n	80a3086 <_Z16getGradientColorttf+0x136>
    blue = value <= 0.5 ? 255 * (value*2) : 255;
  }
  else if (red & green) {
 80a2fd6:	4235      	tst	r5, r6
 80a2fd8:	d030      	beq.n	80a303c <_Z16getGradientColorttf+0xec>
    red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
 80a2fda:	f002 fd67 	bl	80a5aac <__aeabi_fcmple>
 80a2fde:	bb08      	cbnz	r0, 80a3024 <_Z16getGradientColorttf+0xd4>
 80a2fe0:	4638      	mov	r0, r7
 80a2fe2:	f001 ffaf 	bl	80a4f44 <__aeabi_f2d>
 80a2fe6:	2200      	movs	r2, #0
 80a2fe8:	4b33      	ldr	r3, [pc, #204]	; (80a30b8 <_Z16getGradientColorttf+0x168>)
 80a2fea:	f001 fe4b 	bl	80a4c84 <__aeabi_dsub>
 80a2fee:	a330      	add	r3, pc, #192	; (adr r3, 80a30b0 <_Z16getGradientColorttf+0x160>)
 80a2ff0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a2ff4:	f001 fffa 	bl	80a4fec <__aeabi_dmul>
 80a2ff8:	4602      	mov	r2, r0
 80a2ffa:	460b      	mov	r3, r1
 80a2ffc:	f001 fe44 	bl	80a4c88 <__adddf3>
 80a3000:	4602      	mov	r2, r0
 80a3002:	460b      	mov	r3, r1
 80a3004:	a12a      	add	r1, pc, #168	; (adr r1, 80a30b0 <_Z16getGradientColorttf+0x160>)
 80a3006:	e9d1 0100 	ldrd	r0, r1, [r1]
 80a300a:	f001 fe3b 	bl	80a4c84 <__aeabi_dsub>
 80a300e:	f002 fa27 	bl	80a5460 <__aeabi_d2uiz>
    green = value <= 0.5 ? 255 * (value*2) : 255;
 80a3012:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
  if (red & blue) {
    red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
    blue = value <= 0.5 ? 255 * (value*2) : 255;
  }
  else if (red & green) {
    red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
 80a3016:	b2c5      	uxtb	r5, r0
    green = value <= 0.5 ? 255 * (value*2) : 255;
 80a3018:	4638      	mov	r0, r7
 80a301a:	f002 fd47 	bl	80a5aac <__aeabi_fcmple>
 80a301e:	2800      	cmp	r0, #0
 80a3020:	d03c      	beq.n	80a309c <_Z16getGradientColorttf+0x14c>
 80a3022:	e000      	b.n	80a3026 <_Z16getGradientColorttf+0xd6>
  if (red & blue) {
    red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
    blue = value <= 0.5 ? 255 * (value*2) : 255;
  }
  else if (red & green) {
    red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
 80a3024:	25ff      	movs	r5, #255	; 0xff
    green = value <= 0.5 ? 255 * (value*2) : 255;
 80a3026:	4639      	mov	r1, r7
 80a3028:	4638      	mov	r0, r7
 80a302a:	f002 fa8f 	bl	80a554c <__addsf3>
 80a302e:	4923      	ldr	r1, [pc, #140]	; (80a30bc <_Z16getGradientColorttf+0x16c>)
 80a3030:	f002 fb94 	bl	80a575c <__aeabi_fmul>
 80a3034:	f002 fd7e 	bl	80a5b34 <__aeabi_f2uiz>
 80a3038:	b2c6      	uxtb	r6, r0
 80a303a:	e032      	b.n	80a30a2 <_Z16getGradientColorttf+0x152>
  } else { // green & blue
    green = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
 80a303c:	f002 fd36 	bl	80a5aac <__aeabi_fcmple>
 80a3040:	bb00      	cbnz	r0, 80a3084 <_Z16getGradientColorttf+0x134>
 80a3042:	4638      	mov	r0, r7
 80a3044:	f001 ff7e 	bl	80a4f44 <__aeabi_f2d>
 80a3048:	2200      	movs	r2, #0
 80a304a:	4b1b      	ldr	r3, [pc, #108]	; (80a30b8 <_Z16getGradientColorttf+0x168>)
 80a304c:	f001 fe1a 	bl	80a4c84 <__aeabi_dsub>
 80a3050:	a317      	add	r3, pc, #92	; (adr r3, 80a30b0 <_Z16getGradientColorttf+0x160>)
 80a3052:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a3056:	f001 ffc9 	bl	80a4fec <__aeabi_dmul>
 80a305a:	4602      	mov	r2, r0
 80a305c:	460b      	mov	r3, r1
 80a305e:	f001 fe13 	bl	80a4c88 <__adddf3>
 80a3062:	4602      	mov	r2, r0
 80a3064:	460b      	mov	r3, r1
 80a3066:	a112      	add	r1, pc, #72	; (adr r1, 80a30b0 <_Z16getGradientColorttf+0x160>)
 80a3068:	e9d1 0100 	ldrd	r0, r1, [r1]
 80a306c:	f001 fe0a 	bl	80a4c84 <__aeabi_dsub>
 80a3070:	f002 f9f6 	bl	80a5460 <__aeabi_d2uiz>
    blue = value <= 0.5 ? 255 * (value*2) : 255;
 80a3074:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
  }
  else if (red & green) {
    red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
    green = value <= 0.5 ? 255 * (value*2) : 255;
  } else { // green & blue
    green = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
 80a3078:	b2c6      	uxtb	r6, r0
    blue = value <= 0.5 ? 255 * (value*2) : 255;
 80a307a:	4638      	mov	r0, r7
 80a307c:	f002 fd16 	bl	80a5aac <__aeabi_fcmple>
 80a3080:	b170      	cbz	r0, 80a30a0 <_Z16getGradientColorttf+0x150>
 80a3082:	e000      	b.n	80a3086 <_Z16getGradientColorttf+0x136>
  }
  else if (red & green) {
    red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
    green = value <= 0.5 ? 255 * (value*2) : 255;
  } else { // green & blue
    green = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
 80a3084:	26ff      	movs	r6, #255	; 0xff
    blue = value <= 0.5 ? 255 * (value*2) : 255;
 80a3086:	4639      	mov	r1, r7
 80a3088:	4638      	mov	r0, r7
 80a308a:	f002 fa5f 	bl	80a554c <__addsf3>
 80a308e:	490b      	ldr	r1, [pc, #44]	; (80a30bc <_Z16getGradientColorttf+0x16c>)
 80a3090:	f002 fb64 	bl	80a575c <__aeabi_fmul>
 80a3094:	f002 fd4e 	bl	80a5b34 <__aeabi_f2uiz>
 80a3098:	b2c4      	uxtb	r4, r0
 80a309a:	e002      	b.n	80a30a2 <_Z16getGradientColorttf+0x152>
    red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
    blue = value <= 0.5 ? 255 * (value*2) : 255;
  }
  else if (red & green) {
    red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
    green = value <= 0.5 ? 255 * (value*2) : 255;
 80a309c:	26ff      	movs	r6, #255	; 0xff
 80a309e:	e000      	b.n	80a30a2 <_Z16getGradientColorttf+0x152>
  } else { // green & blue
    green = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
    blue = value <= 0.5 ? 255 * (value*2) : 255;
 80a30a0:	24ff      	movs	r4, #255	; 0xff
  }
  return matrix.Color(red, green, blue);
 80a30a2:	4622      	mov	r2, r4
 80a30a4:	4631      	mov	r1, r6
 80a30a6:	4628      	mov	r0, r5
}
 80a30a8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    green = value <= 0.5 ? 255 * (value*2) : 255;
  } else { // green & blue
    green = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
    blue = value <= 0.5 ? 255 * (value*2) : 255;
  }
  return matrix.Color(red, green, blue);
 80a30ac:	f7ff bdce 	b.w	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
 80a30b0:	00000000 	.word	0x00000000
 80a30b4:	406fe000 	.word	0x406fe000
 80a30b8:	3fe00000 	.word	0x3fe00000
 80a30bc:	437f0000 	.word	0x437f0000

080a30c0 <_Z15gradientBetweenttf>:
}

uint16_t gradientBetween(uint16_t col0, uint16_t col1, float value)
{
 80a30c0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a30c4:	1204      	asrs	r4, r0, #8
 80a30c6:	ea4f 0ae0 	mov.w	sl, r0, asr #3
 80a30ca:	00c0      	lsls	r0, r0, #3
 80a30cc:	b2c0      	uxtb	r0, r0
 80a30ce:	271f      	movs	r7, #31
 80a30d0:	ebc0 2000 	rsb	r0, r0, r0, lsl #8
 80a30d4:	fb90 f6f7 	sdiv	r6, r0, r7

  uint8_t red = (r1-r0) * value + r0;
  uint8_t green = (g1-g0) * value + g0;
  uint8_t blue = (b1-b0) * value + b0;

  return matrix.Color(red, green, blue);
 80a30d8:	00c8      	lsls	r0, r1, #3
 80a30da:	b2c0      	uxtb	r0, r0
 80a30dc:	ebc0 2000 	rsb	r0, r0, r0, lsl #8
 80a30e0:	fb90 f0f7 	sdiv	r0, r0, r7
  }
  return matrix.Color(red, green, blue);
}

uint16_t gradientBetween(uint16_t col0, uint16_t col1, float value)
{
 80a30e4:	4615      	mov	r5, r2
 80a30e6:	b2f6      	uxtb	r6, r6

  uint8_t red = (r1-r0) * value + r0;
  uint8_t green = (g1-g0) * value + g0;
  uint8_t blue = (b1-b0) * value + b0;

  return matrix.Color(red, green, blue);
 80a30e8:	b2c0      	uxtb	r0, r0
 80a30ea:	1b80      	subs	r0, r0, r6
  }
  return matrix.Color(red, green, blue);
}

uint16_t gradientBetween(uint16_t col0, uint16_t col1, float value)
{
 80a30ec:	4689      	mov	r9, r1

  uint8_t red = (r1-r0) * value + r0;
  uint8_t green = (g1-g0) * value + g0;
  uint8_t blue = (b1-b0) * value + b0;

  return matrix.Color(red, green, blue);
 80a30ee:	f002 fae1 	bl	80a56b4 <__aeabi_i2f>
 80a30f2:	4629      	mov	r1, r5
 80a30f4:	f002 fb32 	bl	80a575c <__aeabi_fmul>
 80a30f8:	4680      	mov	r8, r0
 80a30fa:	4630      	mov	r0, r6
 80a30fc:	f002 fada 	bl	80a56b4 <__aeabi_i2f>
 80a3100:	4601      	mov	r1, r0
 80a3102:	4640      	mov	r0, r8
 80a3104:	f002 fa22 	bl	80a554c <__addsf3>
 80a3108:	f002 fd14 	bl	80a5b34 <__aeabi_f2uiz>
 80a310c:	fa5f f880 	uxtb.w	r8, r0
 80a3110:	ea4f 00e9 	mov.w	r0, r9, asr #3
 80a3114:	f00a 0afc 	and.w	sl, sl, #252	; 0xfc
 80a3118:	f000 00fc 	and.w	r0, r0, #252	; 0xfc
 80a311c:	f04f 0b3f 	mov.w	fp, #63	; 0x3f
 80a3120:	ebca 2a0a 	rsb	sl, sl, sl, lsl #8
 80a3124:	ebc0 2000 	rsb	r0, r0, r0, lsl #8
 80a3128:	fb9a fafb 	sdiv	sl, sl, fp
 80a312c:	fb90 f0fb 	sdiv	r0, r0, fp
 80a3130:	fa5f fa8a 	uxtb.w	sl, sl
 80a3134:	b2c0      	uxtb	r0, r0
 80a3136:	ebca 0000 	rsb	r0, sl, r0
 80a313a:	f002 fabb 	bl	80a56b4 <__aeabi_i2f>
 80a313e:	4629      	mov	r1, r5
 80a3140:	f002 fb0c 	bl	80a575c <__aeabi_fmul>
 80a3144:	4606      	mov	r6, r0
 80a3146:	4650      	mov	r0, sl
 80a3148:	f002 fab4 	bl	80a56b4 <__aeabi_i2f>
 80a314c:	4601      	mov	r1, r0
 80a314e:	4630      	mov	r0, r6
 80a3150:	f002 f9fc 	bl	80a554c <__addsf3>
 80a3154:	f002 fcee 	bl	80a5b34 <__aeabi_f2uiz>
 80a3158:	ea4f 2129 	mov.w	r1, r9, asr #8
 80a315c:	f001 01f8 	and.w	r1, r1, #248	; 0xf8
 80a3160:	f004 04f8 	and.w	r4, r4, #248	; 0xf8
 80a3164:	b2c6      	uxtb	r6, r0
 80a3166:	ebc4 2404 	rsb	r4, r4, r4, lsl #8
 80a316a:	ebc1 2001 	rsb	r0, r1, r1, lsl #8
 80a316e:	fb94 f4f7 	sdiv	r4, r4, r7
 80a3172:	fb90 f0f7 	sdiv	r0, r0, r7
 80a3176:	b2e4      	uxtb	r4, r4
 80a3178:	b2c0      	uxtb	r0, r0
 80a317a:	1b00      	subs	r0, r0, r4
 80a317c:	f002 fa9a 	bl	80a56b4 <__aeabi_i2f>
 80a3180:	4629      	mov	r1, r5
 80a3182:	f002 faeb 	bl	80a575c <__aeabi_fmul>
 80a3186:	4605      	mov	r5, r0
 80a3188:	4620      	mov	r0, r4
 80a318a:	f002 fa93 	bl	80a56b4 <__aeabi_i2f>
 80a318e:	4601      	mov	r1, r0
 80a3190:	4628      	mov	r0, r5
 80a3192:	f002 f9db 	bl	80a554c <__addsf3>
 80a3196:	f002 fccd 	bl	80a5b34 <__aeabi_f2uiz>
 80a319a:	4642      	mov	r2, r8
 80a319c:	4631      	mov	r1, r6
}
 80a319e:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint8_t red = (r1-r0) * value + r0;
  uint8_t green = (g1-g0) * value + g0;
  uint8_t blue = (b1-b0) * value + b0;

  return matrix.Color(red, green, blue);
 80a31a2:	b2c0      	uxtb	r0, r0
 80a31a4:	f7ff bd52 	b.w	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>

080a31a8 <_Z16getGreenRedValuef>:
}

// 0.0 = Red, 0.5 = Yellow, 1.0 = Green
uint16_t getGreenRedValue(float value)
{
 80a31a8:	b538      	push	{r3, r4, r5, lr}
  int red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
 80a31aa:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
  return matrix.Color(red, green, blue);
}

// 0.0 = Red, 0.5 = Yellow, 1.0 = Green
uint16_t getGreenRedValue(float value)
{
 80a31ae:	4604      	mov	r4, r0
  int red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
 80a31b0:	f002 fc7c 	bl	80a5aac <__aeabi_fcmple>
 80a31b4:	bb00      	cbnz	r0, 80a31f8 <_Z16getGreenRedValuef+0x50>
 80a31b6:	4620      	mov	r0, r4
 80a31b8:	f001 fec4 	bl	80a4f44 <__aeabi_f2d>
 80a31bc:	2200      	movs	r2, #0
 80a31be:	4b1a      	ldr	r3, [pc, #104]	; (80a3228 <_Z16getGreenRedValuef+0x80>)
 80a31c0:	f001 fd60 	bl	80a4c84 <__aeabi_dsub>
 80a31c4:	a316      	add	r3, pc, #88	; (adr r3, 80a3220 <_Z16getGreenRedValuef+0x78>)
 80a31c6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a31ca:	f001 ff0f 	bl	80a4fec <__aeabi_dmul>
 80a31ce:	4602      	mov	r2, r0
 80a31d0:	460b      	mov	r3, r1
 80a31d2:	f001 fd59 	bl	80a4c88 <__adddf3>
 80a31d6:	4602      	mov	r2, r0
 80a31d8:	460b      	mov	r3, r1
 80a31da:	a111      	add	r1, pc, #68	; (adr r1, 80a3220 <_Z16getGreenRedValuef+0x78>)
 80a31dc:	e9d1 0100 	ldrd	r0, r1, [r1]
 80a31e0:	f001 fd50 	bl	80a4c84 <__aeabi_dsub>
 80a31e4:	f002 f914 	bl	80a5410 <__aeabi_d2iz>
  int green = value <= 0.5 ? 255 * (value*2) : 255;
 80a31e8:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
}

// 0.0 = Red, 0.5 = Yellow, 1.0 = Green
uint16_t getGreenRedValue(float value)
{
  int red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
 80a31ec:	4605      	mov	r5, r0
  int green = value <= 0.5 ? 255 * (value*2) : 255;
 80a31ee:	4620      	mov	r0, r4
 80a31f0:	f002 fc5c 	bl	80a5aac <__aeabi_fcmple>
 80a31f4:	b158      	cbz	r0, 80a320e <_Z16getGreenRedValuef+0x66>
 80a31f6:	e000      	b.n	80a31fa <_Z16getGreenRedValuef+0x52>
}

// 0.0 = Red, 0.5 = Yellow, 1.0 = Green
uint16_t getGreenRedValue(float value)
{
  int red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
 80a31f8:	25ff      	movs	r5, #255	; 0xff
  int green = value <= 0.5 ? 255 * (value*2) : 255;
 80a31fa:	4621      	mov	r1, r4
 80a31fc:	4620      	mov	r0, r4
 80a31fe:	f002 f9a5 	bl	80a554c <__addsf3>
 80a3202:	490a      	ldr	r1, [pc, #40]	; (80a322c <_Z16getGreenRedValuef+0x84>)
 80a3204:	f002 faaa 	bl	80a575c <__aeabi_fmul>
 80a3208:	f002 fc6e 	bl	80a5ae8 <__aeabi_f2iz>
 80a320c:	e000      	b.n	80a3210 <_Z16getGreenRedValuef+0x68>
 80a320e:	20ff      	movs	r0, #255	; 0xff
  return matrix.Color(red, green, 0);
 80a3210:	b2c1      	uxtb	r1, r0
 80a3212:	2200      	movs	r2, #0
 80a3214:	b2e8      	uxtb	r0, r5
}
 80a3216:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
// 0.0 = Red, 0.5 = Yellow, 1.0 = Green
uint16_t getGreenRedValue(float value)
{
  int red = value <= 0.5 ? 255 : (255 - 255*(value-0.5)*2);
  int green = value <= 0.5 ? 255 * (value*2) : 255;
  return matrix.Color(red, green, 0);
 80a321a:	f7ff bd17 	b.w	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
 80a321e:	bf00      	nop
 80a3220:	00000000 	.word	0x00000000
 80a3224:	406fe000 	.word	0x406fe000
 80a3228:	3fe00000 	.word	0x3fe00000
 80a322c:	437f0000 	.word	0x437f0000

080a3230 <_Z20greenRedGradientTestv>:
}

void greenRedGradientTest()
{
 80a3230:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  int row = 0;

  matrix.fillScreen(0);
 80a3234:	2100      	movs	r1, #0
 80a3236:	4880      	ldr	r0, [pc, #512]	; (80a3438 <_Z20greenRedGradientTestv+0x208>)
 80a3238:	f7ff fbea 	bl	80a2a10 <_ZN18Adafruit_NeoMatrix10fillScreenEt>

  for (int i = 0; i < LED_COLS; i++)
 80a323c:	2400      	movs	r4, #0
  {
    int red = min(255 * (((float)i)/LED_COLS_HALF), 255);
 80a323e:	4620      	mov	r0, r4
 80a3240:	f002 fa38 	bl	80a56b4 <__aeabi_i2f>
 80a3244:	497d      	ldr	r1, [pc, #500]	; (80a343c <_Z20greenRedGradientTestv+0x20c>)
 80a3246:	f002 fb3d 	bl	80a58c4 <__aeabi_fdiv>
 80a324a:	497d      	ldr	r1, [pc, #500]	; (80a3440 <_Z20greenRedGradientTestv+0x210>)
 80a324c:	f002 fa86 	bl	80a575c <__aeabi_fmul>
max (T a, U b) { return ((a)>(b)?(a):(b)); }

template <typename T, typename U>
static inline
typename std::common_type<T, U>::type
min (T a, U b) { return static_cast<typename std::common_type<T, U>::type>((a)<(b)?(a):(b)); }
 80a3250:	497b      	ldr	r1, [pc, #492]	; (80a3440 <_Z20greenRedGradientTestv+0x210>)
 80a3252:	4605      	mov	r5, r0
 80a3254:	f002 fc20 	bl	80a5a98 <__aeabi_fcmplt>
 80a3258:	b900      	cbnz	r0, 80a325c <_Z20greenRedGradientTestv+0x2c>
 80a325a:	4d79      	ldr	r5, [pc, #484]	; (80a3440 <_Z20greenRedGradientTestv+0x210>)
 80a325c:	4628      	mov	r0, r5
 80a325e:	f002 fc43 	bl	80a5ae8 <__aeabi_f2iz>
    int green = (i < LED_COLS_HALF) ? 255 : (255 - 255*(((float)(i - LED_COLS_HALF))/LED_COLS_HALF));
 80a3262:	2c1d      	cmp	r4, #29

  matrix.fillScreen(0);

  for (int i = 0; i < LED_COLS; i++)
  {
    int red = min(255 * (((float)i)/LED_COLS_HALF), 255);
 80a3264:	4606      	mov	r6, r0
    int green = (i < LED_COLS_HALF) ? 255 : (255 - 255*(((float)(i - LED_COLS_HALF))/LED_COLS_HALF));
 80a3266:	dd11      	ble.n	80a328c <_Z20greenRedGradientTestv+0x5c>
 80a3268:	f1a4 001e 	sub.w	r0, r4, #30
 80a326c:	f002 fa22 	bl	80a56b4 <__aeabi_i2f>
 80a3270:	4972      	ldr	r1, [pc, #456]	; (80a343c <_Z20greenRedGradientTestv+0x20c>)
 80a3272:	f002 fb27 	bl	80a58c4 <__aeabi_fdiv>
 80a3276:	4972      	ldr	r1, [pc, #456]	; (80a3440 <_Z20greenRedGradientTestv+0x210>)
 80a3278:	f002 fa70 	bl	80a575c <__aeabi_fmul>
 80a327c:	4601      	mov	r1, r0
 80a327e:	4870      	ldr	r0, [pc, #448]	; (80a3440 <_Z20greenRedGradientTestv+0x210>)
 80a3280:	f002 f962 	bl	80a5548 <__aeabi_fsub>
 80a3284:	f002 fc30 	bl	80a5ae8 <__aeabi_f2iz>
 80a3288:	4605      	mov	r5, r0
 80a328a:	e000      	b.n	80a328e <_Z20greenRedGradientTestv+0x5e>
 80a328c:	25ff      	movs	r5, #255	; 0xff
    matrix.drawPixel(i, row, matrix.Color(red, 0, 0));
 80a328e:	2200      	movs	r2, #0
 80a3290:	b2f6      	uxtb	r6, r6
 80a3292:	4611      	mov	r1, r2
 80a3294:	4630      	mov	r0, r6
 80a3296:	f7ff fcd9 	bl	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
 80a329a:	b227      	sxth	r7, r4
 80a329c:	4603      	mov	r3, r0
 80a329e:	2200      	movs	r2, #0
 80a32a0:	4639      	mov	r1, r7
 80a32a2:	4865      	ldr	r0, [pc, #404]	; (80a3438 <_Z20greenRedGradientTestv+0x208>)
 80a32a4:	f7ff fbe5 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>
    matrix.drawPixel(i, row+1, matrix.Color(0, green, 0));
 80a32a8:	b2ed      	uxtb	r5, r5
 80a32aa:	2200      	movs	r2, #0
 80a32ac:	4629      	mov	r1, r5
 80a32ae:	4610      	mov	r0, r2
 80a32b0:	f7ff fccc 	bl	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
 80a32b4:	2201      	movs	r2, #1
 80a32b6:	4603      	mov	r3, r0
 80a32b8:	4639      	mov	r1, r7
 80a32ba:	485f      	ldr	r0, [pc, #380]	; (80a3438 <_Z20greenRedGradientTestv+0x208>)
 80a32bc:	f7ff fbd9 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>
    matrix.drawPixel(i, row+2, matrix.Color(red, green, 0));
 80a32c0:	2200      	movs	r2, #0
 80a32c2:	4629      	mov	r1, r5
 80a32c4:	4630      	mov	r0, r6
 80a32c6:	f7ff fcc1 	bl	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
{
  int row = 0;

  matrix.fillScreen(0);

  for (int i = 0; i < LED_COLS; i++)
 80a32ca:	3401      	adds	r4, #1
  {
    int red = min(255 * (((float)i)/LED_COLS_HALF), 255);
    int green = (i < LED_COLS_HALF) ? 255 : (255 - 255*(((float)(i - LED_COLS_HALF))/LED_COLS_HALF));
    matrix.drawPixel(i, row, matrix.Color(red, 0, 0));
    matrix.drawPixel(i, row+1, matrix.Color(0, green, 0));
    matrix.drawPixel(i, row+2, matrix.Color(red, green, 0));
 80a32cc:	4603      	mov	r3, r0
 80a32ce:	2202      	movs	r2, #2
 80a32d0:	4639      	mov	r1, r7
 80a32d2:	4859      	ldr	r0, [pc, #356]	; (80a3438 <_Z20greenRedGradientTestv+0x208>)
 80a32d4:	f7ff fbcd 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>
{
  int row = 0;

  matrix.fillScreen(0);

  for (int i = 0; i < LED_COLS; i++)
 80a32d8:	2c3c      	cmp	r4, #60	; 0x3c
 80a32da:	d1b0      	bne.n	80a323e <_Z20greenRedGradientTestv+0xe>
 80a32dc:	2400      	movs	r4, #0
    matrix.drawPixel(i, row+2, matrix.Color(red, green, 0));
  }

  for (int i = 0; i < LED_COLS; i++)
  {
    matrix.drawPixel(i, row+3, getGreenRedValue(((float)i)/LED_COLS));
 80a32de:	4620      	mov	r0, r4
 80a32e0:	f002 f9e8 	bl	80a56b4 <__aeabi_i2f>
 80a32e4:	4957      	ldr	r1, [pc, #348]	; (80a3444 <_Z20greenRedGradientTestv+0x214>)
 80a32e6:	f002 faed 	bl	80a58c4 <__aeabi_fdiv>
 80a32ea:	f7ff ff5d 	bl	80a31a8 <_Z16getGreenRedValuef>
 80a32ee:	b221      	sxth	r1, r4
 80a32f0:	4603      	mov	r3, r0
 80a32f2:	2203      	movs	r2, #3
 80a32f4:	4850      	ldr	r0, [pc, #320]	; (80a3438 <_Z20greenRedGradientTestv+0x208>)
    matrix.drawPixel(i, row, matrix.Color(red, 0, 0));
    matrix.drawPixel(i, row+1, matrix.Color(0, green, 0));
    matrix.drawPixel(i, row+2, matrix.Color(red, green, 0));
  }

  for (int i = 0; i < LED_COLS; i++)
 80a32f6:	3401      	adds	r4, #1
  {
    matrix.drawPixel(i, row+3, getGreenRedValue(((float)i)/LED_COLS));
 80a32f8:	f7ff fbbb 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>
    matrix.drawPixel(i, row, matrix.Color(red, 0, 0));
    matrix.drawPixel(i, row+1, matrix.Color(0, green, 0));
    matrix.drawPixel(i, row+2, matrix.Color(red, green, 0));
  }

  for (int i = 0; i < LED_COLS; i++)
 80a32fc:	2c3c      	cmp	r4, #60	; 0x3c
 80a32fe:	d1ee      	bne.n	80a32de <_Z20greenRedGradientTestv+0xae>
    matrix.drawPixel(i, row+3, getGreenRedValue(((float)i)/LED_COLS));
  }

  for (int i = 0; i < LED_COLS; i++)
  {
    matrix.drawPixel(i, row+4, getGradientColor(green, blue, ((float)i)/LED_COLS));
 80a3300:	4f51      	ldr	r7, [pc, #324]	; (80a3448 <_Z20greenRedGradientTestv+0x218>)
 80a3302:	2600      	movs	r6, #0
 80a3304:	4630      	mov	r0, r6
 80a3306:	f002 f9d5 	bl	80a56b4 <__aeabi_i2f>
 80a330a:	494e      	ldr	r1, [pc, #312]	; (80a3444 <_Z20greenRedGradientTestv+0x214>)
 80a330c:	f002 fada 	bl	80a58c4 <__aeabi_fdiv>
 80a3310:	f8df 9144 	ldr.w	r9, [pc, #324]	; 80a3458 <_Z20greenRedGradientTestv+0x228>
 80a3314:	4605      	mov	r5, r0
 80a3316:	4602      	mov	r2, r0
 80a3318:	8839      	ldrh	r1, [r7, #0]
 80a331a:	f8b9 0000 	ldrh.w	r0, [r9]
 80a331e:	f7ff fe17 	bl	80a2f50 <_Z16getGradientColorttf>
 80a3322:	b234      	sxth	r4, r6
 80a3324:	4603      	mov	r3, r0
 80a3326:	2204      	movs	r2, #4
 80a3328:	4621      	mov	r1, r4
 80a332a:	4843      	ldr	r0, [pc, #268]	; (80a3438 <_Z20greenRedGradientTestv+0x208>)
 80a332c:	f7ff fba1 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>
    matrix.drawPixel(i, row+5, gradientBetween(green, blue, ((float)i)/LED_COLS));
 80a3330:	462a      	mov	r2, r5
 80a3332:	8839      	ldrh	r1, [r7, #0]
 80a3334:	f8b9 0000 	ldrh.w	r0, [r9]
 80a3338:	f7ff fec2 	bl	80a30c0 <_Z15gradientBetweenttf>

    matrix.drawPixel(i, row+6, getGradientColor(blue, red, ((float)i)/LED_COLS));
 80a333c:	f8df 811c 	ldr.w	r8, [pc, #284]	; 80a345c <_Z20greenRedGradientTestv+0x22c>
  }

  for (int i = 0; i < LED_COLS; i++)
  {
    matrix.drawPixel(i, row+4, getGradientColor(green, blue, ((float)i)/LED_COLS));
    matrix.drawPixel(i, row+5, gradientBetween(green, blue, ((float)i)/LED_COLS));
 80a3340:	4603      	mov	r3, r0
 80a3342:	2205      	movs	r2, #5
 80a3344:	4621      	mov	r1, r4
 80a3346:	483c      	ldr	r0, [pc, #240]	; (80a3438 <_Z20greenRedGradientTestv+0x208>)
 80a3348:	f7ff fb93 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>

    matrix.drawPixel(i, row+6, getGradientColor(blue, red, ((float)i)/LED_COLS));
 80a334c:	f8b8 1000 	ldrh.w	r1, [r8]
 80a3350:	462a      	mov	r2, r5
 80a3352:	8838      	ldrh	r0, [r7, #0]
 80a3354:	f7ff fdfc 	bl	80a2f50 <_Z16getGradientColorttf>
 80a3358:	2206      	movs	r2, #6
 80a335a:	4603      	mov	r3, r0
 80a335c:	4621      	mov	r1, r4
 80a335e:	4836      	ldr	r0, [pc, #216]	; (80a3438 <_Z20greenRedGradientTestv+0x208>)
 80a3360:	f7ff fb87 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>
    matrix.drawPixel(i, row+7, gradientBetween(red, blue, ((float)i)/LED_COLS));
 80a3364:	462a      	mov	r2, r5
 80a3366:	8839      	ldrh	r1, [r7, #0]
 80a3368:	f8b8 0000 	ldrh.w	r0, [r8]
 80a336c:	f7ff fea8 	bl	80a30c0 <_Z15gradientBetweenttf>
 80a3370:	2207      	movs	r2, #7
 80a3372:	4603      	mov	r3, r0
 80a3374:	4621      	mov	r1, r4
 80a3376:	4830      	ldr	r0, [pc, #192]	; (80a3438 <_Z20greenRedGradientTestv+0x208>)
 80a3378:	f7ff fb7b 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>

    matrix.drawPixel(i, row+8, getGradientColor(red, green, ((float)i)/LED_COLS));
 80a337c:	f8b9 1000 	ldrh.w	r1, [r9]
 80a3380:	462a      	mov	r2, r5
 80a3382:	f8b8 0000 	ldrh.w	r0, [r8]
 80a3386:	f7ff fde3 	bl	80a2f50 <_Z16getGradientColorttf>
 80a338a:	2208      	movs	r2, #8
 80a338c:	4603      	mov	r3, r0
 80a338e:	4621      	mov	r1, r4
 80a3390:	4829      	ldr	r0, [pc, #164]	; (80a3438 <_Z20greenRedGradientTestv+0x208>)
 80a3392:	f7ff fb6e 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>
    matrix.drawPixel(i, row+9, gradientBetween(red, green, ((float)i)/LED_COLS));
 80a3396:	f8b9 1000 	ldrh.w	r1, [r9]
 80a339a:	462a      	mov	r2, r5
 80a339c:	f8b8 0000 	ldrh.w	r0, [r8]
 80a33a0:	f7ff fe8e 	bl	80a30c0 <_Z15gradientBetweenttf>

    // matrix.drawPixel(i, row+9, betterGradient(green, blue, ((float)i)/LED_COLS));
    // matrix.drawPixel(i, row+10, betterGradient(blue, red, ((float)i)/LED_COLS));
    // matrix.drawPixel(i, row+11, betterGradient(red, green, ((float)i)/LED_COLS));
    matrix.drawPixel(i, row+10, getGradientColor(cyan, orange, ((float)i)/LED_COLS));
 80a33a4:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 80a3460 <_Z20greenRedGradientTestv+0x230>
 80a33a8:	f8df 90b8 	ldr.w	r9, [pc, #184]	; 80a3464 <_Z20greenRedGradientTestv+0x234>

    matrix.drawPixel(i, row+6, getGradientColor(blue, red, ((float)i)/LED_COLS));
    matrix.drawPixel(i, row+7, gradientBetween(red, blue, ((float)i)/LED_COLS));

    matrix.drawPixel(i, row+8, getGradientColor(red, green, ((float)i)/LED_COLS));
    matrix.drawPixel(i, row+9, gradientBetween(red, green, ((float)i)/LED_COLS));
 80a33ac:	4603      	mov	r3, r0
 80a33ae:	2209      	movs	r2, #9
 80a33b0:	4621      	mov	r1, r4
 80a33b2:	4821      	ldr	r0, [pc, #132]	; (80a3438 <_Z20greenRedGradientTestv+0x208>)
 80a33b4:	f7ff fb5d 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>

    // matrix.drawPixel(i, row+9, betterGradient(green, blue, ((float)i)/LED_COLS));
    // matrix.drawPixel(i, row+10, betterGradient(blue, red, ((float)i)/LED_COLS));
    // matrix.drawPixel(i, row+11, betterGradient(red, green, ((float)i)/LED_COLS));
    matrix.drawPixel(i, row+10, getGradientColor(cyan, orange, ((float)i)/LED_COLS));
 80a33b8:	462a      	mov	r2, r5
 80a33ba:	f8b8 1000 	ldrh.w	r1, [r8]
 80a33be:	f8b9 0000 	ldrh.w	r0, [r9]
 80a33c2:	f7ff fdc5 	bl	80a2f50 <_Z16getGradientColorttf>
 80a33c6:	220a      	movs	r2, #10
 80a33c8:	4603      	mov	r3, r0
 80a33ca:	4621      	mov	r1, r4
 80a33cc:	481a      	ldr	r0, [pc, #104]	; (80a3438 <_Z20greenRedGradientTestv+0x208>)
 80a33ce:	f7ff fb50 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>
    matrix.drawPixel(i, row+11, gradientBetween(cyan, orange, ((float)i)/LED_COLS));
 80a33d2:	462a      	mov	r2, r5
 80a33d4:	f8b8 1000 	ldrh.w	r1, [r8]
 80a33d8:	f8b9 0000 	ldrh.w	r0, [r9]
 80a33dc:	f7ff fe70 	bl	80a30c0 <_Z15gradientBetweenttf>
 80a33e0:	220b      	movs	r2, #11
 80a33e2:	4603      	mov	r3, r0
 80a33e4:	4621      	mov	r1, r4
 80a33e6:	4814      	ldr	r0, [pc, #80]	; (80a3438 <_Z20greenRedGradientTestv+0x208>)
 80a33e8:	f7ff fb43 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>
    matrix.drawPixel(i, row+12, gradientBetween(purple, orange, ((float)i)/LED_COLS));
 80a33ec:	4b17      	ldr	r3, [pc, #92]	; (80a344c <_Z20greenRedGradientTestv+0x21c>)
 80a33ee:	462a      	mov	r2, r5
 80a33f0:	f8b8 1000 	ldrh.w	r1, [r8]
 80a33f4:	8818      	ldrh	r0, [r3, #0]
 80a33f6:	f7ff fe63 	bl	80a30c0 <_Z15gradientBetweenttf>
 80a33fa:	220c      	movs	r2, #12
 80a33fc:	4603      	mov	r3, r0
 80a33fe:	4621      	mov	r1, r4
 80a3400:	480d      	ldr	r0, [pc, #52]	; (80a3438 <_Z20greenRedGradientTestv+0x208>)
 80a3402:	f7ff fb36 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>
    matrix.drawPixel(i, row+13, gradientBetween(white, blue, ((float)i)/LED_COLS));
 80a3406:	4b12      	ldr	r3, [pc, #72]	; (80a3450 <_Z20greenRedGradientTestv+0x220>)
 80a3408:	462a      	mov	r2, r5
 80a340a:	8839      	ldrh	r1, [r7, #0]
 80a340c:	8818      	ldrh	r0, [r3, #0]
 80a340e:	f7ff fe57 	bl	80a30c0 <_Z15gradientBetweenttf>
  for (int i = 0; i < LED_COLS; i++)
  {
    matrix.drawPixel(i, row+3, getGreenRedValue(((float)i)/LED_COLS));
  }

  for (int i = 0; i < LED_COLS; i++)
 80a3412:	3601      	adds	r6, #1
    // matrix.drawPixel(i, row+10, betterGradient(blue, red, ((float)i)/LED_COLS));
    // matrix.drawPixel(i, row+11, betterGradient(red, green, ((float)i)/LED_COLS));
    matrix.drawPixel(i, row+10, getGradientColor(cyan, orange, ((float)i)/LED_COLS));
    matrix.drawPixel(i, row+11, gradientBetween(cyan, orange, ((float)i)/LED_COLS));
    matrix.drawPixel(i, row+12, gradientBetween(purple, orange, ((float)i)/LED_COLS));
    matrix.drawPixel(i, row+13, gradientBetween(white, blue, ((float)i)/LED_COLS));
 80a3414:	4603      	mov	r3, r0
 80a3416:	220d      	movs	r2, #13
 80a3418:	4621      	mov	r1, r4
 80a341a:	4807      	ldr	r0, [pc, #28]	; (80a3438 <_Z20greenRedGradientTestv+0x208>)
 80a341c:	f7ff fb29 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>
  for (int i = 0; i < LED_COLS; i++)
  {
    matrix.drawPixel(i, row+3, getGreenRedValue(((float)i)/LED_COLS));
  }

  for (int i = 0; i < LED_COLS; i++)
 80a3420:	2e3c      	cmp	r6, #60	; 0x3c
 80a3422:	f47f af6f 	bne.w	80a3304 <_Z20greenRedGradientTestv+0xd4>
    matrix.drawPixel(i, row+11, gradientBetween(cyan, orange, ((float)i)/LED_COLS));
    matrix.drawPixel(i, row+12, gradientBetween(purple, orange, ((float)i)/LED_COLS));
    matrix.drawPixel(i, row+13, gradientBetween(white, blue, ((float)i)/LED_COLS));
  }

  matrix.show();
 80a3426:	480b      	ldr	r0, [pc, #44]	; (80a3454 <_Z20greenRedGradientTestv+0x224>)
 80a3428:	f7fe f9a6 	bl	80a1778 <_ZN17Adafruit_NeoPixel4showEv>

  delay(1000);
}
 80a342c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    matrix.drawPixel(i, row+13, gradientBetween(white, blue, ((float)i)/LED_COLS));
  }

  matrix.show();

  delay(1000);
 80a3430:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a3434:	f000 bd16 	b.w	80a3e64 <delay>
 80a3438:	20001378 	.word	0x20001378
 80a343c:	41f00000 	.word	0x41f00000
 80a3440:	437f0000 	.word	0x437f0000
 80a3444:	42700000 	.word	0x42700000
 80a3448:	20001336 	.word	0x20001336
 80a344c:	200013c4 	.word	0x200013c4
 80a3450:	2000136a 	.word	0x2000136a
 80a3454:	20001394 	.word	0x20001394
 80a3458:	20001344 	.word	0x20001344
 80a345c:	2000136c 	.word	0x2000136c
 80a3460:	20001376 	.word	0x20001376
 80a3464:	20001368 	.word	0x20001368

080a3468 <_Z5Wheelh>:
}

// Borrowed from: https://learn.adafruit.com/multi-tasking-the-arduino-part-3/utility-functions
uint32_t Wheel(uint8_t WheelPos)
{
  WheelPos = 255 - WheelPos;
 80a3468:	43c0      	mvns	r0, r0
 80a346a:	b2c0      	uxtb	r0, r0
  if(WheelPos < 85) {
 80a346c:	2854      	cmp	r0, #84	; 0x54
  delay(1000);
}

// Borrowed from: https://learn.adafruit.com/multi-tasking-the-arduino-part-3/utility-functions
uint32_t Wheel(uint8_t WheelPos)
{
 80a346e:	b508      	push	{r3, lr}
  WheelPos = 255 - WheelPos;
  if(WheelPos < 85) {
 80a3470:	d80a      	bhi.n	80a3488 <_Z5Wheelh+0x20>
    return matrix.Color(255 - WheelPos * 3, 0, WheelPos * 3);
 80a3472:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 80a3476:	eba0 0080 	sub.w	r0, r0, r0, lsl #2
 80a347a:	3801      	subs	r0, #1
 80a347c:	b2d2      	uxtb	r2, r2
 80a347e:	2100      	movs	r1, #0
 80a3480:	b2c0      	uxtb	r0, r0
 80a3482:	f7ff fbe3 	bl	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
 80a3486:	bd08      	pop	{r3, pc}
  }
  if(WheelPos < 170) {
 80a3488:	28a9      	cmp	r0, #169	; 0xa9
 80a348a:	d80c      	bhi.n	80a34a6 <_Z5Wheelh+0x3e>
    WheelPos -= 85;
 80a348c:	3855      	subs	r0, #85	; 0x55
 80a348e:	b2c1      	uxtb	r1, r0
    return matrix.Color(0, WheelPos * 3, 255 - WheelPos * 3);
 80a3490:	eba1 0281 	sub.w	r2, r1, r1, lsl #2
 80a3494:	3a01      	subs	r2, #1
 80a3496:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80a349a:	b2d2      	uxtb	r2, r2
 80a349c:	b2c9      	uxtb	r1, r1
 80a349e:	2000      	movs	r0, #0
 80a34a0:	f7ff fbd4 	bl	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
 80a34a4:	bd08      	pop	{r3, pc}
  }
  WheelPos -= 170;
 80a34a6:	3056      	adds	r0, #86	; 0x56
 80a34a8:	b2c0      	uxtb	r0, r0
  return matrix.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
 80a34aa:	eba0 0180 	sub.w	r1, r0, r0, lsl #2
 80a34ae:	3901      	subs	r1, #1
 80a34b0:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a34b4:	2200      	movs	r2, #0
 80a34b6:	b2c9      	uxtb	r1, r1
 80a34b8:	b2c0      	uxtb	r0, r0
 80a34ba:	f7ff fbc7 	bl	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
}
 80a34be:	bd08      	pop	{r3, pc}

080a34c0 <_Z11rainbowLedsv>:
  delay(1000);
}

// Light all LEDs in the matrix with a rainbow effect
void rainbowLeds()
{
 80a34c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  static int offset = 0;
  for (int row = 0; row < 14; row++) {
    for (int col = 0; col < 60; col++) {
      matrix.drawPixel(col, row, Wheel((row*col+offset)%255));
 80a34c4:	f8df 8050 	ldr.w	r8, [pc, #80]	; 80a3518 <_Z11rainbowLedsv+0x58>

// Light all LEDs in the matrix with a rainbow effect
void rainbowLeds()
{
  static int offset = 0;
  for (int row = 0; row < 14; row++) {
 80a34c8:	2400      	movs	r4, #0
 80a34ca:	2600      	movs	r6, #0
 80a34cc:	4635      	mov	r5, r6
    for (int col = 0; col < 60; col++) {
      matrix.drawPixel(col, row, Wheel((row*col+offset)%255));
 80a34ce:	f04f 09ff 	mov.w	r9, #255	; 0xff
 80a34d2:	f8d8 3000 	ldr.w	r3, [r8]
 80a34d6:	4f10      	ldr	r7, [pc, #64]	; (80a3518 <_Z11rainbowLedsv+0x58>)
 80a34d8:	4433      	add	r3, r6
 80a34da:	fb93 f0f9 	sdiv	r0, r3, r9
 80a34de:	4418      	add	r0, r3
 80a34e0:	b2c0      	uxtb	r0, r0
 80a34e2:	f7ff ffc1 	bl	80a3468 <_Z5Wheelh>
 80a34e6:	b229      	sxth	r1, r5
 80a34e8:	b283      	uxth	r3, r0
 80a34ea:	b222      	sxth	r2, r4
 80a34ec:	480b      	ldr	r0, [pc, #44]	; (80a351c <_Z11rainbowLedsv+0x5c>)
// Light all LEDs in the matrix with a rainbow effect
void rainbowLeds()
{
  static int offset = 0;
  for (int row = 0; row < 14; row++) {
    for (int col = 0; col < 60; col++) {
 80a34ee:	3501      	adds	r5, #1
      matrix.drawPixel(col, row, Wheel((row*col+offset)%255));
 80a34f0:	f7ff fabf 	bl	80a2a72 <_ZN18Adafruit_NeoMatrix9drawPixelEsst>
// Light all LEDs in the matrix with a rainbow effect
void rainbowLeds()
{
  static int offset = 0;
  for (int row = 0; row < 14; row++) {
    for (int col = 0; col < 60; col++) {
 80a34f4:	2d3c      	cmp	r5, #60	; 0x3c
 80a34f6:	4426      	add	r6, r4
 80a34f8:	d1eb      	bne.n	80a34d2 <_Z11rainbowLedsv+0x12>

// Light all LEDs in the matrix with a rainbow effect
void rainbowLeds()
{
  static int offset = 0;
  for (int row = 0; row < 14; row++) {
 80a34fa:	3401      	adds	r4, #1
 80a34fc:	2c0e      	cmp	r4, #14
 80a34fe:	d1e4      	bne.n	80a34ca <_Z11rainbowLedsv+0xa>
    for (int col = 0; col < 60; col++) {
      matrix.drawPixel(col, row, Wheel((row*col+offset)%255));
    }
  }
  offset++;
 80a3500:	683b      	ldr	r3, [r7, #0]
  matrix.show();
 80a3502:	4807      	ldr	r0, [pc, #28]	; (80a3520 <_Z11rainbowLedsv+0x60>)
  for (int row = 0; row < 14; row++) {
    for (int col = 0; col < 60; col++) {
      matrix.drawPixel(col, row, Wheel((row*col+offset)%255));
    }
  }
  offset++;
 80a3504:	3301      	adds	r3, #1
 80a3506:	603b      	str	r3, [r7, #0]
  matrix.show();
 80a3508:	f7fe f936 	bl	80a1778 <_ZN17Adafruit_NeoPixel4showEv>
  delay(1000);
}
 80a350c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
      matrix.drawPixel(col, row, Wheel((row*col+offset)%255));
    }
  }
  offset++;
  matrix.show();
  delay(1000);
 80a3510:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a3514:	f000 bca6 	b.w	80a3e64 <delay>
 80a3518:	20001348 	.word	0x20001348
 80a351c:	20001378 	.word	0x20001378
 80a3520:	20001394 	.word	0x20001394

080a3524 <_Z2rrii>:
  return matrix.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
}

// Generate a random number between minRand and maxRand
int rr(int minRand, int maxRand)
{
 80a3524:	b538      	push	{r3, r4, r5, lr}
 80a3526:	4605      	mov	r5, r0
 80a3528:	460c      	mov	r4, r1
  return rand() % (maxRand-minRand+1) + minRand;
 80a352a:	f002 fb71 	bl	80a5c10 <rand>
 80a352e:	1b61      	subs	r1, r4, r5
 80a3530:	3101      	adds	r1, #1
 80a3532:	fb90 f3f1 	sdiv	r3, r0, r1
 80a3536:	fb03 0011 	mls	r0, r3, r1, r0
 80a353a:	4428      	add	r0, r5
 80a353c:	bd38      	pop	{r3, r4, r5, pc}
	...

080a3540 <_Z10lightBoxesv>:
  //delay(10);
}

// Light each led-mapped box on the organizer one by one
void lightBoxes()
{
 80a3540:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  for (int row = 0; row < 8; row++) {
    for (int col = 0; col < 16; col++) {
      GFX_lightBox(row, col, colors[rr(0, colorCount)]);
 80a3544:	f8df 8068 	ldr.w	r8, [pc, #104]	; 80a35b0 <_Z10lightBoxesv+0x70>
 80a3548:	f8df 9068 	ldr.w	r9, [pc, #104]	; 80a35b4 <_Z10lightBoxesv+0x74>
}

// Light each led-mapped box on the organizer one by one
void lightBoxes()
{
  for (int row = 0; row < 8; row++) {
 80a354c:	2400      	movs	r4, #0
 80a354e:	2500      	movs	r5, #0
    for (int col = 0; col < 16; col++) {
      GFX_lightBox(row, col, colors[rr(0, colorCount)]);
 80a3550:	f898 1000 	ldrb.w	r1, [r8]
 80a3554:	2000      	movs	r0, #0
 80a3556:	f7ff ffe5 	bl	80a3524 <_Z2rrii>
 80a355a:	4629      	mov	r1, r5
 80a355c:	f839 2010 	ldrh.w	r2, [r9, r0, lsl #1]
 80a3560:	4620      	mov	r0, r4
 80a3562:	f7ff fbeb 	bl	80a2d3c <_Z12GFX_lightBoxiit>

// Light each led-mapped box on the organizer one by one
void lightBoxes()
{
  for (int row = 0; row < 8; row++) {
    for (int col = 0; col < 16; col++) {
 80a3566:	3501      	adds	r5, #1
      GFX_lightBox(row, col, colors[rr(0, colorCount)]);
      delay(50);
 80a3568:	2032      	movs	r0, #50	; 0x32
 80a356a:	f000 fc7b 	bl	80a3e64 <delay>

// Light each led-mapped box on the organizer one by one
void lightBoxes()
{
  for (int row = 0; row < 8; row++) {
    for (int col = 0; col < 16; col++) {
 80a356e:	2d10      	cmp	r5, #16
 80a3570:	4e0f      	ldr	r6, [pc, #60]	; (80a35b0 <_Z10lightBoxesv+0x70>)
 80a3572:	4f10      	ldr	r7, [pc, #64]	; (80a35b4 <_Z10lightBoxesv+0x74>)
 80a3574:	d1ec      	bne.n	80a3550 <_Z10lightBoxesv+0x10>
}

// Light each led-mapped box on the organizer one by one
void lightBoxes()
{
  for (int row = 0; row < 8; row++) {
 80a3576:	3401      	adds	r4, #1
 80a3578:	2c08      	cmp	r4, #8
 80a357a:	d1e8      	bne.n	80a354e <_Z10lightBoxesv+0xe>
 80a357c:	2500      	movs	r5, #0
      delay(50);
    }
  }
  for (int row = 8; row < 14; row++) {
    for (int col = 0; col < 8; col++) {
      GFX_lightBox(row, col, colors[rr(0, colorCount)]);
 80a357e:	7831      	ldrb	r1, [r6, #0]
 80a3580:	2000      	movs	r0, #0
 80a3582:	f7ff ffcf 	bl	80a3524 <_Z2rrii>
 80a3586:	4629      	mov	r1, r5
 80a3588:	f837 2010 	ldrh.w	r2, [r7, r0, lsl #1]
 80a358c:	4620      	mov	r0, r4
 80a358e:	f7ff fbd5 	bl	80a2d3c <_Z12GFX_lightBoxiit>
      GFX_lightBox(row, col, colors[rr(0, colorCount)]);
      delay(50);
    }
  }
  for (int row = 8; row < 14; row++) {
    for (int col = 0; col < 8; col++) {
 80a3592:	3501      	adds	r5, #1
      GFX_lightBox(row, col, colors[rr(0, colorCount)]);
      delay(50);
 80a3594:	2032      	movs	r0, #50	; 0x32
 80a3596:	f000 fc65 	bl	80a3e64 <delay>
      GFX_lightBox(row, col, colors[rr(0, colorCount)]);
      delay(50);
    }
  }
  for (int row = 8; row < 14; row++) {
    for (int col = 0; col < 8; col++) {
 80a359a:	2d08      	cmp	r5, #8
 80a359c:	d1ef      	bne.n	80a357e <_Z10lightBoxesv+0x3e>
    for (int col = 0; col < 16; col++) {
      GFX_lightBox(row, col, colors[rr(0, colorCount)]);
      delay(50);
    }
  }
  for (int row = 8; row < 14; row++) {
 80a359e:	3401      	adds	r4, #1
 80a35a0:	2c0e      	cmp	r4, #14
 80a35a2:	d1eb      	bne.n	80a357c <_Z10lightBoxesv+0x3c>
      GFX_lightBox(row, col, colors[rr(0, colorCount)]);
      delay(50);
    }
  }
  while(true) {
    delay(1000);
 80a35a4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a35a8:	f000 fc5c 	bl	80a3e64 <delay>
 80a35ac:	e7fa      	b.n	80a35a4 <_Z10lightBoxesv+0x64>
 80a35ae:	bf00      	nop
 80a35b0:	20000480 	.word	0x20000480
 80a35b4:	20001338 	.word	0x20001338

080a35b8 <_Z8GFX_loopv>:
    matrix.setTextWrap(false);
    matrix.setBrightness(30);
    matrix.setTextColor(matrix.Color(255,0,255));
}

void GFX_loop() {
 80a35b8:	b508      	push	{r3, lr}
    if (enableLightAllBoxes) lightBoxes();
 80a35ba:	4b09      	ldr	r3, [pc, #36]	; (80a35e0 <_Z8GFX_loopv+0x28>)
 80a35bc:	781b      	ldrb	r3, [r3, #0]
 80a35be:	b10b      	cbz	r3, 80a35c4 <_Z8GFX_loopv+0xc>
 80a35c0:	f7ff ffbe 	bl	80a3540 <_Z10lightBoxesv>
    if (enableTextScrolling) scrollDisplay();
 80a35c4:	4b07      	ldr	r3, [pc, #28]	; (80a35e4 <_Z8GFX_loopv+0x2c>)
 80a35c6:	781b      	ldrb	r3, [r3, #0]
 80a35c8:	b10b      	cbz	r3, 80a35ce <_Z8GFX_loopv+0x16>
 80a35ca:	f7ff fc2b 	bl	80a2e24 <_Z13scrollDisplayv>
    if (enableRainbowLeds)   rainbowLeds();
 80a35ce:	4b06      	ldr	r3, [pc, #24]	; (80a35e8 <_Z8GFX_loopv+0x30>)
 80a35d0:	781b      	ldrb	r3, [r3, #0]
 80a35d2:	b11b      	cbz	r3, 80a35dc <_Z8GFX_loopv+0x24>
}
 80a35d4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
}

void GFX_loop() {
    if (enableLightAllBoxes) lightBoxes();
    if (enableTextScrolling) scrollDisplay();
    if (enableRainbowLeds)   rainbowLeds();
 80a35d8:	f7ff bf72 	b.w	80a34c0 <_Z11rainbowLedsv>
 80a35dc:	bd08      	pop	{r3, pc}
 80a35de:	bf00      	nop
 80a35e0:	20001364 	.word	0x20001364
 80a35e4:	200013cc 	.word	0x200013cc
 80a35e8:	20001334 	.word	0x20001334

080a35ec <_GLOBAL__sub_I_matrix>:

// Generate a random number between minRand and maxRand
int rr(int minRand, int maxRand)
{
  return rand() % (maxRand-minRand+1) + minRand;
 80a35ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
const int boxLedWidthByColumnBottom[] = {
  7, 6, 6, 7, 7, 6, 6, 7
};

// Variables
Adafruit_NeoMatrix matrix = Adafruit_NeoMatrix(
 80a35f0:	4c45      	ldr	r4, [pc, #276]	; (80a3708 <_GLOBAL__sub_I_matrix+0x11c>)

// Generate a random number between minRand and maxRand
int rr(int minRand, int maxRand)
{
  return rand() % (maxRand-minRand+1) + minRand;
 80a35f2:	b085      	sub	sp, #20
 80a35f4:	f000 f8aa 	bl	80a374c <HAL_Pin_Map>
const int boxLedWidthByColumnBottom[] = {
  7, 6, 6, 7, 7, 6, 6, 7
};

// Variables
Adafruit_NeoMatrix matrix = Adafruit_NeoMatrix(
 80a35f8:	4d44      	ldr	r5, [pc, #272]	; (80a370c <_GLOBAL__sub_I_matrix+0x120>)
 80a35fa:	2208      	movs	r2, #8
 80a35fc:	2302      	movs	r3, #2
 80a35fe:	e88d 000c 	stmia.w	sp, {r2, r3}
 80a3602:	213c      	movs	r1, #60	; 0x3c
 80a3604:	2303      	movs	r3, #3
 80a3606:	220e      	movs	r2, #14
 80a3608:	4620      	mov	r0, r4
 80a360a:	f7ff faf5 	bl	80a2bf8 <_ZN18Adafruit_NeoMatrixC1Eiihhh>
 80a360e:	462a      	mov	r2, r5
 80a3610:	493f      	ldr	r1, [pc, #252]	; (80a3710 <_GLOBAL__sub_I_matrix+0x124>)
 80a3612:	4620      	mov	r0, r4
 80a3614:	f001 f9e2 	bl	80a49dc <__aeabi_atexit>
    PIXEL_PIN, // data pin
    NEO_MATRIX_TOP + NEO_MATRIX_LEFT + NEO_MATRIX_ROWS + NEO_MATRIX_ZIGZAG,
    PIXEL_TYPE
);

uint16_t red = matrix.Color(255, 0, 0);
 80a3618:	2200      	movs	r2, #0
 80a361a:	4611      	mov	r1, r2
 80a361c:	20ff      	movs	r0, #255	; 0xff
 80a361e:	f7ff fb15 	bl	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
 80a3622:	4b3c      	ldr	r3, [pc, #240]	; (80a3714 <_GLOBAL__sub_I_matrix+0x128>)
uint16_t green = matrix.Color(0, 255, 0);
 80a3624:	2200      	movs	r2, #0
    PIXEL_PIN, // data pin
    NEO_MATRIX_TOP + NEO_MATRIX_LEFT + NEO_MATRIX_ROWS + NEO_MATRIX_ZIGZAG,
    PIXEL_TYPE
);

uint16_t red = matrix.Color(255, 0, 0);
 80a3626:	8018      	strh	r0, [r3, #0]
uint16_t green = matrix.Color(0, 255, 0);
 80a3628:	21ff      	movs	r1, #255	; 0xff
 80a362a:	4610      	mov	r0, r2
    PIXEL_PIN, // data pin
    NEO_MATRIX_TOP + NEO_MATRIX_LEFT + NEO_MATRIX_ROWS + NEO_MATRIX_ZIGZAG,
    PIXEL_TYPE
);

uint16_t red = matrix.Color(255, 0, 0);
 80a362c:	9303      	str	r3, [sp, #12]
uint16_t green = matrix.Color(0, 255, 0);
 80a362e:	f7ff fb0d 	bl	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
 80a3632:	f8df b108 	ldr.w	fp, [pc, #264]	; 80a373c <_GLOBAL__sub_I_matrix+0x150>
uint16_t blue = matrix.Color(0, 0, 255);
 80a3636:	2100      	movs	r1, #0
    NEO_MATRIX_TOP + NEO_MATRIX_LEFT + NEO_MATRIX_ROWS + NEO_MATRIX_ZIGZAG,
    PIXEL_TYPE
);

uint16_t red = matrix.Color(255, 0, 0);
uint16_t green = matrix.Color(0, 255, 0);
 80a3638:	f8ab 0000 	strh.w	r0, [fp]
uint16_t blue = matrix.Color(0, 0, 255);
 80a363c:	22ff      	movs	r2, #255	; 0xff
 80a363e:	4608      	mov	r0, r1
 80a3640:	f7ff fb04 	bl	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
 80a3644:	f8df a0f8 	ldr.w	sl, [pc, #248]	; 80a3740 <_GLOBAL__sub_I_matrix+0x154>
uint16_t magenta = matrix.Color(255, 0, 255);
 80a3648:	22ff      	movs	r2, #255	; 0xff
    PIXEL_TYPE
);

uint16_t red = matrix.Color(255, 0, 0);
uint16_t green = matrix.Color(0, 255, 0);
uint16_t blue = matrix.Color(0, 0, 255);
 80a364a:	f8aa 0000 	strh.w	r0, [sl]
uint16_t magenta = matrix.Color(255, 0, 255);
 80a364e:	2100      	movs	r1, #0
 80a3650:	4610      	mov	r0, r2
 80a3652:	f7ff fafb 	bl	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
 80a3656:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 80a3744 <_GLOBAL__sub_I_matrix+0x158>
uint16_t orange = matrix.Color(255, 165, 0);
 80a365a:	2200      	movs	r2, #0
);

uint16_t red = matrix.Color(255, 0, 0);
uint16_t green = matrix.Color(0, 255, 0);
uint16_t blue = matrix.Color(0, 0, 255);
uint16_t magenta = matrix.Color(255, 0, 255);
 80a365c:	f8a9 0000 	strh.w	r0, [r9]
uint16_t orange = matrix.Color(255, 165, 0);
 80a3660:	21a5      	movs	r1, #165	; 0xa5
 80a3662:	20ff      	movs	r0, #255	; 0xff
 80a3664:	f7ff faf2 	bl	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
 80a3668:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 80a3748 <_GLOBAL__sub_I_matrix+0x15c>
uint16_t cyan = matrix.Color(0, 255, 255);
 80a366c:	22ff      	movs	r2, #255	; 0xff

uint16_t red = matrix.Color(255, 0, 0);
uint16_t green = matrix.Color(0, 255, 0);
uint16_t blue = matrix.Color(0, 0, 255);
uint16_t magenta = matrix.Color(255, 0, 255);
uint16_t orange = matrix.Color(255, 165, 0);
 80a366e:	f8a8 0000 	strh.w	r0, [r8]
uint16_t cyan = matrix.Color(0, 255, 255);
 80a3672:	4611      	mov	r1, r2
 80a3674:	2000      	movs	r0, #0
 80a3676:	f7ff fae9 	bl	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
 80a367a:	4f27      	ldr	r7, [pc, #156]	; (80a3718 <_GLOBAL__sub_I_matrix+0x12c>)
uint16_t purple = matrix.Color(128,0,128);
 80a367c:	2280      	movs	r2, #128	; 0x80
uint16_t red = matrix.Color(255, 0, 0);
uint16_t green = matrix.Color(0, 255, 0);
uint16_t blue = matrix.Color(0, 0, 255);
uint16_t magenta = matrix.Color(255, 0, 255);
uint16_t orange = matrix.Color(255, 165, 0);
uint16_t cyan = matrix.Color(0, 255, 255);
 80a367e:	8038      	strh	r0, [r7, #0]
uint16_t purple = matrix.Color(128,0,128);
 80a3680:	2100      	movs	r1, #0
 80a3682:	4610      	mov	r0, r2
 80a3684:	f7ff fae2 	bl	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
 80a3688:	4e24      	ldr	r6, [pc, #144]	; (80a371c <_GLOBAL__sub_I_matrix+0x130>)
uint16_t white = matrix.Color(255, 255, 255);
 80a368a:	22ff      	movs	r2, #255	; 0xff
uint16_t green = matrix.Color(0, 255, 0);
uint16_t blue = matrix.Color(0, 0, 255);
uint16_t magenta = matrix.Color(255, 0, 255);
uint16_t orange = matrix.Color(255, 165, 0);
uint16_t cyan = matrix.Color(0, 255, 255);
uint16_t purple = matrix.Color(128,0,128);
 80a368c:	8030      	strh	r0, [r6, #0]
uint16_t white = matrix.Color(255, 255, 255);
 80a368e:	4611      	mov	r1, r2
 80a3690:	4610      	mov	r0, r2
 80a3692:	f7ff fadb 	bl	80a2c4c <_ZN18Adafruit_NeoMatrix5ColorEhhh>
  green,
  blue,
  magenta,
  orange,
  cyan
};
 80a3696:	9b03      	ldr	r3, [sp, #12]
uint16_t blue = matrix.Color(0, 0, 255);
uint16_t magenta = matrix.Color(255, 0, 255);
uint16_t orange = matrix.Color(255, 165, 0);
uint16_t cyan = matrix.Color(0, 255, 255);
uint16_t purple = matrix.Color(128,0,128);
uint16_t white = matrix.Color(255, 255, 255);
 80a3698:	4a21      	ldr	r2, [pc, #132]	; (80a3720 <_GLOBAL__sub_I_matrix+0x134>)
  green,
  blue,
  magenta,
  orange,
  cyan
};
 80a369a:	f8b3 e000 	ldrh.w	lr, [r3]
 80a369e:	f8bb c000 	ldrh.w	ip, [fp]
 80a36a2:	4b20      	ldr	r3, [pc, #128]	; (80a3724 <_GLOBAL__sub_I_matrix+0x138>)
 80a36a4:	f8b8 1000 	ldrh.w	r1, [r8]
 80a36a8:	f8ba a000 	ldrh.w	sl, [sl]
 80a36ac:	f8b9 9000 	ldrh.w	r9, [r9]
uint16_t blue = matrix.Color(0, 0, 255);
uint16_t magenta = matrix.Color(255, 0, 255);
uint16_t orange = matrix.Color(255, 165, 0);
uint16_t cyan = matrix.Color(0, 255, 255);
uint16_t purple = matrix.Color(128,0,128);
uint16_t white = matrix.Color(255, 255, 255);
 80a36b0:	8010      	strh	r0, [r2, #0]
  green,
  blue,
  magenta,
  orange,
  cyan
};
 80a36b2:	883a      	ldrh	r2, [r7, #0]
 80a36b4:	f8a3 e000 	strh.w	lr, [r3]
 80a36b8:	f8a3 c002 	strh.w	ip, [r3, #2]
 80a36bc:	f8a3 a004 	strh.w	sl, [r3, #4]
 80a36c0:	f8a3 9006 	strh.w	r9, [r3, #6]
 80a36c4:	8119      	strh	r1, [r3, #8]
 80a36c6:	815a      	strh	r2, [r3, #10]
  { "magenta", magenta },
  { "orange", orange },
  { "cyan", cyan },
  { "white", white },
  { "purple", purple }
};
 80a36c8:	4b17      	ldr	r3, [pc, #92]	; (80a3728 <_GLOBAL__sub_I_matrix+0x13c>)
 80a36ca:	859a      	strh	r2, [r3, #44]	; 0x2c
 80a36cc:	8832      	ldrh	r2, [r6, #0]
 80a36ce:	f8a3 e004 	strh.w	lr, [r3, #4]
 80a36d2:	f8a3 c00c 	strh.w	ip, [r3, #12]
 80a36d6:	879a      	strh	r2, [r3, #60]	; 0x3c
 80a36d8:	f8a3 a014 	strh.w	sl, [r3, #20]
 80a36dc:	f8a3 901c 	strh.w	r9, [r3, #28]
 80a36e0:	8499      	strh	r1, [r3, #36]	; 0x24
 80a36e2:	8698      	strh	r0, [r3, #52]	; 0x34
uint16_t likelyColor;
uint16_t unlikelyColor;

uint8_t colorCount = sizeof(colors) / sizeof(uint16_t);

int scrollPosition = matrix.width();
 80a36e4:	4620      	mov	r0, r4
 80a36e6:	f7fd ffe0 	bl	80a16aa <_ZN12Adafruit_GFX5widthEv>
int scrollCount = 0;

String text = "H I ";
 80a36ea:	4c10      	ldr	r4, [pc, #64]	; (80a372c <_GLOBAL__sub_I_matrix+0x140>)
uint16_t likelyColor;
uint16_t unlikelyColor;

uint8_t colorCount = sizeof(colors) / sizeof(uint16_t);

int scrollPosition = matrix.width();
 80a36ec:	4b10      	ldr	r3, [pc, #64]	; (80a3730 <_GLOBAL__sub_I_matrix+0x144>)
int scrollCount = 0;

String text = "H I ";
 80a36ee:	4911      	ldr	r1, [pc, #68]	; (80a3734 <_GLOBAL__sub_I_matrix+0x148>)
uint16_t likelyColor;
uint16_t unlikelyColor;

uint8_t colorCount = sizeof(colors) / sizeof(uint16_t);

int scrollPosition = matrix.width();
 80a36f0:	6018      	str	r0, [r3, #0]
int scrollCount = 0;

String text = "H I ";
 80a36f2:	4620      	mov	r0, r4
 80a36f4:	f000 fa57 	bl	80a3ba6 <_ZN6StringC1EPK19__FlashStringHelper>
 80a36f8:	462a      	mov	r2, r5
 80a36fa:	4620      	mov	r0, r4
 80a36fc:	490e      	ldr	r1, [pc, #56]	; (80a3738 <_GLOBAL__sub_I_matrix+0x14c>)

// Generate a random number between minRand and maxRand
int rr(int minRand, int maxRand)
{
  return rand() % (maxRand-minRand+1) + minRand;
 80a36fe:	b005      	add	sp, #20
 80a3700:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
uint8_t colorCount = sizeof(colors) / sizeof(uint16_t);

int scrollPosition = matrix.width();
int scrollCount = 0;

String text = "H I ";
 80a3704:	f001 b96a 	b.w	80a49dc <__aeabi_atexit>
 80a3708:	20001378 	.word	0x20001378
 80a370c:	200004f0 	.word	0x200004f0
 80a3710:	080a2a49 	.word	0x080a2a49
 80a3714:	2000136c 	.word	0x2000136c
 80a3718:	20001368 	.word	0x20001368
 80a371c:	200013c4 	.word	0x200013c4
 80a3720:	2000136a 	.word	0x2000136a
 80a3724:	20001338 	.word	0x20001338
 80a3728:	20000440 	.word	0x20000440
 80a372c:	20001354 	.word	0x20001354
 80a3730:	2000134c 	.word	0x2000134c
 80a3734:	080a6a25 	.word	0x080a6a25
 80a3738:	080a3b19 	.word	0x080a3b19
 80a373c:	20001344 	.word	0x20001344
 80a3740:	20001336 	.word	0x20001336
 80a3744:	20001352 	.word	0x20001352
 80a3748:	20001376 	.word	0x20001376

080a374c <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, STM32_Pin_Info*(void))
 80a374c:	b508      	push	{r3, lr}
 80a374e:	4b02      	ldr	r3, [pc, #8]	; (80a3758 <HAL_Pin_Map+0xc>)
 80a3750:	681b      	ldr	r3, [r3, #0]
 80a3752:	681b      	ldr	r3, [r3, #0]
 80a3754:	9301      	str	r3, [sp, #4]
 80a3756:	bd08      	pop	{r3, pc}
 80a3758:	080601b0 	.word	0x080601b0

080a375c <HAL_Pin_Mode>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a375c:	b508      	push	{r3, lr}
 80a375e:	4b02      	ldr	r3, [pc, #8]	; (80a3768 <HAL_Pin_Mode+0xc>)
 80a3760:	681b      	ldr	r3, [r3, #0]
 80a3762:	689b      	ldr	r3, [r3, #8]
 80a3764:	9301      	str	r3, [sp, #4]
 80a3766:	bd08      	pop	{r3, pc}
 80a3768:	080601b0 	.word	0x080601b0

080a376c <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
 80a376c:	b508      	push	{r3, lr}
 80a376e:	4b02      	ldr	r3, [pc, #8]	; (80a3778 <HAL_Get_Pin_Mode+0xc>)
 80a3770:	681b      	ldr	r3, [r3, #0]
 80a3772:	68db      	ldr	r3, [r3, #12]
 80a3774:	9301      	str	r3, [sp, #4]
 80a3776:	bd08      	pop	{r3, pc}
 80a3778:	080601b0 	.word	0x080601b0

080a377c <HAL_GPIO_Write>:
DYNALIB_FN(4, hal_gpio, HAL_GPIO_Write, void(pin_t, uint8_t))
 80a377c:	b508      	push	{r3, lr}
 80a377e:	4b02      	ldr	r3, [pc, #8]	; (80a3788 <HAL_GPIO_Write+0xc>)
 80a3780:	681b      	ldr	r3, [r3, #0]
 80a3782:	691b      	ldr	r3, [r3, #16]
 80a3784:	9301      	str	r3, [sp, #4]
 80a3786:	bd08      	pop	{r3, pc}
 80a3788:	080601b0 	.word	0x080601b0

080a378c <HAL_SPI_Init>:
DYNALIB_FN(2, hal_spi, HAL_SPI_Set_Bit_Order, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(3, hal_spi, HAL_SPI_Set_Data_Mode, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(4, hal_spi, HAL_SPI_Set_Clock_Divider, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(5, hal_spi, HAL_SPI_Send_Receive_Data, uint16_t(HAL_SPI_Interface, uint16_t))
DYNALIB_FN(6, hal_spi, HAL_SPI_Is_Enabled_Old, bool(void))
DYNALIB_FN(7, hal_spi, HAL_SPI_Init, void(HAL_SPI_Interface))
 80a378c:	b508      	push	{r3, lr}
 80a378e:	4b02      	ldr	r3, [pc, #8]	; (80a3798 <HAL_SPI_Init+0xc>)
 80a3790:	681b      	ldr	r3, [r3, #0]
 80a3792:	69db      	ldr	r3, [r3, #28]
 80a3794:	9301      	str	r3, [sp, #4]
 80a3796:	bd08      	pop	{r3, pc}
 80a3798:	080601b4 	.word	0x080601b4

080a379c <HAL_SPI_Is_Enabled>:
DYNALIB_FN(8, hal_spi, HAL_SPI_Is_Enabled, bool(HAL_SPI_Interface))
 80a379c:	b508      	push	{r3, lr}
 80a379e:	4b02      	ldr	r3, [pc, #8]	; (80a37a8 <HAL_SPI_Is_Enabled+0xc>)
 80a37a0:	681b      	ldr	r3, [r3, #0]
 80a37a2:	6a1b      	ldr	r3, [r3, #32]
 80a37a4:	9301      	str	r3, [sp, #4]
 80a37a6:	bd08      	pop	{r3, pc}
 80a37a8:	080601b4 	.word	0x080601b4

080a37ac <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a37ac:	b508      	push	{r3, lr}
 80a37ae:	4b02      	ldr	r3, [pc, #8]	; (80a37b8 <HAL_RNG_GetRandomNumber+0xc>)
 80a37b0:	681b      	ldr	r3, [r3, #0]
 80a37b2:	685b      	ldr	r3, [r3, #4]
 80a37b4:	9301      	str	r3, [sp, #4]
 80a37b6:	bd08      	pop	{r3, pc}
 80a37b8:	0806019c 	.word	0x0806019c

080a37bc <HAL_Delay_Microseconds>:
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
 80a37bc:	b508      	push	{r3, lr}
 80a37be:	4b02      	ldr	r3, [pc, #8]	; (80a37c8 <HAL_Delay_Microseconds+0xc>)
 80a37c0:	681b      	ldr	r3, [r3, #0]
 80a37c2:	68db      	ldr	r3, [r3, #12]
 80a37c4:	9301      	str	r3, [sp, #4]
 80a37c6:	bd08      	pop	{r3, pc}
 80a37c8:	0806019c 	.word	0x0806019c

080a37cc <HAL_Timer_Get_Micro_Seconds>:
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
 80a37cc:	b508      	push	{r3, lr}
 80a37ce:	4b02      	ldr	r3, [pc, #8]	; (80a37d8 <HAL_Timer_Get_Micro_Seconds+0xc>)
 80a37d0:	681b      	ldr	r3, [r3, #0]
 80a37d2:	691b      	ldr	r3, [r3, #16]
 80a37d4:	9301      	str	r3, [sp, #4]
 80a37d6:	bd08      	pop	{r3, pc}
 80a37d8:	0806019c 	.word	0x0806019c

080a37dc <HAL_Timer_Get_Milli_Seconds>:
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a37dc:	b508      	push	{r3, lr}
 80a37de:	4b02      	ldr	r3, [pc, #8]	; (80a37e8 <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a37e0:	681b      	ldr	r3, [r3, #0]
 80a37e2:	695b      	ldr	r3, [r3, #20]
 80a37e4:	9301      	str	r3, [sp, #4]
 80a37e6:	bd08      	pop	{r3, pc}
 80a37e8:	0806019c 	.word	0x0806019c

080a37ec <HAL_Core_Get_Last_Reset_Info>:
DYNALIB_FN(22, hal_core, HAL_Set_System_Config, int(hal_system_config_t, const void*, unsigned))
DYNALIB_FN(23, hal_core, HAL_Core_Enter_Safe_Mode, void(void*))
DYNALIB_FN(24, hal_core, HAL_Feature_Get, bool(HAL_Feature))
DYNALIB_FN(25, hal_core, HAL_Feature_Set, int(HAL_Feature, bool))
DYNALIB_FN(26, hal_core, HAL_Core_System_Reset_Ex, void(int, uint32_t, void*))
DYNALIB_FN(27, hal_core, HAL_Core_Get_Last_Reset_Info, int(int*, uint32_t*, void*))
 80a37ec:	b508      	push	{r3, lr}
 80a37ee:	4b02      	ldr	r3, [pc, #8]	; (80a37f8 <HAL_Core_Get_Last_Reset_Info+0xc>)
 80a37f0:	681b      	ldr	r3, [r3, #0]
 80a37f2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a37f4:	9301      	str	r3, [sp, #4]
 80a37f6:	bd08      	pop	{r3, pc}
 80a37f8:	080601b8 	.word	0x080601b8

080a37fc <os_mutex_create>:
DYNALIB_FN(8, hal_concurrent, os_timer_create, int(os_timer_t*, unsigned, void(*)(os_timer_t), void*, bool, void*))
DYNALIB_FN(9, hal_concurrent, os_timer_destroy, int(os_timer_t, void*))
DYNALIB_FN(10, hal_concurrent, os_timer_get_id, int(os_timer_t, void**))
DYNALIB_FN(11, hal_concurrent, os_timer_change, int(os_timer_t, os_timer_change_t, bool, unsigned, unsigned, void*))

DYNALIB_FN(12, hal_concurrent, os_mutex_create, int(os_mutex_t*))
 80a37fc:	b508      	push	{r3, lr}
 80a37fe:	4b02      	ldr	r3, [pc, #8]	; (80a3808 <os_mutex_create+0xc>)
 80a3800:	681b      	ldr	r3, [r3, #0]
 80a3802:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a3804:	9301      	str	r3, [sp, #4]
 80a3806:	bd08      	pop	{r3, pc}
 80a3808:	080601d0 	.word	0x080601d0

080a380c <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
 80a380c:	b508      	push	{r3, lr}
 80a380e:	4b02      	ldr	r3, [pc, #8]	; (80a3818 <HAL_USART_Init+0xc>)
 80a3810:	681b      	ldr	r3, [r3, #0]
 80a3812:	699b      	ldr	r3, [r3, #24]
 80a3814:	9301      	str	r3, [sp, #4]
 80a3816:	bd08      	pop	{r3, pc}
 80a3818:	080601c4 	.word	0x080601c4

080a381c <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
 80a381c:	b508      	push	{r3, lr}
 80a381e:	4b02      	ldr	r3, [pc, #8]	; (80a3828 <HAL_USART_Write_Data+0xc>)
 80a3820:	681b      	ldr	r3, [r3, #0]
 80a3822:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a3824:	9301      	str	r3, [sp, #4]
 80a3826:	bd08      	pop	{r3, pc}
 80a3828:	080601c4 	.word	0x080601c4

080a382c <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
 80a382c:	b508      	push	{r3, lr}
 80a382e:	4b02      	ldr	r3, [pc, #8]	; (80a3838 <HAL_USART_Available_Data+0xc>)
 80a3830:	681b      	ldr	r3, [r3, #0]
 80a3832:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a3834:	9301      	str	r3, [sp, #4]
 80a3836:	bd08      	pop	{r3, pc}
 80a3838:	080601c4 	.word	0x080601c4

080a383c <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
 80a383c:	b508      	push	{r3, lr}
 80a383e:	4b02      	ldr	r3, [pc, #8]	; (80a3848 <HAL_USART_Read_Data+0xc>)
 80a3840:	681b      	ldr	r3, [r3, #0]
 80a3842:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a3844:	9301      	str	r3, [sp, #4]
 80a3846:	bd08      	pop	{r3, pc}
 80a3848:	080601c4 	.word	0x080601c4

080a384c <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
 80a384c:	b508      	push	{r3, lr}
 80a384e:	4b02      	ldr	r3, [pc, #8]	; (80a3858 <HAL_USART_Peek_Data+0xc>)
 80a3850:	681b      	ldr	r3, [r3, #0]
 80a3852:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a3854:	9301      	str	r3, [sp, #4]
 80a3856:	bd08      	pop	{r3, pc}
 80a3858:	080601c4 	.word	0x080601c4

080a385c <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
 80a385c:	b508      	push	{r3, lr}
 80a385e:	4b02      	ldr	r3, [pc, #8]	; (80a3868 <HAL_USART_Flush_Data+0xc>)
 80a3860:	681b      	ldr	r3, [r3, #0]
 80a3862:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a3864:	9301      	str	r3, [sp, #4]
 80a3866:	bd08      	pop	{r3, pc}
 80a3868:	080601c4 	.word	0x080601c4

080a386c <HAL_USART_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
 80a386c:	b508      	push	{r3, lr}
 80a386e:	4b02      	ldr	r3, [pc, #8]	; (80a3878 <HAL_USART_Is_Enabled+0xc>)
 80a3870:	681b      	ldr	r3, [r3, #0]
 80a3872:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a3874:	9301      	str	r3, [sp, #4]
 80a3876:	bd08      	pop	{r3, pc}
 80a3878:	080601c4 	.word	0x080601c4

080a387c <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
 80a387c:	b508      	push	{r3, lr}
 80a387e:	4b02      	ldr	r3, [pc, #8]	; (80a3888 <HAL_USART_Available_Data_For_Write+0xc>)
 80a3880:	681b      	ldr	r3, [r3, #0]
 80a3882:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a3884:	9301      	str	r3, [sp, #4]
 80a3886:	bd08      	pop	{r3, pc}
 80a3888:	080601c4 	.word	0x080601c4

080a388c <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
 80a388c:	b508      	push	{r3, lr}
 80a388e:	4b02      	ldr	r3, [pc, #8]	; (80a3898 <HAL_I2C_Write_Data+0xc>)
 80a3890:	681b      	ldr	r3, [r3, #0]
 80a3892:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a3894:	9301      	str	r3, [sp, #4]
 80a3896:	bd08      	pop	{r3, pc}
 80a3898:	080601ac 	.word	0x080601ac

080a389c <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
 80a389c:	b508      	push	{r3, lr}
 80a389e:	4b02      	ldr	r3, [pc, #8]	; (80a38a8 <HAL_I2C_Available_Data+0xc>)
 80a38a0:	681b      	ldr	r3, [r3, #0]
 80a38a2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a38a4:	9301      	str	r3, [sp, #4]
 80a38a6:	bd08      	pop	{r3, pc}
 80a38a8:	080601ac 	.word	0x080601ac

080a38ac <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
 80a38ac:	b508      	push	{r3, lr}
 80a38ae:	4b02      	ldr	r3, [pc, #8]	; (80a38b8 <HAL_I2C_Read_Data+0xc>)
 80a38b0:	681b      	ldr	r3, [r3, #0]
 80a38b2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a38b4:	9301      	str	r3, [sp, #4]
 80a38b6:	bd08      	pop	{r3, pc}
 80a38b8:	080601ac 	.word	0x080601ac

080a38bc <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
 80a38bc:	b508      	push	{r3, lr}
 80a38be:	4b02      	ldr	r3, [pc, #8]	; (80a38c8 <HAL_I2C_Peek_Data+0xc>)
 80a38c0:	681b      	ldr	r3, [r3, #0]
 80a38c2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a38c4:	9301      	str	r3, [sp, #4]
 80a38c6:	bd08      	pop	{r3, pc}
 80a38c8:	080601ac 	.word	0x080601ac

080a38cc <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
 80a38cc:	b508      	push	{r3, lr}
 80a38ce:	4b02      	ldr	r3, [pc, #8]	; (80a38d8 <HAL_I2C_Flush_Data+0xc>)
 80a38d0:	681b      	ldr	r3, [r3, #0]
 80a38d2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a38d4:	9301      	str	r3, [sp, #4]
 80a38d6:	bd08      	pop	{r3, pc}
 80a38d8:	080601ac 	.word	0x080601ac

080a38dc <HAL_I2C_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
 80a38dc:	b508      	push	{r3, lr}
 80a38de:	4b02      	ldr	r3, [pc, #8]	; (80a38e8 <HAL_I2C_Is_Enabled+0xc>)
 80a38e0:	681b      	ldr	r3, [r3, #0]
 80a38e2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a38e4:	9301      	str	r3, [sp, #4]
 80a38e6:	bd08      	pop	{r3, pc}
 80a38e8:	080601ac 	.word	0x080601ac

080a38ec <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, void(HAL_I2C_Interface, void*))
 80a38ec:	b508      	push	{r3, lr}
 80a38ee:	4b03      	ldr	r3, [pc, #12]	; (80a38fc <HAL_I2C_Init+0x10>)
 80a38f0:	681b      	ldr	r3, [r3, #0]
 80a38f2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a38f6:	9301      	str	r3, [sp, #4]
 80a38f8:	bd08      	pop	{r3, pc}
 80a38fa:	0000      	.short	0x0000
 80a38fc:	080601ac 	.word	0x080601ac

080a3900 <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a3900:	b508      	push	{r3, lr}
 80a3902:	4b02      	ldr	r3, [pc, #8]	; (80a390c <HAL_USB_USART_Init+0xc>)
 80a3904:	681b      	ldr	r3, [r3, #0]
 80a3906:	681b      	ldr	r3, [r3, #0]
 80a3908:	9301      	str	r3, [sp, #4]
 80a390a:	bd08      	pop	{r3, pc}
 80a390c:	080601d8 	.word	0x080601d8

080a3910 <HAL_USB_USART_Begin>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
 80a3910:	b508      	push	{r3, lr}
 80a3912:	4b02      	ldr	r3, [pc, #8]	; (80a391c <HAL_USB_USART_Begin+0xc>)
 80a3914:	681b      	ldr	r3, [r3, #0]
 80a3916:	685b      	ldr	r3, [r3, #4]
 80a3918:	9301      	str	r3, [sp, #4]
 80a391a:	bd08      	pop	{r3, pc}
 80a391c:	080601d8 	.word	0x080601d8

080a3920 <HAL_USB_USART_Available_Data>:
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a3920:	b508      	push	{r3, lr}
 80a3922:	4b02      	ldr	r3, [pc, #8]	; (80a392c <HAL_USB_USART_Available_Data+0xc>)
 80a3924:	681b      	ldr	r3, [r3, #0]
 80a3926:	691b      	ldr	r3, [r3, #16]
 80a3928:	9301      	str	r3, [sp, #4]
 80a392a:	bd08      	pop	{r3, pc}
 80a392c:	080601d8 	.word	0x080601d8

080a3930 <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a3930:	b508      	push	{r3, lr}
 80a3932:	4b02      	ldr	r3, [pc, #8]	; (80a393c <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a3934:	681b      	ldr	r3, [r3, #0]
 80a3936:	695b      	ldr	r3, [r3, #20]
 80a3938:	9301      	str	r3, [sp, #4]
 80a393a:	bd08      	pop	{r3, pc}
 80a393c:	080601d8 	.word	0x080601d8

080a3940 <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a3940:	b508      	push	{r3, lr}
 80a3942:	4b02      	ldr	r3, [pc, #8]	; (80a394c <HAL_USB_USART_Receive_Data+0xc>)
 80a3944:	681b      	ldr	r3, [r3, #0]
 80a3946:	699b      	ldr	r3, [r3, #24]
 80a3948:	9301      	str	r3, [sp, #4]
 80a394a:	bd08      	pop	{r3, pc}
 80a394c:	080601d8 	.word	0x080601d8

080a3950 <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a3950:	b508      	push	{r3, lr}
 80a3952:	4b02      	ldr	r3, [pc, #8]	; (80a395c <HAL_USB_USART_Send_Data+0xc>)
 80a3954:	681b      	ldr	r3, [r3, #0]
 80a3956:	69db      	ldr	r3, [r3, #28]
 80a3958:	9301      	str	r3, [sp, #4]
 80a395a:	bd08      	pop	{r3, pc}
 80a395c:	080601d8 	.word	0x080601d8

080a3960 <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a3960:	b508      	push	{r3, lr}
 80a3962:	4b02      	ldr	r3, [pc, #8]	; (80a396c <HAL_USB_USART_Flush_Data+0xc>)
 80a3964:	681b      	ldr	r3, [r3, #0]
 80a3966:	6a1b      	ldr	r3, [r3, #32]
 80a3968:	9301      	str	r3, [sp, #4]
 80a396a:	bd08      	pop	{r3, pc}
 80a396c:	080601d8 	.word	0x080601d8

080a3970 <panic_>:
DYNALIB_FN(9, services, LED_Toggle, void(Led_TypeDef))
DYNALIB_FN(10, services, LED_Fade, void(Led_TypeDef))
DYNALIB_FN(11, services, Get_LED_Brightness, uint8_t(void))

DYNALIB_FN(12, services, set_logger_output, void(debug_output_fn, LoggerOutputLevel)) // Deprecated
DYNALIB_FN(13, services, panic_, void(ePanicCode, void*, void(*)(uint32_t)))
 80a3970:	b508      	push	{r3, lr}
 80a3972:	4b02      	ldr	r3, [pc, #8]	; (80a397c <panic_+0xc>)
 80a3974:	681b      	ldr	r3, [r3, #0]
 80a3976:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a3978:	9301      	str	r3, [sp, #4]
 80a397a:	bd08      	pop	{r3, pc}
 80a397c:	080201a8 	.word	0x080201a8

080a3980 <set_system_mode>:
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a3980:	b508      	push	{r3, lr}
 80a3982:	4b02      	ldr	r3, [pc, #8]	; (80a398c <set_system_mode+0xc>)
 80a3984:	681b      	ldr	r3, [r3, #0]
 80a3986:	685b      	ldr	r3, [r3, #4]
 80a3988:	9301      	str	r3, [sp, #4]
 80a398a:	bd08      	pop	{r3, pc}
 80a398c:	080601a4 	.word	0x080601a4

080a3990 <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a3990:	b508      	push	{r3, lr}
 80a3992:	4b02      	ldr	r3, [pc, #8]	; (80a399c <system_delay_ms+0xc>)
 80a3994:	681b      	ldr	r3, [r3, #0]
 80a3996:	695b      	ldr	r3, [r3, #20]
 80a3998:	9301      	str	r3, [sp, #4]
 80a399a:	bd08      	pop	{r3, pc}
 80a399c:	080601a4 	.word	0x080601a4

080a39a0 <application_thread_current>:
DYNALIB_FN(15, system, system_get_flag, int(system_flag_t, uint8_t*, void*))
DYNALIB_FN(16, system, Spark_Prepare_For_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))
DYNALIB_FN(17, system, Spark_Save_Firmware_Chunk, int(FileTransfer::Descriptor&, const uint8_t*, void*))
DYNALIB_FN(18, system, Spark_Finish_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))

DYNALIB_FN(19, system, application_thread_current, uint8_t(void*))
 80a39a0:	b508      	push	{r3, lr}
 80a39a2:	4b02      	ldr	r3, [pc, #8]	; (80a39ac <application_thread_current+0xc>)
 80a39a4:	681b      	ldr	r3, [r3, #0]
 80a39a6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a39a8:	9301      	str	r3, [sp, #4]
 80a39aa:	bd08      	pop	{r3, pc}
 80a39ac:	080601a4 	.word	0x080601a4

080a39b0 <application_thread_invoke>:
DYNALIB_FN(20, system, system_thread_current, uint8_t(void*))
DYNALIB_FN(21, system, application_thread_invoke, uint8_t(void(*)(void*), void*, void*))
 80a39b0:	b508      	push	{r3, lr}
 80a39b2:	4b02      	ldr	r3, [pc, #8]	; (80a39bc <application_thread_invoke+0xc>)
 80a39b4:	681b      	ldr	r3, [r3, #0]
 80a39b6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a39b8:	9301      	str	r3, [sp, #4]
 80a39ba:	bd08      	pop	{r3, pc}
 80a39bc:	080601a4 	.word	0x080601a4

080a39c0 <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
 80a39c0:	b508      	push	{r3, lr}
 80a39c2:	4b03      	ldr	r3, [pc, #12]	; (80a39d0 <system_ctrl_set_app_request_handler+0x10>)
 80a39c4:	681b      	ldr	r3, [r3, #0]
 80a39c6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a39ca:	9301      	str	r3, [sp, #4]
 80a39cc:	bd08      	pop	{r3, pc}
 80a39ce:	0000      	.short	0x0000
 80a39d0:	080601a4 	.word	0x080601a4

080a39d4 <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
 80a39d4:	b508      	push	{r3, lr}
 80a39d6:	4b03      	ldr	r3, [pc, #12]	; (80a39e4 <system_ctrl_set_result+0x10>)
 80a39d8:	681b      	ldr	r3, [r3, #0]
 80a39da:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80a39de:	9301      	str	r3, [sp, #4]
 80a39e0:	bd08      	pop	{r3, pc}
 80a39e2:	0000      	.short	0x0000
 80a39e4:	080601a4 	.word	0x080601a4

080a39e8 <network_ready>:

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a39e8:	b508      	push	{r3, lr}
 80a39ea:	4b02      	ldr	r3, [pc, #8]	; (80a39f4 <network_ready+0xc>)
 80a39ec:	681b      	ldr	r3, [r3, #0]
 80a39ee:	691b      	ldr	r3, [r3, #16]
 80a39f0:	9301      	str	r3, [sp, #4]
 80a39f2:	bd08      	pop	{r3, pc}
 80a39f4:	080601c8 	.word	0x080601c8

080a39f8 <spark_send_event>:
DYNALIB_FN(3, system_cloud, spark_cloud_flag_connect, void(void))
DYNALIB_FN(4, system_cloud, spark_cloud_flag_disconnect, void(void))
DYNALIB_FN(5, system_cloud, spark_cloud_flag_connected, bool(void))
DYNALIB_FN(6, system_cloud, system_cloud_protocol_instance, ProtocolFacade*(void))
DYNALIB_FN(7, system_cloud, spark_deviceID, String(void))
DYNALIB_FN(8, system_cloud, spark_send_event, bool(const char*, const char*, int, uint32_t, void*))
 80a39f8:	b508      	push	{r3, lr}
 80a39fa:	4b02      	ldr	r3, [pc, #8]	; (80a3a04 <spark_send_event+0xc>)
 80a39fc:	681b      	ldr	r3, [r3, #0]
 80a39fe:	6a1b      	ldr	r3, [r3, #32]
 80a3a00:	9301      	str	r3, [sp, #4]
 80a3a02:	bd08      	pop	{r3, pc}
 80a3a04:	080601cc 	.word	0x080601cc

080a3a08 <spark_subscribe>:
DYNALIB_FN(9, system_cloud, spark_subscribe, bool(const char*, EventHandler, void*, Spark_Subscription_Scope_TypeDef, const char*, void*))
 80a3a08:	b508      	push	{r3, lr}
 80a3a0a:	4b02      	ldr	r3, [pc, #8]	; (80a3a14 <spark_subscribe+0xc>)
 80a3a0c:	681b      	ldr	r3, [r3, #0]
 80a3a0e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a3a10:	9301      	str	r3, [sp, #4]
 80a3a12:	bd08      	pop	{r3, pc}
 80a3a14:	080601cc 	.word	0x080601cc

080a3a18 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time_t*, void*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, particle::protocol::connection_properties_t*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
 80a3a18:	b508      	push	{r3, lr}
 80a3a1a:	4b02      	ldr	r3, [pc, #8]	; (80a3a24 <spark_set_random_seed_from_cloud_handler+0xc>)
 80a3a1c:	681b      	ldr	r3, [r3, #0]
 80a3a1e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a3a20:	9301      	str	r3, [sp, #4]
 80a3a22:	bd08      	pop	{r3, pc}
 80a3a24:	080601cc 	.word	0x080601cc

080a3a28 <malloc>:

#include "dynalib.h"

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
 80a3a28:	b508      	push	{r3, lr}
 80a3a2a:	4b02      	ldr	r3, [pc, #8]	; (80a3a34 <malloc+0xc>)
 80a3a2c:	681b      	ldr	r3, [r3, #0]
 80a3a2e:	681b      	ldr	r3, [r3, #0]
 80a3a30:	9301      	str	r3, [sp, #4]
 80a3a32:	bd08      	pop	{r3, pc}
 80a3a34:	080601a0 	.word	0x080601a0

080a3a38 <free>:
DYNALIB_FN(1, rt, free, void(void*))
 80a3a38:	b508      	push	{r3, lr}
 80a3a3a:	4b02      	ldr	r3, [pc, #8]	; (80a3a44 <free+0xc>)
 80a3a3c:	681b      	ldr	r3, [r3, #0]
 80a3a3e:	685b      	ldr	r3, [r3, #4]
 80a3a40:	9301      	str	r3, [sp, #4]
 80a3a42:	bd08      	pop	{r3, pc}
 80a3a44:	080601a0 	.word	0x080601a0

080a3a48 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a3a48:	b508      	push	{r3, lr}
 80a3a4a:	4b02      	ldr	r3, [pc, #8]	; (80a3a54 <realloc+0xc>)
 80a3a4c:	681b      	ldr	r3, [r3, #0]
 80a3a4e:	689b      	ldr	r3, [r3, #8]
 80a3a50:	9301      	str	r3, [sp, #4]
 80a3a52:	bd08      	pop	{r3, pc}
 80a3a54:	080601a0 	.word	0x080601a0

080a3a58 <sprintf>:
DYNALIB_FN(3, rt, sprintf, int(char*, const char*, ...))
 80a3a58:	b508      	push	{r3, lr}
 80a3a5a:	4b02      	ldr	r3, [pc, #8]	; (80a3a64 <sprintf+0xc>)
 80a3a5c:	681b      	ldr	r3, [r3, #0]
 80a3a5e:	68db      	ldr	r3, [r3, #12]
 80a3a60:	9301      	str	r3, [sp, #4]
 80a3a62:	bd08      	pop	{r3, pc}
 80a3a64:	080601a0 	.word	0x080601a0

080a3a68 <vsnprintf>:
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
 80a3a68:	b508      	push	{r3, lr}
 80a3a6a:	4b02      	ldr	r3, [pc, #8]	; (80a3a74 <vsnprintf+0xc>)
 80a3a6c:	681b      	ldr	r3, [r3, #0]
 80a3a6e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a3a70:	9301      	str	r3, [sp, #4]
 80a3a72:	bd08      	pop	{r3, pc}
 80a3a74:	080601a0 	.word	0x080601a0

080a3a78 <abort>:
DYNALIB_FN(10, rt, vsniprintf, int(char*, size_t, const char*, va_list))
DYNALIB_FN(11, rt, abort, void(void))
 80a3a78:	b508      	push	{r3, lr}
 80a3a7a:	4b02      	ldr	r3, [pc, #8]	; (80a3a84 <abort+0xc>)
 80a3a7c:	681b      	ldr	r3, [r3, #0]
 80a3a7e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a3a80:	9301      	str	r3, [sp, #4]
 80a3a82:	bd08      	pop	{r3, pc}
 80a3a84:	080601a0 	.word	0x080601a0

080a3a88 <_malloc_r>:
DYNALIB_FN(12, rt, _malloc_r, void*(struct _reent*, size_t))
 80a3a88:	b508      	push	{r3, lr}
 80a3a8a:	4b02      	ldr	r3, [pc, #8]	; (80a3a94 <_malloc_r+0xc>)
 80a3a8c:	681b      	ldr	r3, [r3, #0]
 80a3a8e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a3a90:	9301      	str	r3, [sp, #4]
 80a3a92:	bd08      	pop	{r3, pc}
 80a3a94:	080601a0 	.word	0x080601a0

080a3a98 <_ZN8SPIClassD1Ev>:
  Mutex mutex_;
#endif

public:
  SPIClass(HAL_SPI_Interface spi);
  virtual ~SPIClass() {};
 80a3a98:	4770      	bx	lr

080a3a9a <_ZN8SPIClassD0Ev>:
 80a3a9a:	b510      	push	{r4, lr}
 80a3a9c:	4604      	mov	r4, r0
 80a3a9e:	f7fc fafe 	bl	80a009e <_ZdlPv>
 80a3aa2:	4620      	mov	r0, r4
 80a3aa4:	bd10      	pop	{r4, pc}
	...

080a3aa8 <_ZN8SPIClassC1E17HAL_SPI_Interface>:
  if (!info->enabled || info->default_settings)
    return particle::__SPISettings();
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a3aa8:	b570      	push	{r4, r5, r6, lr}
 80a3aaa:	4604      	mov	r4, r0
 80a3aac:	460e      	mov	r6, r1
 80a3aae:	4b07      	ldr	r3, [pc, #28]	; (80a3acc <_ZN8SPIClassC1E17HAL_SPI_Interface+0x24>)
    Mutex(os_mutex_t handle) : handle_(handle) {}

    /**
     * Creates a new mutex.
     */
    Mutex() : handle_(nullptr)
 80a3ab0:	2500      	movs	r5, #0
 80a3ab2:	6003      	str	r3, [r0, #0]
 80a3ab4:	f840 5f0c 	str.w	r5, [r0, #12]!
    {
        os_mutex_create(&handle_);
 80a3ab8:	f7ff fea0 	bl	80a37fc <os_mutex_create>
{
  _spi = spi;
  HAL_SPI_Init(_spi);
 80a3abc:	4630      	mov	r0, r6
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
{
  _spi = spi;
 80a3abe:	7126      	strb	r6, [r4, #4]
  HAL_SPI_Init(_spi);
 80a3ac0:	f7ff fe64 	bl	80a378c <HAL_SPI_Init>
  dividerReference = SPI_CLK_SYSTEM;     // 0 indicates the system clock
 80a3ac4:	60a5      	str	r5, [r4, #8]
}
 80a3ac6:	4620      	mov	r0, r4
 80a3ac8:	bd70      	pop	{r4, r5, r6, pc}
 80a3aca:	bf00      	nop
 80a3acc:	080a6ac4 	.word	0x080a6ac4

080a3ad0 <_ZN8SPIClass9isEnabledEv>:
  //To Do
}

bool SPIClass::isEnabled()
{
  return HAL_SPI_Is_Enabled(_spi);
 80a3ad0:	7900      	ldrb	r0, [r0, #4]
 80a3ad2:	f7ff be63 	b.w	80a379c <HAL_SPI_Is_Enabled>
	...

080a3ad8 <_GLOBAL__sub_I_System>:
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a3ad8:	f64f 739c 	movw	r3, #65436	; 0xff9c
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
}
 80a3adc:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a3ade:	4c0d      	ldr	r4, [pc, #52]	; (80a3b14 <_GLOBAL__sub_I_System+0x3c>)
 80a3ae0:	2500      	movs	r5, #0
 80a3ae2:	8063      	strh	r3, [r4, #2]
 80a3ae4:	f64f 73ff 	movw	r3, #65535	; 0xffff

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a3ae8:	4628      	mov	r0, r5
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a3aea:	80a3      	strh	r3, [r4, #4]
 80a3aec:	7025      	strb	r5, [r4, #0]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a3aee:	f7ff ff47 	bl	80a3980 <set_system_mode>
        return get_flag(flag) != 0;
    }

    inline int resetReason() const
    {
        int reason = RESET_REASON_NONE;
 80a3af2:	a802      	add	r0, sp, #8
 80a3af4:	f840 5d04 	str.w	r5, [r0, #-4]!
        HAL_Core_Get_Last_Reset_Info(&reason, nullptr, nullptr);
 80a3af8:	462a      	mov	r2, r5
 80a3afa:	4629      	mov	r1, r5
 80a3afc:	f7ff fe76 	bl	80a37ec <HAL_Core_Get_Last_Reset_Info>
        return reason;
 80a3b00:	9b01      	ldr	r3, [sp, #4]
class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
        if (resetReason() == RESET_REASON_POWER_MANAGEMENT) {
 80a3b02:	2b1e      	cmp	r3, #30
 80a3b04:	d104      	bne.n	80a3b10 <_GLOBAL__sub_I_System+0x38>
            // Woken up from standby mode
            sleepResult_ = SleepResult(WAKEUP_REASON_PIN_OR_RTC, SYSTEM_ERROR_NONE, WKP);
 80a3b06:	2303      	movs	r3, #3
 80a3b08:	7023      	strb	r3, [r4, #0]
 80a3b0a:	2311      	movs	r3, #17
 80a3b0c:	8065      	strh	r5, [r4, #2]
 80a3b0e:	80a3      	strh	r3, [r4, #4]
 80a3b10:	b003      	add	sp, #12
 80a3b12:	bd30      	pop	{r4, r5, pc}
 80a3b14:	200013ce 	.word	0x200013ce

080a3b18 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a3b18:	b510      	push	{r4, lr}
 80a3b1a:	4604      	mov	r4, r0
{
	free(buffer);
 80a3b1c:	6800      	ldr	r0, [r0, #0]
 80a3b1e:	f7ff ff8b 	bl	80a3a38 <free>
}
 80a3b22:	4620      	mov	r0, r4
 80a3b24:	bd10      	pop	{r4, pc}

080a3b26 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a3b26:	b510      	push	{r4, lr}
 80a3b28:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a3b2a:	6800      	ldr	r0, [r0, #0]
 80a3b2c:	b108      	cbz	r0, 80a3b32 <_ZN6String10invalidateEv+0xc>
 80a3b2e:	f7ff ff83 	bl	80a3a38 <free>
	buffer = NULL;
 80a3b32:	2300      	movs	r3, #0
 80a3b34:	6023      	str	r3, [r4, #0]
	capacity = len = 0;
 80a3b36:	60a3      	str	r3, [r4, #8]
 80a3b38:	6063      	str	r3, [r4, #4]
 80a3b3a:	bd10      	pop	{r4, pc}

080a3b3c <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a3b3c:	b538      	push	{r3, r4, r5, lr}
 80a3b3e:	4604      	mov	r4, r0
 80a3b40:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a3b42:	6800      	ldr	r0, [r0, #0]
 80a3b44:	3101      	adds	r1, #1
 80a3b46:	f7ff ff7f 	bl	80a3a48 <realloc>
	if (newbuffer) {
 80a3b4a:	b110      	cbz	r0, 80a3b52 <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a3b4c:	e884 0021 	stmia.w	r4, {r0, r5}
		return 1;
 80a3b50:	2001      	movs	r0, #1
	}
	return 0;
}
 80a3b52:	bd38      	pop	{r3, r4, r5, pc}

080a3b54 <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a3b54:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a3b56:	6803      	ldr	r3, [r0, #0]
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a3b58:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a3b5a:	b113      	cbz	r3, 80a3b62 <_ZN6String7reserveEj+0xe>
 80a3b5c:	6843      	ldr	r3, [r0, #4]
 80a3b5e:	428b      	cmp	r3, r1
 80a3b60:	d207      	bcs.n	80a3b72 <_ZN6String7reserveEj+0x1e>
	if (changeBuffer(size)) {
 80a3b62:	4620      	mov	r0, r4
 80a3b64:	f7ff ffea 	bl	80a3b3c <_ZN6String12changeBufferEj>
 80a3b68:	b120      	cbz	r0, 80a3b74 <_ZN6String7reserveEj+0x20>
		if (len == 0) buffer[0] = 0;
 80a3b6a:	68a3      	ldr	r3, [r4, #8]
 80a3b6c:	b90b      	cbnz	r3, 80a3b72 <_ZN6String7reserveEj+0x1e>
 80a3b6e:	6822      	ldr	r2, [r4, #0]
 80a3b70:	7013      	strb	r3, [r2, #0]
 80a3b72:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
 80a3b74:	bd10      	pop	{r4, pc}

080a3b76 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a3b76:	b570      	push	{r4, r5, r6, lr}
 80a3b78:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a3b7a:	4611      	mov	r1, r2
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a3b7c:	4604      	mov	r4, r0
 80a3b7e:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a3b80:	f7ff ffe8 	bl	80a3b54 <_ZN6String7reserveEj>
 80a3b84:	b918      	cbnz	r0, 80a3b8e <_ZN6String4copyEPKcj+0x18>
		invalidate();
 80a3b86:	4620      	mov	r0, r4
 80a3b88:	f7ff ffcd 	bl	80a3b26 <_ZN6String10invalidateEv>
		return *this;
 80a3b8c:	e009      	b.n	80a3ba2 <_ZN6String4copyEPKcj+0x2c>
	}
	len = length;
	memcpy(buffer, cstr, length);
 80a3b8e:	462a      	mov	r2, r5
 80a3b90:	4631      	mov	r1, r6
{
	if (!reserve(length)) {
		invalidate();
		return *this;
	}
	len = length;
 80a3b92:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
 80a3b94:	6820      	ldr	r0, [r4, #0]
 80a3b96:	f001 ffff 	bl	80a5b98 <memcpy>
	buffer[len] = 0;
 80a3b9a:	6822      	ldr	r2, [r4, #0]
 80a3b9c:	68a3      	ldr	r3, [r4, #8]
 80a3b9e:	2100      	movs	r1, #0
 80a3ba0:	54d1      	strb	r1, [r2, r3]
	return *this;
}
 80a3ba2:	4620      	mov	r0, r4
 80a3ba4:	bd70      	pop	{r4, r5, r6, pc}

080a3ba6 <_ZN6StringC1EPK19__FlashStringHelper>:
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a3ba6:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a3ba8:	2300      	movs	r3, #0
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a3baa:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a3bac:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a3bae:	6043      	str	r3, [r0, #4]
	len = 0;
 80a3bb0:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a3bb2:	7303      	strb	r3, [r0, #12]

String::String(const __FlashStringHelper *pstr)
{
	init();
	const char* cstr = reinterpret_cast<const char*>(pstr);
	if (cstr) copy(cstr, strlen(cstr));
 80a3bb4:	460d      	mov	r5, r1
 80a3bb6:	b139      	cbz	r1, 80a3bc8 <_ZN6StringC1EPK19__FlashStringHelper+0x22>
 80a3bb8:	4608      	mov	r0, r1
 80a3bba:	f002 f8a0 	bl	80a5cfe <strlen>
 80a3bbe:	4629      	mov	r1, r5
 80a3bc0:	4602      	mov	r2, r0
 80a3bc2:	4620      	mov	r0, r4
 80a3bc4:	f7ff ffd7 	bl	80a3b76 <_ZN6String4copyEPKcj>
}
 80a3bc8:	4620      	mov	r0, r4
 80a3bca:	bd38      	pop	{r3, r4, r5, pc}

080a3bcc <_ZN6StringaSERKS_>:
}
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
 80a3bcc:	4288      	cmp	r0, r1
	rhs.len = 0;
}
#endif

String & String::operator = (const String &rhs)
{
 80a3bce:	b510      	push	{r4, lr}
 80a3bd0:	460b      	mov	r3, r1
 80a3bd2:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
 80a3bd4:	d007      	beq.n	80a3be6 <_ZN6StringaSERKS_+0x1a>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
 80a3bd6:	6809      	ldr	r1, [r1, #0]
 80a3bd8:	b119      	cbz	r1, 80a3be2 <_ZN6StringaSERKS_+0x16>
 80a3bda:	689a      	ldr	r2, [r3, #8]
 80a3bdc:	f7ff ffcb 	bl	80a3b76 <_ZN6String4copyEPKcj>
 80a3be0:	e001      	b.n	80a3be6 <_ZN6StringaSERKS_+0x1a>
	else invalidate();
 80a3be2:	f7ff ffa0 	bl	80a3b26 <_ZN6String10invalidateEv>

	return *this;
}
 80a3be6:	4620      	mov	r0, r4
 80a3be8:	bd10      	pop	{r4, pc}

080a3bea <_ZN6StringC1ERKS_>:
{
	init();
	if (cstr) copy(cstr, length);
}

String::String(const String &value)
 80a3bea:	b510      	push	{r4, lr}
 80a3bec:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a3bee:	2300      	movs	r3, #0
 80a3bf0:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a3bf2:	6043      	str	r3, [r0, #4]
	len = 0;
 80a3bf4:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a3bf6:	7303      	strb	r3, [r0, #12]
}

String::String(const String &value)
{
	init();
	*this = value;
 80a3bf8:	f7ff ffe8 	bl	80a3bcc <_ZN6StringaSERKS_>
}
 80a3bfc:	4620      	mov	r0, r4
 80a3bfe:	bd10      	pop	{r4, pc}

080a3c00 <_ZN6String6concatEPKcj>:
{
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
 80a3c00:	b570      	push	{r4, r5, r6, lr}
 80a3c02:	4604      	mov	r4, r0
	unsigned int newlen = len + length;
	if (!cstr) return 0;
 80a3c04:	460e      	mov	r6, r1
 80a3c06:	b909      	cbnz	r1, 80a3c0c <_ZN6String6concatEPKcj+0xc>
 80a3c08:	2000      	movs	r0, #0
 80a3c0a:	bd70      	pop	{r4, r5, r6, pc}
	if (length == 0) return 1;
 80a3c0c:	b16a      	cbz	r2, 80a3c2a <_ZN6String6concatEPKcj+0x2a>
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
 80a3c0e:	6883      	ldr	r3, [r0, #8]
 80a3c10:	18d5      	adds	r5, r2, r3
	if (!cstr) return 0;
	if (length == 0) return 1;
	if (!reserve(newlen)) return 0;
 80a3c12:	4629      	mov	r1, r5
 80a3c14:	f7ff ff9e 	bl	80a3b54 <_ZN6String7reserveEj>
 80a3c18:	2800      	cmp	r0, #0
 80a3c1a:	d0f5      	beq.n	80a3c08 <_ZN6String6concatEPKcj+0x8>
	strcpy(buffer + len, cstr);
 80a3c1c:	6820      	ldr	r0, [r4, #0]
 80a3c1e:	68a3      	ldr	r3, [r4, #8]
 80a3c20:	4631      	mov	r1, r6
 80a3c22:	4418      	add	r0, r3
 80a3c24:	f002 f847 	bl	80a5cb6 <strcpy>
	len = newlen;
 80a3c28:	60a5      	str	r5, [r4, #8]

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
	if (!cstr) return 0;
	if (length == 0) return 1;
 80a3c2a:	2001      	movs	r0, #1
	if (!reserve(newlen)) return 0;
	strcpy(buffer + len, cstr);
	len = newlen;
	return 1;
}
 80a3c2c:	bd70      	pop	{r4, r5, r6, pc}

080a3c2e <_ZN6String6concatEc>:
unsigned char String::concat(const __FlashStringHelper * str) {
	return concat(reinterpret_cast<const char*>(str));
}

unsigned char String::concat(char c)
{
 80a3c2e:	b507      	push	{r0, r1, r2, lr}
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
 80a3c30:	2300      	movs	r3, #0
}

unsigned char String::concat(char c)
{
	char buf[2];
	buf[0] = c;
 80a3c32:	f88d 1004 	strb.w	r1, [sp, #4]
	buf[1] = 0;
	return concat(buf, 1);
 80a3c36:	2201      	movs	r2, #1
 80a3c38:	a901      	add	r1, sp, #4

unsigned char String::concat(char c)
{
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
 80a3c3a:	f88d 3005 	strb.w	r3, [sp, #5]
	return concat(buf, 1);
 80a3c3e:	f7ff ffdf 	bl	80a3c00 <_ZN6String6concatEPKcj>
}
 80a3c42:	b003      	add	sp, #12
 80a3c44:	f85d fb04 	ldr.w	pc, [sp], #4

080a3c48 <_ZN6StringixEj>:
}

char & String::operator[](unsigned int index)
{
	static char dummy_writable_char;
	if (index >= len || !buffer) {
 80a3c48:	6883      	ldr	r3, [r0, #8]
 80a3c4a:	428b      	cmp	r3, r1
 80a3c4c:	d901      	bls.n	80a3c52 <_ZN6StringixEj+0xa>
 80a3c4e:	6800      	ldr	r0, [r0, #0]
 80a3c50:	b918      	cbnz	r0, 80a3c5a <_ZN6StringixEj+0x12>
		dummy_writable_char = 0;
 80a3c52:	4803      	ldr	r0, [pc, #12]	; (80a3c60 <_ZN6StringixEj+0x18>)
 80a3c54:	2300      	movs	r3, #0
 80a3c56:	7003      	strb	r3, [r0, #0]
		return dummy_writable_char;
 80a3c58:	4770      	bx	lr
	}
	return buffer[index];
 80a3c5a:	4408      	add	r0, r1
}
 80a3c5c:	4770      	bx	lr
 80a3c5e:	bf00      	nop
 80a3c60:	200013d4 	.word	0x200013d4

080a3c64 <_ZN6String11toUpperCaseEv>:
        }
        return *this;
}

String& String::toUpperCase(void)
{
 80a3c64:	b538      	push	{r3, r4, r5, lr}
	if (buffer) {
 80a3c66:	6804      	ldr	r4, [r0, #0]
        }
        return *this;
}

String& String::toUpperCase(void)
{
 80a3c68:	4605      	mov	r5, r0
	if (buffer) {
 80a3c6a:	b134      	cbz	r4, 80a3c7a <_ZN6String11toUpperCaseEv+0x16>
            for (char *p = buffer; *p; p++) {
 80a3c6c:	7820      	ldrb	r0, [r4, #0]
 80a3c6e:	b120      	cbz	r0, 80a3c7a <_ZN6String11toUpperCaseEv+0x16>
                    *p = toupper(*p);
 80a3c70:	f002 f956 	bl	80a5f20 <toupper>
 80a3c74:	f804 0b01 	strb.w	r0, [r4], #1
}

String& String::toUpperCase(void)
{
	if (buffer) {
            for (char *p = buffer; *p; p++) {
 80a3c78:	e7f8      	b.n	80a3c6c <_ZN6String11toUpperCaseEv+0x8>
                    *p = toupper(*p);
            }
        }
        return *this;
}
 80a3c7a:	4628      	mov	r0, r5
 80a3c7c:	bd38      	pop	{r3, r4, r5, pc}

080a3c7e <_ZNK6String5toIntEv>:
/*  Parsing / Conversion                     */
/*********************************************/

long String::toInt(void) const
{
	if (buffer) return atol(buffer);
 80a3c7e:	6800      	ldr	r0, [r0, #0]
 80a3c80:	b108      	cbz	r0, 80a3c86 <_ZNK6String5toIntEv+0x8>
 80a3c82:	f001 bf77 	b.w	80a5b74 <atol>
	return 0;
}
 80a3c86:	4770      	bx	lr

080a3c88 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a3c88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a3c8a:	4606      	mov	r6, r0
 80a3c8c:	460d      	mov	r5, r1
 80a3c8e:	188f      	adds	r7, r1, r2
  size_t n = 0;
 80a3c90:	2400      	movs	r4, #0
  while (size--) {
 80a3c92:	42bd      	cmp	r5, r7
 80a3c94:	d00c      	beq.n	80a3cb0 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a3c96:	6833      	ldr	r3, [r6, #0]
 80a3c98:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a3c9c:	689b      	ldr	r3, [r3, #8]
 80a3c9e:	4630      	mov	r0, r6
 80a3ca0:	4798      	blx	r3
     if (chunk>=0)
 80a3ca2:	2800      	cmp	r0, #0
 80a3ca4:	db01      	blt.n	80a3caa <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a3ca6:	4404      	add	r4, r0

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
 80a3ca8:	e7f3      	b.n	80a3c92 <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
 80a3caa:	2c00      	cmp	r4, #0
 80a3cac:	bf08      	it	eq
 80a3cae:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
 80a3cb0:	4620      	mov	r0, r4
 80a3cb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a3cb4 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a3cb4:	b570      	push	{r4, r5, r6, lr}
 80a3cb6:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a3cb8:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a3cba:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 80a3cbc:	b149      	cbz	r1, 80a3cd2 <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a3cbe:	f002 f81e 	bl	80a5cfe <strlen>
 80a3cc2:	682b      	ldr	r3, [r5, #0]
 80a3cc4:	4602      	mov	r2, r0
 80a3cc6:	4621      	mov	r1, r4
 80a3cc8:	4628      	mov	r0, r5
    }
 80a3cca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 80a3cce:	68db      	ldr	r3, [r3, #12]
 80a3cd0:	4718      	bx	r3
    }
 80a3cd2:	bd70      	pop	{r4, r5, r6, pc}

080a3cd4 <_ZN5Print5printEPKc>:
 80a3cd4:	b508      	push	{r3, lr}
 80a3cd6:	f7ff ffed 	bl	80a3cb4 <_ZN5Print5writeEPKc>
 80a3cda:	bd08      	pop	{r3, pc}

080a3cdc <_ZN5Print5printEc>:
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
 80a3cdc:	6803      	ldr	r3, [r0, #0]
 80a3cde:	689b      	ldr	r3, [r3, #8]
 80a3ce0:	4718      	bx	r3

080a3ce2 <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a3ce2:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a3ce4:	210d      	movs	r1, #13
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a3ce6:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a3ce8:	f7ff fff8 	bl	80a3cdc <_ZN5Print5printEc>
  n += print('\n');
 80a3cec:	210a      	movs	r1, #10
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
  size_t n = print('\r');
 80a3cee:	4604      	mov	r4, r0
  n += print('\n');
 80a3cf0:	4628      	mov	r0, r5
 80a3cf2:	f7ff fff3 	bl	80a3cdc <_ZN5Print5printEc>
  return n;
}
 80a3cf6:	4420      	add	r0, r4
 80a3cf8:	bd38      	pop	{r3, r4, r5, pc}

080a3cfa <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
 80a3cfa:	b538      	push	{r3, r4, r5, lr}
 80a3cfc:	4605      	mov	r5, r0
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a3cfe:	f7ff ffd9 	bl	80a3cb4 <_ZN5Print5writeEPKc>
 80a3d02:	4604      	mov	r4, r0
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
 80a3d04:	4628      	mov	r0, r5
 80a3d06:	f7ff ffec 	bl	80a3ce2 <_ZN5Print7printlnEv>
  return n;
}
 80a3d0a:	4420      	add	r0, r4
 80a3d0c:	bd38      	pop	{r3, r4, r5, pc}

080a3d0e <_ZN5Print11printNumberEmh>:
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a3d0e:	2a01      	cmp	r2, #1
 80a3d10:	bf98      	it	ls
 80a3d12:	220a      	movls	r2, #10
  return println(reinterpret_cast<const char*>(str));
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a3d14:	b530      	push	{r4, r5, lr}
 80a3d16:	460b      	mov	r3, r1
 80a3d18:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a3d1a:	2100      	movs	r1, #0
 80a3d1c:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
 80a3d20:	f10d 0423 	add.w	r4, sp, #35	; 0x23
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    unsigned long m = n;
    n /= base;
 80a3d24:	fbb3 f5f2 	udiv	r5, r3, r2
    char c = m - base * n;
 80a3d28:	fb05 3312 	mls	r3, r5, r2, r3
 80a3d2c:	b2db      	uxtb	r3, r3
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a3d2e:	2b09      	cmp	r3, #9
 80a3d30:	bf94      	ite	ls
 80a3d32:	3330      	addls	r3, #48	; 0x30
 80a3d34:	3337      	addhi	r3, #55	; 0x37
 80a3d36:	b2db      	uxtb	r3, r3
 80a3d38:	4621      	mov	r1, r4
 80a3d3a:	f804 3901 	strb.w	r3, [r4], #-1
 80a3d3e:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 80a3d40:	2d00      	cmp	r5, #0
 80a3d42:	d1ef      	bne.n	80a3d24 <_ZN5Print11printNumberEmh+0x16>
    n /= base;
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 80a3d44:	f7ff ffb6 	bl	80a3cb4 <_ZN5Print5writeEPKc>
}
 80a3d48:	b00b      	add	sp, #44	; 0x2c
 80a3d4a:	bd30      	pop	{r4, r5, pc}

080a3d4c <_ZN5Print5printEmi>:
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
{
 80a3d4c:	b410      	push	{r4}
  if (base == 0) return write(n);
 80a3d4e:	b922      	cbnz	r2, 80a3d5a <_ZN5Print5printEmi+0xe>
 80a3d50:	6803      	ldr	r3, [r0, #0]
 80a3d52:	b2c9      	uxtb	r1, r1
 80a3d54:	689b      	ldr	r3, [r3, #8]
  else return printNumber(n, base);
}
 80a3d56:	bc10      	pop	{r4}
  }
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
 80a3d58:	4718      	bx	r3
  else return printNumber(n, base);
 80a3d5a:	b2d2      	uxtb	r2, r2
}
 80a3d5c:	bc10      	pop	{r4}
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 80a3d5e:	f7ff bfd6 	b.w	80a3d0e <_ZN5Print11printNumberEmh>

080a3d62 <_ZN5Print5printEhi>:
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
 80a3d62:	f7ff bff3 	b.w	80a3d4c <_ZN5Print5printEmi>

080a3d66 <_ZN5Print7printlnEji>:
  n += println();
  return n;
}

size_t Print::println(unsigned int num, int base)
{
 80a3d66:	b538      	push	{r3, r4, r5, lr}
 80a3d68:	4605      	mov	r5, r0
  return print((long) n, base);
}

size_t Print::print(unsigned int n, int base)
{
  return print((unsigned long) n, base);
 80a3d6a:	f7ff ffef 	bl	80a3d4c <_ZN5Print5printEmi>
 80a3d6e:	4604      	mov	r4, r0
}

size_t Print::println(unsigned int num, int base)
{
  size_t n = print(num, base);
  n += println();
 80a3d70:	4628      	mov	r0, r5
 80a3d72:	f7ff ffb6 	bl	80a3ce2 <_ZN5Print7printlnEv>
  return n;
}
 80a3d76:	4420      	add	r0, r4
 80a3d78:	bd38      	pop	{r3, r4, r5, pc}

080a3d7a <_ZN5Print11printf_implEbPKcz>:

  return n;
}

size_t Print::printf_impl(bool newline, const char* format, ...)
{
 80a3d7a:	b40c      	push	{r2, r3}
 80a3d7c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a3d80:	b087      	sub	sp, #28
 80a3d82:	af00      	add	r7, sp, #0
 80a3d84:	f107 0438 	add.w	r4, r7, #56	; 0x38
 80a3d88:	f854 9b04 	ldr.w	r9, [r4], #4
 80a3d8c:	4605      	mov	r5, r0
 80a3d8e:	460e      	mov	r6, r1
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a3d90:	4623      	mov	r3, r4
 80a3d92:	464a      	mov	r2, r9
 80a3d94:	2114      	movs	r1, #20
 80a3d96:	1d38      	adds	r0, r7, #4
size_t Print::printf_impl(bool newline, const char* format, ...)
{
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
 80a3d98:	603c      	str	r4, [r7, #0]
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a3d9a:	f7ff fe65 	bl	80a3a68 <vsnprintf>
    va_end(marker);

    if (n<bufsize)
 80a3d9e:	2813      	cmp	r0, #19
 80a3da0:	d805      	bhi.n	80a3dae <_ZN5Print11printf_implEbPKcz+0x34>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a3da2:	1d39      	adds	r1, r7, #4
 80a3da4:	4628      	mov	r0, r5
 80a3da6:	f7ff ff85 	bl	80a3cb4 <_ZN5Print5writeEPKc>
 80a3daa:	4604      	mov	r4, r0
 80a3dac:	e013      	b.n	80a3dd6 <_ZN5Print11printf_implEbPKcz+0x5c>
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a3dae:	f100 0308 	add.w	r3, r0, #8
 80a3db2:	f023 0307 	bic.w	r3, r3, #7
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
 80a3db6:	46e8      	mov	r8, sp
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a3db8:	ebad 0d03 	sub.w	sp, sp, r3
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
 80a3dbc:	1c41      	adds	r1, r0, #1
 80a3dbe:	4623      	mov	r3, r4
 80a3dc0:	464a      	mov	r2, r9
 80a3dc2:	4668      	mov	r0, sp
        n = print(test);
    }
    else
    {
        char bigger[n+1];
        va_start(marker, format);
 80a3dc4:	603c      	str	r4, [r7, #0]
        n = vsnprintf(bigger, n+1, format, marker);
 80a3dc6:	f7ff fe4f 	bl	80a3a68 <vsnprintf>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a3dca:	4669      	mov	r1, sp
 80a3dcc:	4628      	mov	r0, r5
 80a3dce:	f7ff ff71 	bl	80a3cb4 <_ZN5Print5writeEPKc>
 80a3dd2:	4604      	mov	r4, r0
 80a3dd4:	46c5      	mov	sp, r8
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
    }
    if (newline)
 80a3dd6:	b11e      	cbz	r6, 80a3de0 <_ZN5Print11printf_implEbPKcz+0x66>
        n += println();
 80a3dd8:	4628      	mov	r0, r5
 80a3dda:	f7ff ff82 	bl	80a3ce2 <_ZN5Print7printlnEv>
 80a3dde:	4404      	add	r4, r0
    return n;
}
 80a3de0:	4620      	mov	r0, r4
 80a3de2:	371c      	adds	r7, #28
 80a3de4:	46bd      	mov	sp, r7
 80a3de6:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a3dea:	b002      	add	sp, #8
 80a3dec:	4770      	bx	lr

080a3dee <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      explicit __shared_count(const __weak_count<_Lp>& __r);

      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
 80a3dee:	b538      	push	{r3, r4, r5, lr}
      {
	if (_M_pi != nullptr)
 80a3df0:	6804      	ldr	r4, [r0, #0]
      explicit __shared_count(const __weak_count<_Lp>& __r);

      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
 80a3df2:	4605      	mov	r5, r0
      {
	if (_M_pi != nullptr)
 80a3df4:	b17c      	cbz	r4, 80a3e16 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a3df6:	6863      	ldr	r3, [r4, #4]
 80a3df8:	3b01      	subs	r3, #1
 80a3dfa:	6063      	str	r3, [r4, #4]
 80a3dfc:	b95b      	cbnz	r3, 80a3e16 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
        {
          _M_dispose();
 80a3dfe:	6823      	ldr	r3, [r4, #0]
 80a3e00:	4620      	mov	r0, r4
 80a3e02:	689b      	ldr	r3, [r3, #8]
 80a3e04:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a3e06:	68a3      	ldr	r3, [r4, #8]
 80a3e08:	3b01      	subs	r3, #1
 80a3e0a:	60a3      	str	r3, [r4, #8]
 80a3e0c:	b91b      	cbnz	r3, 80a3e16 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
            _M_destroy();
 80a3e0e:	6823      	ldr	r3, [r4, #0]
 80a3e10:	4620      	mov	r0, r4
 80a3e12:	68db      	ldr	r3, [r3, #12]
 80a3e14:	4798      	blx	r3

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
	  _M_pi->_M_release();
      }
 80a3e16:	4628      	mov	r0, r5
 80a3e18:	bd38      	pop	{r3, r4, r5, pc}

080a3e1a <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>:

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
 80a3e1a:	680b      	ldr	r3, [r1, #0]
 80a3e1c:	6003      	str	r3, [r0, #0]
      {
	if (_M_pi != 0)
 80a3e1e:	b113      	cbz	r3, 80a3e26 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_+0xc>
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }
 80a3e20:	685a      	ldr	r2, [r3, #4]
 80a3e22:	3201      	adds	r2, #1
 80a3e24:	605a      	str	r2, [r3, #4]
      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
	if (_M_pi != 0)
	  _M_pi->_M_add_ref_copy();
      }
 80a3e26:	4770      	bx	lr

080a3e28 <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
 80a3e28:	4a01      	ldr	r2, [pc, #4]	; (80a3e30 <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a3e2a:	4b02      	ldr	r3, [pc, #8]	; (80a3e34 <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a3e2c:	601a      	str	r2, [r3, #0]
 80a3e2e:	4770      	bx	lr
 80a3e30:	080a6b82 	.word	0x080a6b82
 80a3e34:	200013d8 	.word	0x200013d8

080a3e38 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a3e38:	4b02      	ldr	r3, [pc, #8]	; (80a3e44 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a3e3a:	681a      	ldr	r2, [r3, #0]
 80a3e3c:	4b02      	ldr	r3, [pc, #8]	; (80a3e48 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a3e3e:	601a      	str	r2, [r3, #0]
 80a3e40:	4770      	bx	lr
 80a3e42:	bf00      	nop
 80a3e44:	20000484 	.word	0x20000484
 80a3e48:	200013dc 	.word	0x200013dc

080a3e4c <_Z3mapiiiii>:
    HAL_ADC_Set_Sample_Time(ADC_SampleTime);
}

int map(int value, int fromStart, int fromEnd, int toStart, int toEnd)
{
    if (fromEnd == fromStart) {
 80a3e4c:	428a      	cmp	r2, r1
{
    HAL_ADC_Set_Sample_Time(ADC_SampleTime);
}

int map(int value, int fromStart, int fromEnd, int toStart, int toEnd)
{
 80a3e4e:	b530      	push	{r4, r5, lr}
    if (fromEnd == fromStart) {
 80a3e50:	d007      	beq.n	80a3e62 <_Z3mapiiiii+0x16>
        return value;
    }
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
 80a3e52:	9d03      	ldr	r5, [sp, #12]
 80a3e54:	1a44      	subs	r4, r0, r1
 80a3e56:	1aed      	subs	r5, r5, r3
 80a3e58:	436c      	muls	r4, r5
 80a3e5a:	1a52      	subs	r2, r2, r1
 80a3e5c:	fb94 f4f2 	sdiv	r4, r4, r2
 80a3e60:	18e0      	adds	r0, r4, r3
}
 80a3e62:	bd30      	pop	{r4, r5, pc}

080a3e64 <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a3e64:	2100      	movs	r1, #0
 80a3e66:	f7ff bd93 	b.w	80a3990 <system_delay_ms>

080a3e6a <_ZNSt14_Function_baseD1Ev>:
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a3e6a:	b510      	push	{r4, lr}
    {
      if (_M_manager)
 80a3e6c:	6883      	ldr	r3, [r0, #8]
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a3e6e:	4604      	mov	r4, r0
    {
      if (_M_manager)
 80a3e70:	b113      	cbz	r3, 80a3e78 <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a3e72:	2203      	movs	r2, #3
 80a3e74:	4601      	mov	r1, r0
 80a3e76:	4798      	blx	r3
    }
 80a3e78:	4620      	mov	r0, r4
 80a3e7a:	bd10      	pop	{r4, pc}

080a3e7c <_ZN8RGBClassD1Ev>:
#include "rgbled.h"

typedef void (raw_rgb_change_handler_t)(uint8_t, uint8_t, uint8_t);
typedef std::function<raw_rgb_change_handler_t> wiring_rgb_change_handler_t;

class RGBClass {
 80a3e7c:	b510      	push	{r4, lr}
 80a3e7e:	4604      	mov	r4, r0
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a3e80:	f7ff fff3 	bl	80a3e6a <_ZNSt14_Function_baseD1Ev>
 80a3e84:	4620      	mov	r0, r4
 80a3e86:	bd10      	pop	{r4, pc}

080a3e88 <_ZSt4swapISt9_Any_dataEvRT_S2_>:
   *  @param  __b  Another thing of arbitrary type.
   *  @return   Nothing.
  */
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
 80a3e88:	b513      	push	{r0, r1, r4, lr}
 80a3e8a:	460b      	mov	r3, r1
 80a3e8c:	4604      	mov	r4, r0
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a3e8e:	c803      	ldmia	r0, {r0, r1}
 80a3e90:	e88d 0003 	stmia.w	sp, {r0, r1}
      __a = _GLIBCXX_MOVE(__b);
 80a3e94:	e893 0003 	ldmia.w	r3, {r0, r1}
 80a3e98:	e884 0003 	stmia.w	r4, {r0, r1}
      __b = _GLIBCXX_MOVE(__tmp);
 80a3e9c:	e89d 0003 	ldmia.w	sp, {r0, r1}
 80a3ea0:	e883 0003 	stmia.w	r3, {r0, r1}
    }
 80a3ea4:	b002      	add	sp, #8
 80a3ea6:	bd10      	pop	{r4, pc}

080a3ea8 <_GLOBAL__sub_I_RGB>:
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a3ea8:	4803      	ldr	r0, [pc, #12]	; (80a3eb8 <_GLOBAL__sub_I_RGB+0x10>)
 80a3eaa:	2300      	movs	r3, #0
 80a3eac:	6083      	str	r3, [r0, #8]
#include "spark_wiring_rgb.h"
#include "spark_wiring_interrupts.h"

#include "core_hal.h"

RGBClass RGB;
 80a3eae:	4a03      	ldr	r2, [pc, #12]	; (80a3ebc <_GLOBAL__sub_I_RGB+0x14>)
 80a3eb0:	4903      	ldr	r1, [pc, #12]	; (80a3ec0 <_GLOBAL__sub_I_RGB+0x18>)
 80a3eb2:	f000 bd93 	b.w	80a49dc <__aeabi_atexit>
 80a3eb6:	bf00      	nop
 80a3eb8:	200013e0 	.word	0x200013e0
 80a3ebc:	200004f0 	.word	0x200004f0
 80a3ec0:	080a3e7d 	.word	0x080a3e7d

080a3ec4 <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
 80a3ec4:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a3ec6:	4b14      	ldr	r3, [pc, #80]	; (80a3f18 <serialEventRun+0x54>)
 80a3ec8:	b133      	cbz	r3, 80a3ed8 <serialEventRun+0x14>
 80a3eca:	f000 fb9d 	bl	80a4608 <_Z16_fetch_usbserialv>
 80a3ece:	6803      	ldr	r3, [r0, #0]
 80a3ed0:	691b      	ldr	r3, [r3, #16]
 80a3ed2:	4798      	blx	r3
 80a3ed4:	2800      	cmp	r0, #0
 80a3ed6:	dc16      	bgt.n	80a3f06 <serialEventRun+0x42>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
 80a3ed8:	4b10      	ldr	r3, [pc, #64]	; (80a3f1c <serialEventRun+0x58>)
 80a3eda:	b133      	cbz	r3, 80a3eea <serialEventRun+0x26>
 80a3edc:	f000 fc2c 	bl	80a4738 <_Z22__fetch_global_Serial1v>
 80a3ee0:	6803      	ldr	r3, [r0, #0]
 80a3ee2:	691b      	ldr	r3, [r3, #16]
 80a3ee4:	4798      	blx	r3
 80a3ee6:	2800      	cmp	r0, #0
 80a3ee8:	dc10      	bgt.n	80a3f0c <serialEventRun+0x48>
        serialEvent1();

#if Wiring_Serial2
    if (serialEventRun2) serialEventRun2();
 80a3eea:	4b0d      	ldr	r3, [pc, #52]	; (80a3f20 <serialEventRun+0x5c>)
 80a3eec:	b10b      	cbz	r3, 80a3ef2 <serialEventRun+0x2e>
 80a3eee:	f3af 8000 	nop.w
#if Wiring_Serial5
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a3ef2:	4b0c      	ldr	r3, [pc, #48]	; (80a3f24 <serialEventRun+0x60>)
 80a3ef4:	b17b      	cbz	r3, 80a3f16 <serialEventRun+0x52>
 80a3ef6:	f000 fbb5 	bl	80a4664 <_Z17_fetch_usbserial1v>
 80a3efa:	6803      	ldr	r3, [r0, #0]
 80a3efc:	691b      	ldr	r3, [r3, #16]
 80a3efe:	4798      	blx	r3
 80a3f00:	2800      	cmp	r0, #0
 80a3f02:	dc06      	bgt.n	80a3f12 <serialEventRun+0x4e>
 80a3f04:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
 80a3f06:	f3af 8000 	nop.w
 80a3f0a:	e7e5      	b.n	80a3ed8 <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
 80a3f0c:	f3af 8000 	nop.w
 80a3f10:	e7eb      	b.n	80a3eea <serialEventRun+0x26>
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
        usbSerialEvent1();
 80a3f12:	f3af 8000 	nop.w
 80a3f16:	bd08      	pop	{r3, pc}
	...

080a3f28 <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
 80a3f28:	b508      	push	{r3, lr}
	serialEventRun();
 80a3f2a:	f7ff ffcb 	bl	80a3ec4 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a3f2e:	f7ff fc55 	bl	80a37dc <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a3f32:	4b01      	ldr	r3, [pc, #4]	; (80a3f38 <_post_loop+0x10>)
 80a3f34:	6018      	str	r0, [r3, #0]
 80a3f36:	bd08      	pop	{r3, pc}
 80a3f38:	2000146c 	.word	0x2000146c

080a3f3c <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a3f3c:	4802      	ldr	r0, [pc, #8]	; (80a3f48 <_Z33system_initialize_user_backup_ramv+0xc>)
 80a3f3e:	4a03      	ldr	r2, [pc, #12]	; (80a3f4c <_Z33system_initialize_user_backup_ramv+0x10>)
 80a3f40:	4903      	ldr	r1, [pc, #12]	; (80a3f50 <_Z33system_initialize_user_backup_ramv+0x14>)
 80a3f42:	1a12      	subs	r2, r2, r0
 80a3f44:	f001 be28 	b.w	80a5b98 <memcpy>
 80a3f48:	40024000 	.word	0x40024000
 80a3f4c:	40024004 	.word	0x40024004
 80a3f50:	080a6e40 	.word	0x080a6e40

080a3f54 <_Z27ctrl_request_custom_handlerP12ctrl_request>:
bool __backup_ram_was_valid() { return false; }

#endif

// Default handler for CTRL_REQUEST_APP_CUSTOM requests
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
 80a3f54:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a3f56:	2300      	movs	r3, #0
 80a3f58:	9300      	str	r3, [sp, #0]
 80a3f5a:	461a      	mov	r2, r3
 80a3f5c:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a3f60:	f7ff fd38 	bl	80a39d4 <system_ctrl_set_result>
}
 80a3f64:	b003      	add	sp, #12
 80a3f66:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a3f6c <_ZL20ctrl_request_handlerP12ctrl_request>:
// Callback invoked to process a logging configuration request
void(*log_process_ctrl_request_callback)(ctrl_request* req) = nullptr;
#endif

// Application handler for control requests
static void ctrl_request_handler(ctrl_request* req) {
 80a3f6c:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
 80a3f6e:	8843      	ldrh	r3, [r0, #2]
 80a3f70:	2b0a      	cmp	r3, #10
 80a3f72:	d008      	beq.n	80a3f86 <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
 80a3f74:	2b50      	cmp	r3, #80	; 0x50
 80a3f76:	d109      	bne.n	80a3f8c <_ZL20ctrl_request_handlerP12ctrl_request+0x20>
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
 80a3f78:	4b09      	ldr	r3, [pc, #36]	; (80a3fa0 <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
 80a3f7a:	681b      	ldr	r3, [r3, #0]
 80a3f7c:	b13b      	cbz	r3, 80a3f8e <_ZL20ctrl_request_handlerP12ctrl_request+0x22>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
        break;
    }
}
 80a3f7e:	b003      	add	sp, #12
 80a3f80:	f85d eb04 	ldr.w	lr, [sp], #4
static void ctrl_request_handler(ctrl_request* req) {
    switch (req->type) {
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
            log_process_ctrl_request_callback(req);
 80a3f84:	4718      	bx	r3
        }
        break;
    }
#endif
    case CTRL_REQUEST_APP_CUSTOM: {
        ctrl_request_custom_handler(req);
 80a3f86:	f7ff ffe5 	bl	80a3f54 <_Z27ctrl_request_custom_handlerP12ctrl_request>
        break;
 80a3f8a:	e006      	b.n	80a3f9a <_ZL20ctrl_request_handlerP12ctrl_request+0x2e>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a3f8c:	2300      	movs	r3, #0
 80a3f8e:	9300      	str	r3, [sp, #0]
 80a3f90:	461a      	mov	r2, r3
 80a3f92:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a3f96:	f7ff fd1d 	bl	80a39d4 <system_ctrl_set_result>
        break;
    }
}
 80a3f9a:	b003      	add	sp, #12
 80a3f9c:	f85d fb04 	ldr.w	pc, [sp], #4
 80a3fa0:	200013f0 	.word	0x200013f0

080a3fa4 <module_user_init_hook>:

void module_user_init_hook()
{
 80a3fa4:	b538      	push	{r3, r4, r5, lr}
#if PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
 80a3fa6:	4c10      	ldr	r4, [pc, #64]	; (80a3fe8 <module_user_init_hook+0x44>)
 80a3fa8:	4d10      	ldr	r5, [pc, #64]	; (80a3fec <module_user_init_hook+0x48>)
 80a3faa:	6823      	ldr	r3, [r4, #0]
 80a3fac:	42ab      	cmp	r3, r5
 80a3fae:	4b10      	ldr	r3, [pc, #64]	; (80a3ff0 <module_user_init_hook+0x4c>)
 80a3fb0:	bf0c      	ite	eq
 80a3fb2:	2201      	moveq	r2, #1
 80a3fb4:	2200      	movne	r2, #0
 80a3fb6:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
 80a3fb8:	d002      	beq.n	80a3fc0 <module_user_init_hook+0x1c>
        system_initialize_user_backup_ram();
 80a3fba:	f7ff ffbf 	bl	80a3f3c <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
 80a3fbe:	6025      	str	r5, [r4, #0]
#endif

    // todo - add a RNG define for that capability
#if defined(STM32F2XX)
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    srand(HAL_RNG_GetRandomNumber());
 80a3fc0:	f7ff fbf4 	bl	80a37ac <HAL_RNG_GetRandomNumber>
 80a3fc4:	f001 fdfc 	bl	80a5bc0 <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
 80a3fc8:	4b0a      	ldr	r3, [pc, #40]	; (80a3ff4 <module_user_init_hook+0x50>)
 80a3fca:	b11b      	cbz	r3, 80a3fd4 <module_user_init_hook+0x30>
        uint32_t seed = HAL_RNG_GetRandomNumber();
 80a3fcc:	f7ff fbee 	bl	80a37ac <HAL_RNG_GetRandomNumber>
        random_seed_from_cloud(seed);
 80a3fd0:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
 80a3fd4:	2100      	movs	r1, #0
 80a3fd6:	4807      	ldr	r0, [pc, #28]	; (80a3ff4 <module_user_init_hook+0x50>)
 80a3fd8:	f7ff fd1e 	bl	80a3a18 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
 80a3fdc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
 80a3fe0:	2100      	movs	r1, #0
 80a3fe2:	4805      	ldr	r0, [pc, #20]	; (80a3ff8 <module_user_init_hook+0x54>)
 80a3fe4:	f7ff bcec 	b.w	80a39c0 <system_ctrl_set_app_request_handler>
 80a3fe8:	40024000 	.word	0x40024000
 80a3fec:	9a271c1e 	.word	0x9a271c1e
 80a3ff0:	200013f4 	.word	0x200013f4
 80a3ff4:	00000000 	.word	0x00000000
 80a3ff8:	080a3f6d 	.word	0x080a3f6d

080a3ffc <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED1Ev>:
    class __shared_count;


  // Counted ptr with no deleter or allocator support
  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
 80a3ffc:	4770      	bx	lr

080a3ffe <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info>:
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept
      { return nullptr; }
 80a3ffe:	2000      	movs	r0, #0
 80a4000:	4770      	bx	lr

080a4002 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>:
    class __shared_count;


  // Counted ptr with no deleter or allocator support
  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
 80a4002:	b510      	push	{r4, lr}
 80a4004:	4604      	mov	r4, r0
 80a4006:	f7fc f84a 	bl	80a009e <_ZdlPv>
 80a400a:	4620      	mov	r0, r4
 80a400c:	bd10      	pop	{r4, pc}

080a400e <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv>:
      virtual void
      _M_dispose() noexcept
      { delete _M_ptr; }

      virtual void
      _M_destroy() noexcept
 80a400e:	b508      	push	{r3, lr}
      { delete this; }
 80a4010:	b108      	cbz	r0, 80a4016 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv+0x8>
 80a4012:	f7ff fff6 	bl	80a4002 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>
 80a4016:	bd08      	pop	{r3, pc}

080a4018 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv>:
      explicit
      _Sp_counted_ptr(_Ptr __p) noexcept
      : _M_ptr(__p) { }

      virtual void
      _M_dispose() noexcept
 80a4018:	b538      	push	{r3, r4, r5, lr}
      { delete _M_ptr; }
 80a401a:	68c4      	ldr	r4, [r0, #12]
 80a401c:	b1d4      	cbz	r4, 80a4054 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x3c>

      _Tp
      load(memory_order __m = memory_order_seq_cst) const noexcept
      { 
        _Tp tmp;
	__atomic_load(&_M_i, &tmp, __m);
 80a401e:	7823      	ldrb	r3, [r4, #0]
    ~FutureImpl() {
        // Call destructor of the appropriate unnamed enum's field
        const State s = this->state();
        if (s == State::SUCCEEDED) {
            result_.~ResultT();
        } else if (s == State::FAILED) {
 80a4020:	2b02      	cmp	r3, #2
 80a4022:	d102      	bne.n	80a402a <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x12>
        Error() {
    swap(*this, error);
}

inline particle::Error::~Error() {
    free((void*)msg_);
 80a4024:	68e0      	ldr	r0, [r4, #12]
 80a4026:	f7ff fd07 	bl	80a3a38 <free>
      {
        memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_p, __m);
 80a402a:	6865      	ldr	r5, [r4, #4]
    // Completion callback types
    typedef typename detail::FutureCallbackTypes<ResultT>::OnSuccess OnSuccessCallback;
    typedef typename detail::FutureCallbackTypes<ResultT>::OnError OnErrorCallback;

    ~FutureImplBase() {
        delete onSuccess_.load(std::memory_order_relaxed);
 80a402c:	b12d      	cbz	r5, 80a403a <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x22>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a402e:	4628      	mov	r0, r5
 80a4030:	f7ff ff1b 	bl	80a3e6a <_ZNSt14_Function_baseD1Ev>
 80a4034:	4628      	mov	r0, r5
 80a4036:	f7fc f832 	bl	80a009e <_ZdlPv>
 80a403a:	68a5      	ldr	r5, [r4, #8]
        delete onError_.load(std::memory_order_relaxed);
 80a403c:	b12d      	cbz	r5, 80a404a <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x32>
 80a403e:	4628      	mov	r0, r5
 80a4040:	f7ff ff13 	bl	80a3e6a <_ZNSt14_Function_baseD1Ev>
 80a4044:	4628      	mov	r0, r5
 80a4046:	f7fc f82a 	bl	80a009e <_ZdlPv>
 80a404a:	4620      	mov	r0, r4
 80a404c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80a4050:	f7fc b825 	b.w	80a009e <_ZdlPv>
 80a4054:	bd38      	pop	{r3, r4, r5, pc}

080a4056 <_ZN8particle6FutureIbNS_6detail13FutureContextEEC1ESt10shared_ptrINS1_10FutureImplIbS2_EEE>:
};

template<typename ResultT, typename ContextT = detail::FutureContext>
class Future: public FutureBase<ResultT, ContextT> {
public:
    using FutureBase<ResultT, ContextT>::FutureBase;
 80a4056:	b513      	push	{r0, r1, r4, lr}
 80a4058:	4604      	mov	r4, r0
      }

      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 80a405a:	e891 0005 	ldmia.w	r1, {r0, r2}
	__r._M_pi = _M_pi;
 80a405e:	2300      	movs	r3, #0
 80a4060:	604b      	str	r3, [r1, #4]

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
	_M_refcount._M_swap(__r._M_refcount);
	__r._M_ptr = 0;
 80a4062:	600b      	str	r3, [r1, #0]
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
	{ }

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
 80a4064:	6020      	str	r0, [r4, #0]
      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
	_M_pi = __tmp;
 80a4066:	6062      	str	r2, [r4, #4]
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a4068:	a801      	add	r0, sp, #4

      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
 80a406a:	9301      	str	r3, [sp, #4]

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
	_M_refcount._M_swap(__r._M_refcount);
	__r._M_ptr = 0;
 80a406c:	9300      	str	r3, [sp, #0]
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a406e:	f7ff febe 	bl	80a3dee <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a4072:	4620      	mov	r0, r4
 80a4074:	b002      	add	sp, #8
 80a4076:	bd10      	pop	{r4, pc}

080a4078 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>:
        // TODO: Use custom reference counting object to avoid unnecessary memory allocation
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
    }

    // Unwraps promise from an object pointer created via dataPtr() method
    static Promise<ResultT, ContextT> fromDataPtr(void* data) {
 80a4078:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a407a:	460c      	mov	r4, r1
 80a407c:	4606      	mov	r6, r0
 80a407e:	460f      	mov	r7, r1
 80a4080:	f854 3b04 	ldr.w	r3, [r4], #4
 80a4084:	ad02      	add	r5, sp, #8
 80a4086:	f845 3d08 	str.w	r3, [r5, #-8]!
 80a408a:	4621      	mov	r1, r4
 80a408c:	a801      	add	r0, sp, #4
 80a408e:	f7ff fec4 	bl	80a3e1a <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
        auto d = static_cast<detail::FutureImplPtr<ResultT, ContextT>*>(data);
        const Promise<ResultT, ContextT> p(*d);
 80a4092:	4629      	mov	r1, r5
 80a4094:	4630      	mov	r0, r6
 80a4096:	f7ff ffde 	bl	80a4056 <_ZN8particle6FutureIbNS_6detail13FutureContextEEC1ESt10shared_ptrINS1_10FutureImplIbS2_EEE>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a409a:	a801      	add	r0, sp, #4
 80a409c:	f7ff fea7 	bl	80a3dee <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a40a0:	4620      	mov	r0, r4
 80a40a2:	f7ff fea4 	bl	80a3dee <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        delete d;
 80a40a6:	4638      	mov	r0, r7
 80a40a8:	f7fb fff9 	bl	80a009e <_ZdlPv>
        return p;
    }
 80a40ac:	4630      	mov	r0, r6
 80a40ae:	b003      	add	sp, #12
 80a40b0:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a40b2 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>:
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a40b2:	6882      	ldr	r2, [r0, #8]
	  }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
 80a40b4:	b510      	push	{r4, lr}
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a40b6:	b90a      	cbnz	r2, 80a40bc <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_+0xa>
	__throw_bad_function_call();
 80a40b8:	f000 fc95 	bl	80a49e6 <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a40bc:	68c3      	ldr	r3, [r0, #12]
    }
 80a40be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
	__throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a40c2:	4718      	bx	r3

080a40c4 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE9_M_invokeERKSt9_Any_data>:
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
 80a40c4:	b508      	push	{r3, lr}
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
 80a40c6:	6800      	ldr	r0, [r0, #0]
      template<typename _Result, typename... _Args, std::size_t... _Indexes>
	_Result
	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
	{
	  return _M_f(_Mu<_Bound_args>()
		      (std::get<_Indexes>(_M_bound_args), __args)...);
 80a40c8:	f100 0110 	add.w	r1, r0, #16
 80a40cc:	f7ff fff1 	bl	80a40b2 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
 80a40d0:	bd08      	pop	{r3, pc}

080a40d2 <_ZNKSt8functionIFvRKbEEclES1_>:
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a40d2:	6882      	ldr	r2, [r0, #8]
	  }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
 80a40d4:	b510      	push	{r4, lr}
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a40d6:	b90a      	cbnz	r2, 80a40dc <_ZNKSt8functionIFvRKbEEclES1_+0xa>
	__throw_bad_function_call();
 80a40d8:	f000 fc85 	bl	80a49e6 <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a40dc:	68c3      	ldr	r3, [r0, #12]
    }
 80a40de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
	__throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a40e2:	4718      	bx	r3

080a40e4 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE9_M_invokeERKSt9_Any_data>:
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
 80a40e4:	b508      	push	{r3, lr}
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
 80a40e6:	6800      	ldr	r0, [r0, #0]
      template<typename _Result, typename... _Args, std::size_t... _Indexes>
	_Result
	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
	{
	  return _M_f(_Mu<_Bound_args>()
		      (std::get<_Indexes>(_M_bound_args), __args)...);
 80a40e8:	f100 0110 	add.w	r1, r0, #16
 80a40ec:	f7ff fff1 	bl	80a40d2 <_ZNKSt8functionIFvRKbEEclES1_>
 80a40f0:	bd08      	pop	{r3, pc}

080a40f2 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>:
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
 80a40f2:	b538      	push	{r3, r4, r5, lr}
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a40f4:	2300      	movs	r3, #0
 80a40f6:	6083      	str	r3, [r0, #8]
 80a40f8:	688b      	ldr	r3, [r1, #8]
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
 80a40fa:	4604      	mov	r4, r0
 80a40fc:	460d      	mov	r5, r1
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 80a40fe:	b12b      	cbz	r3, 80a410c <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_+0x1a>
	{
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 80a4100:	2202      	movs	r2, #2
 80a4102:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 80a4104:	68eb      	ldr	r3, [r5, #12]
 80a4106:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
 80a4108:	68ab      	ldr	r3, [r5, #8]
 80a410a:	60a3      	str	r3, [r4, #8]
	}
    }
 80a410c:	4620      	mov	r0, r4
 80a410e:	bd38      	pop	{r3, r4, r5, pc}

080a4110 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>:

    explicit PromiseBase(detail::FutureImplPtr<ResultT, ContextT> ptr) :
            p_(std::move(ptr)) {
    }

    void setError(Error error) {
 80a4110:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
 80a4114:	f64f 739c 	movw	r3, #65436	; 0xff9c
 80a4118:	6804      	ldr	r4, [r0, #0]

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s, 
			      memory_order __f) noexcept
      {
	return __atomic_compare_exchange(&_M_i, &__e, &__i, false, __s, __f);
 80a411a:	f04f 0002 	mov.w	r0, #2
 80a411e:	b086      	sub	sp, #24
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a4120:	f9b1 2004 	ldrsh.w	r2, [r1, #4]
      __b = _GLIBCXX_MOVE(__tmp);
 80a4124:	808b      	strh	r3, [r1, #4]
 80a4126:	2300      	movs	r3, #0
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a4128:	680f      	ldr	r7, [r1, #0]
            onSuccess_(nullptr),
            onError_(nullptr) {
    }

    bool changeState(State state) {
        State s = State::RUNNING; // Expected state
 80a412a:	f88d 3000 	strb.w	r3, [sp]
      __b = _GLIBCXX_MOVE(__tmp);
 80a412e:	600b      	str	r3, [r1, #0]
 80a4130:	e8d4 1f4f 	ldrexb	r1, [r4]
 80a4134:	4299      	cmp	r1, r3
 80a4136:	d103      	bne.n	80a4140 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x30>
 80a4138:	e8c4 0f45 	strexb	r5, r0, [r4]
 80a413c:	2d00      	cmp	r5, #0
 80a413e:	d1f7      	bne.n	80a4130 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x20>
 80a4140:	d002      	beq.n	80a4148 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x38>
 80a4142:	f88d 1000 	strb.w	r1, [sp]
 80a4146:	e06b      	b.n	80a4220 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x110>
        return std::move(defaultValue);
    }

    void setError(Error error) {
        if (this->changeState(State::FAILED)) {
            new(&error_) Error(std::move(error));
 80a4148:	f114 050c 	adds.w	r5, r4, #12
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a414c:	bf1c      	itt	ne
 80a414e:	60e7      	strne	r7, [r4, #12]
 80a4150:	8222      	strhne	r2, [r4, #16]
        memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_acquire);
	__glibcxx_assert(__b != memory_order_acq_rel);
	__glibcxx_assert(__b != memory_order_consume);

	__atomic_store_n(&_M_i, __i, __m);
 80a4152:	f3bf 8f5f 	dmb	sy
      __b = _GLIBCXX_MOVE(__tmp);
 80a4156:	bf18      	it	ne
 80a4158:	461f      	movne	r7, r3
 80a415a:	2301      	movs	r3, #1
 80a415c:	7063      	strb	r3, [r4, #1]

      _GLIBCXX_ALWAYS_INLINE __pointer_type
      exchange(__pointer_type __p,
	       memory_order __m = memory_order_seq_cst) noexcept
      {
	return __atomic_exchange_n(&_M_p, __p, __m);
 80a415e:	f3bf 8f5f 	dmb	sy
 80a4162:	f104 0308 	add.w	r3, r4, #8
 80a4166:	2000      	movs	r0, #0
 80a4168:	e853 6f00 	ldrex	r6, [r3]
 80a416c:	e843 0200 	strex	r2, r0, [r3]
 80a4170:	2a00      	cmp	r2, #0
 80a4172:	d1f9      	bne.n	80a4168 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x58>
 80a4174:	f3bf 8f5f 	dmb	sy

    // Takes a callback from its atomic wrapper and invokes it
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(std::atomic<std::function<FunctionT>*>& wrapper, ArgsT&&... args) {
        std::function<FunctionT>* callbackPtr = wrapper.exchange(nullptr, std::memory_order_acq_rel);
        if (callbackPtr) {
 80a4178:	2e00      	cmp	r6, #0
 80a417a:	d051      	beq.n	80a4220 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x110>
        return (application_thread_invoke(callback, data, nullptr) == 0);
    }

    // Returns true if current thread is the application thread
    static bool isApplicationThreadCurrent() {
        return (application_thread_current(nullptr) != 0);
 80a417c:	f7ff fc10 	bl	80a39a0 <application_thread_current>
    }

    // Invokes std::function in the application context
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(const std::function<FunctionT>& callback, ArgsT&&... args) {
        if (ContextT::isApplicationThreadCurrent()) {
 80a4180:	b120      	cbz	r0, 80a418c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x7c>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
 80a4182:	4629      	mov	r1, r5
 80a4184:	4630      	mov	r0, r6
 80a4186:	f7ff ff94 	bl	80a40b2 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
 80a418a:	e043      	b.n	80a4214 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x104>
	}

     public:
      template<typename... _Args>
	explicit _Bind(const _Functor& __f, _Args&&... __args)
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 80a418c:	4631      	mov	r1, r6
 80a418e:	4668      	mov	r0, sp
 80a4190:	f7ff ffaf 	bl	80a40f2 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
inline particle::Error::Error(const char* msg) :
        Error(UNKNOWN, msg) {
}

inline particle::Error::Error(const Error& error) :
        Error(error.type_, error.msg_) {
 80a4194:	68e0      	ldr	r0, [r4, #12]
 80a4196:	f9b4 5010 	ldrsh.w	r5, [r4, #16]
        type_(type) {
}

inline particle::Error::Error(Type type, const char* msg) :
        msg_(msg ? (const char*)strdup(msg) : nullptr),
        type_(type) {
 80a419a:	b108      	cbz	r0, 80a41a0 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x90>
 80a419c:	f001 fd94 	bl	80a5cc8 <strdup>
 80a41a0:	9004      	str	r0, [sp, #16]
        } else {
            // Bind all arguments and wrap resulting function into a pointer
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
 80a41a2:	2010      	movs	r0, #16
 80a41a4:	f8ad 5014 	strh.w	r5, [sp, #20]
 80a41a8:	f7fb ff77 	bl	80a009a <_Znwj>
 80a41ac:	4605      	mov	r5, r0
 80a41ae:	b330      	cbz	r0, 80a41fe <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xee>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a41b0:	f04f 0800 	mov.w	r8, #0
 80a41b4:	f8c0 8008 	str.w	r8, [r0, #8]
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a41b8:	2018      	movs	r0, #24
 80a41ba:	f7fb ff6e 	bl	80a009a <_Znwj>
 80a41be:	4604      	mov	r4, r0
 80a41c0:	b1c0      	cbz	r0, 80a41f4 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xe4>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a41c2:	f8c0 8008 	str.w	r8, [r0, #8]
       *  Swap the targets of @c this function object and @a __f. This
       *  function will not throw an %exception.
       */
      void swap(function& __x)
      {
	std::swap(_M_functor, __x._M_functor);
 80a41c6:	4601      	mov	r1, r0
 80a41c8:	4668      	mov	r0, sp
 80a41ca:	f7ff fe5d 	bl	80a3e88 <_ZSt4swapISt9_Any_dataEvRT_S2_>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a41ce:	9b02      	ldr	r3, [sp, #8]
      __a = _GLIBCXX_MOVE(__b);
 80a41d0:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a41d2:	60a3      	str	r3, [r4, #8]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a41d4:	9b03      	ldr	r3, [sp, #12]
      __a = _GLIBCXX_MOVE(__b);
 80a41d6:	9202      	str	r2, [sp, #8]
 80a41d8:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a41da:	60e3      	str	r3, [r4, #12]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a41dc:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 80a41e0:	9203      	str	r2, [sp, #12]
 80a41e2:	82a3      	strh	r3, [r4, #20]
      __b = _GLIBCXX_MOVE(__tmp);
 80a41e4:	f64f 739c 	movw	r3, #65436	; 0xff9c
 80a41e8:	f8ad 3014 	strh.w	r3, [sp, #20]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a41ec:	9b04      	ldr	r3, [sp, #16]
      __b = _GLIBCXX_MOVE(__tmp);
 80a41ee:	f8cd 8010 	str.w	r8, [sp, #16]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a41f2:	6123      	str	r3, [r4, #16]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a41f4:	4b0d      	ldr	r3, [pc, #52]	; (80a422c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x11c>)
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a41f6:	602c      	str	r4, [r5, #0]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a41f8:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a41fa:	4b0d      	ldr	r3, [pc, #52]	; (80a4230 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x120>)
 80a41fc:	60ab      	str	r3, [r5, #8]
        Error() {
    swap(*this, error);
}

inline particle::Error::~Error() {
    free((void*)msg_);
 80a41fe:	9804      	ldr	r0, [sp, #16]
 80a4200:	f7ff fc1a 	bl	80a3a38 <free>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a4204:	4668      	mov	r0, sp
 80a4206:	f7ff fe30 	bl	80a3e6a <_ZNSt14_Function_baseD1Ev>
        spark_process();
    }

    // Asynchronously invokes a callback in the application context
    static bool invokeApplicationCallback(void (*callback)(void* data), void* data) {
        return (application_thread_invoke(callback, data, nullptr) == 0);
 80a420a:	2200      	movs	r2, #0
 80a420c:	4629      	mov	r1, r5
 80a420e:	4809      	ldr	r0, [pc, #36]	; (80a4234 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x124>)
 80a4210:	f7ff fbce 	bl	80a39b0 <application_thread_invoke>
 80a4214:	4630      	mov	r0, r6
 80a4216:	f7ff fe28 	bl	80a3e6a <_ZNSt14_Function_baseD1Ev>
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(std::atomic<std::function<FunctionT>*>& wrapper, ArgsT&&... args) {
        std::function<FunctionT>* callbackPtr = wrapper.exchange(nullptr, std::memory_order_acq_rel);
        if (callbackPtr) {
            invokeCallback(*callbackPtr, std::forward<ArgsT>(args)...);
            delete callbackPtr;
 80a421a:	4630      	mov	r0, r6
 80a421c:	f7fb ff3f 	bl	80a009e <_ZdlPv>
 80a4220:	4638      	mov	r0, r7
 80a4222:	f7ff fc09 	bl	80a3a38 <free>
            p_(std::move(ptr)) {
    }

    void setError(Error error) {
        p_->setError(std::move(error));
    }
 80a4226:	b006      	add	sp, #24
 80a4228:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a422c:	080a40c5 	.word	0x080a40c5
 80a4230:	080a4321 	.word	0x080a4321
 80a4234:	080a47b9 	.word	0x080a47b9

080a4238 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>:
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
}

Future<bool> CloudClass::publish_event(const char *eventName, const char *eventData, int ttl, PublishFlags flags) {
 80a4238:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a423c:	b08b      	sub	sp, #44	; 0x2c
#ifndef SPARK_NO_CLOUD
    spark_send_event_data d = { sizeof(spark_send_event_data) };
 80a423e:	ad07      	add	r5, sp, #28
 80a4240:	f04f 0b00 	mov.w	fp, #0
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
}

Future<bool> CloudClass::publish_event(const char *eventName, const char *eventData, int ttl, PublishFlags flags) {
 80a4244:	4606      	mov	r6, r0
 80a4246:	4699      	mov	r9, r3
// can be acquired via Future
template<typename ResultT, typename ContextT>
class PromiseBase {
public:
    PromiseBase() :
            p_(new detail::FutureImpl<ResultT, ContextT>(State::RUNNING)) {
 80a4248:	2014      	movs	r0, #20
#ifndef SPARK_NO_CLOUD
    spark_send_event_data d = { sizeof(spark_send_event_data) };
 80a424a:	230c      	movs	r3, #12
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
}

Future<bool> CloudClass::publish_event(const char *eventName, const char *eventData, int ttl, PublishFlags flags) {
 80a424c:	460f      	mov	r7, r1
 80a424e:	4690      	mov	r8, r2
 80a4250:	f89d a050 	ldrb.w	sl, [sp, #80]	; 0x50
#ifndef SPARK_NO_CLOUD
    spark_send_event_data d = { sizeof(spark_send_event_data) };
 80a4254:	f8c5 b004 	str.w	fp, [r5, #4]
 80a4258:	f8c5 b008 	str.w	fp, [r5, #8]
 80a425c:	9307      	str	r3, [sp, #28]
 80a425e:	f7fb ff1c 	bl	80a009a <_Znwj>
 80a4262:	4604      	mov	r4, r0
 80a4264:	b138      	cbz	r0, 80a4276 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x3e>
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(_Tp __i) noexcept : _M_i(__i) { }
 80a4266:	f880 b000 	strb.w	fp, [r0]
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;

      // Requires __int_type convertible to _M_i.
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
 80a426a:	f880 b001 	strb.w	fp, [r0, #1]
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;

      // Requires __pointer_type convertible to _M_p.
      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
 80a426e:	f8c0 b004 	str.w	fp, [r0, #4]
 80a4272:	f8c0 b008 	str.w	fp, [r0, #8]
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
	__shared_count(_Ptr __p) : _M_pi(0)
 80a4276:	2300      	movs	r3, #0
	{
	  __try
	    {
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a4278:	2010      	movs	r0, #16
      : _M_ptr(0), _M_refcount()
      { }

      template<typename _Tp1>
	explicit __shared_ptr(_Tp1* __p)
        : _M_ptr(__p), _M_refcount(__p)
 80a427a:	9403      	str	r4, [sp, #12]
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
	__shared_count(_Ptr __p) : _M_pi(0)
 80a427c:	9304      	str	r3, [sp, #16]
	{
	  __try
	    {
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a427e:	f7fb ff0c 	bl	80a009a <_Znwj>
 80a4282:	b128      	cbz	r0, 80a4290 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x58>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:  
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }
 80a4284:	2301      	movs	r3, #1
 80a4286:	6043      	str	r3, [r0, #4]
 80a4288:	6083      	str	r3, [r0, #8]
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
    {
    public:
      explicit
      _Sp_counted_ptr(_Ptr __p) noexcept
      : _M_ptr(__p) { }
 80a428a:	4b23      	ldr	r3, [pc, #140]	; (80a4318 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xe0>)
 80a428c:	60c4      	str	r4, [r0, #12]
 80a428e:	6003      	str	r3, [r0, #0]

    // Completion handler
    Promise<bool> p;
    d.handler_callback = publishCompletionCallback;
 80a4290:	4b22      	ldr	r3, [pc, #136]	; (80a431c <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xe4>)
        explicit
	__shared_count(_Ptr __p) : _M_pi(0)
	{
	  __try
	    {
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a4292:	9004      	str	r0, [sp, #16]
    }

    // Wraps this promise into an object pointer that can be passed to a C function
    void* dataPtr() const {
        // TODO: Use custom reference counting object to avoid unnecessary memory allocation
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
 80a4294:	2008      	movs	r0, #8
 80a4296:	9308      	str	r3, [sp, #32]
 80a4298:	f7fb feff 	bl	80a009a <_Znwj>
 80a429c:	4604      	mov	r4, r0
 80a429e:	b128      	cbz	r0, 80a42ac <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x74>
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a42a0:	9b03      	ldr	r3, [sp, #12]
 80a42a2:	a904      	add	r1, sp, #16
 80a42a4:	f840 3b04 	str.w	r3, [r0], #4
 80a42a8:	f7ff fdb7 	bl	80a3e1a <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
    d.handler_data = p.dataPtr();

    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
 80a42ac:	9500      	str	r5, [sp, #0]
 80a42ae:	fa5f f38a 	uxtb.w	r3, sl
 80a42b2:	464a      	mov	r2, r9
 80a42b4:	4641      	mov	r1, r8
 80a42b6:	4638      	mov	r0, r7
    spark_send_event_data d = { sizeof(spark_send_event_data) };

    // Completion handler
    Promise<bool> p;
    d.handler_callback = publishCompletionCallback;
    d.handler_data = p.dataPtr();
 80a42b8:	9409      	str	r4, [sp, #36]	; 0x24

    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
 80a42ba:	f7ff fb9d 	bl	80a39f8 <spark_send_event>
 80a42be:	b9b8      	cbnz	r0, 80a42f0 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xb8>
      {
       memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_i, __m);
 80a42c0:	9b03      	ldr	r3, [sp, #12]
 80a42c2:	785b      	ldrb	r3, [r3, #1]
 80a42c4:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80a42c8:	b993      	cbnz	r3, 80a42f0 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xb8>

} // namespace particle

inline particle::Error::Error(Type type) :
        msg_(nullptr),
        type_(type) {
 80a42ca:	f64f 739c 	movw	r3, #65436	; 0xff9c
        // Set generic error code in case completion callback wasn't invoked for some reason
        p.setError(Error::UNKNOWN);
 80a42ce:	a905      	add	r1, sp, #20
 80a42d0:	a803      	add	r0, sp, #12
 80a42d2:	9205      	str	r2, [sp, #20]
 80a42d4:	f8ad 3018 	strh.w	r3, [sp, #24]
 80a42d8:	f7ff ff1a 	bl	80a4110 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
        Error() {
    swap(*this, error);
}

inline particle::Error::~Error() {
    free((void*)msg_);
 80a42dc:	9805      	ldr	r0, [sp, #20]
 80a42de:	f7ff fbab 	bl	80a3a38 <free>
        p.fromDataPtr(d.handler_data); // Free wrapper object
 80a42e2:	a805      	add	r0, sp, #20
 80a42e4:	9909      	ldr	r1, [sp, #36]	; 0x24
 80a42e6:	f7ff fec7 	bl	80a4078 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a42ea:	a806      	add	r0, sp, #24
 80a42ec:	f7ff fd7f 	bl	80a3dee <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a42f0:	9b03      	ldr	r3, [sp, #12]
 80a42f2:	a904      	add	r1, sp, #16
 80a42f4:	a806      	add	r0, sp, #24
 80a42f6:	9305      	str	r3, [sp, #20]
 80a42f8:	f7ff fd8f 	bl	80a3e1a <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
    bool isDone() const {
        return p_->isDone();
    }

    Future<ResultT, ContextT> future() const {
        return Future<ResultT, ContextT>(p_);
 80a42fc:	a905      	add	r1, sp, #20
 80a42fe:	4630      	mov	r0, r6
 80a4300:	f7ff fea9 	bl	80a4056 <_ZN8particle6FutureIbNS_6detail13FutureContextEEC1ESt10shared_ptrINS1_10FutureImplIbS2_EEE>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a4304:	a806      	add	r0, sp, #24
 80a4306:	f7ff fd72 	bl	80a3dee <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a430a:	a804      	add	r0, sp, #16
 80a430c:	f7ff fd6f 	bl	80a3dee <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>

    return p.future();
#else
    return Future<bool>(Error::NOT_SUPPORTED);
#endif
}
 80a4310:	4630      	mov	r0, r6
 80a4312:	b00b      	add	sp, #44	; 0x2c
 80a4314:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a4318:	080a6bdc 	.word	0x080a6bdc
 80a431c:	080a4489 	.word	0x080a4489

080a4320 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
 80a4320:	2a02      	cmp	r2, #2
	  delete __victim._M_access<_Functor*>();
	}

      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
 80a4322:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a4324:	4604      	mov	r4, r0
		   _Manager_operation __op)
	{
	  switch (__op)
 80a4326:	d006      	beq.n	80a4336 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x16>
 80a4328:	2a03      	cmp	r2, #3
 80a432a:	d017      	beq.n	80a435c <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x3c>
 80a432c:	2a01      	cmp	r2, #1
 80a432e:	d120      	bne.n	80a4372 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x52>
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
 80a4330:	680b      	ldr	r3, [r1, #0]
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
	      break;
#endif
	    case __get_functor_ptr:
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a4332:	6003      	str	r3, [r0, #0]
	      break;
 80a4334:	e01d      	b.n	80a4372 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x52>
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
 80a4336:	2018      	movs	r0, #24
 80a4338:	680e      	ldr	r6, [r1, #0]
 80a433a:	f7fb feae 	bl	80a009a <_Znwj>
 80a433e:	4605      	mov	r5, r0
 80a4340:	b150      	cbz	r0, 80a4358 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x38>
      template<typename... _Args>
	explicit _Bind(_Functor&& __f, _Args&&... __args)
	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
	{ }

      _Bind(const _Bind&) = default;
 80a4342:	4631      	mov	r1, r6
 80a4344:	f7ff fed5 	bl	80a40f2 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
inline particle::Error::Error(const char* msg) :
        Error(UNKNOWN, msg) {
}

inline particle::Error::Error(const Error& error) :
        Error(error.type_, error.msg_) {
 80a4348:	6930      	ldr	r0, [r6, #16]
 80a434a:	f9b6 7014 	ldrsh.w	r7, [r6, #20]
        type_(type) {
}

inline particle::Error::Error(Type type, const char* msg) :
        msg_(msg ? (const char*)strdup(msg) : nullptr),
        type_(type) {
 80a434e:	b108      	cbz	r0, 80a4354 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x34>
 80a4350:	f001 fcba 	bl	80a5cc8 <strdup>
 80a4354:	6128      	str	r0, [r5, #16]
 80a4356:	82af      	strh	r7, [r5, #20]
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
 80a4358:	6025      	str	r5, [r4, #0]
 80a435a:	e00a      	b.n	80a4372 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x52>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
 80a435c:	6804      	ldr	r4, [r0, #0]
 80a435e:	b144      	cbz	r4, 80a4372 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x52>
        Error() {
    swap(*this, error);
}

inline particle::Error::~Error() {
    free((void*)msg_);
 80a4360:	6920      	ldr	r0, [r4, #16]
 80a4362:	f7ff fb69 	bl	80a3a38 <free>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a4366:	4620      	mov	r0, r4
 80a4368:	f7ff fd7f 	bl	80a3e6a <_ZNSt14_Function_baseD1Ev>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
 80a436c:	4620      	mov	r0, r4
 80a436e:	f7fb fe96 	bl	80a009e <_ZdlPv>
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
 80a4372:	2000      	movs	r0, #0
 80a4374:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a4376 <_ZNSt8functionIFvRKbEEC1ERKS3_>:
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
 80a4376:	b538      	push	{r3, r4, r5, lr}
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a4378:	2300      	movs	r3, #0
 80a437a:	6083      	str	r3, [r0, #8]
 80a437c:	688b      	ldr	r3, [r1, #8]
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
 80a437e:	4604      	mov	r4, r0
 80a4380:	460d      	mov	r5, r1
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 80a4382:	b12b      	cbz	r3, 80a4390 <_ZNSt8functionIFvRKbEEC1ERKS3_+0x1a>
	{
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 80a4384:	2202      	movs	r2, #2
 80a4386:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 80a4388:	68eb      	ldr	r3, [r5, #12]
 80a438a:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
 80a438c:	68ab      	ldr	r3, [r5, #8]
 80a438e:	60a3      	str	r3, [r4, #8]
	}
    }
 80a4390:	4620      	mov	r0, r4
 80a4392:	bd38      	pop	{r3, r4, r5, pc}

080a4394 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
 80a4394:	2a02      	cmp	r2, #2
	  delete __victim._M_access<_Functor*>();
	}

      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
 80a4396:	b570      	push	{r4, r5, r6, lr}
 80a4398:	4604      	mov	r4, r0
		   _Manager_operation __op)
	{
	  switch (__op)
 80a439a:	d006      	beq.n	80a43aa <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x16>
 80a439c:	2a03      	cmp	r2, #3
 80a439e:	d011      	beq.n	80a43c4 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x30>
 80a43a0:	2a01      	cmp	r2, #1
 80a43a2:	d117      	bne.n	80a43d4 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x40>
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
 80a43a4:	680b      	ldr	r3, [r1, #0]
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
	      break;
#endif
	    case __get_functor_ptr:
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a43a6:	6003      	str	r3, [r0, #0]
	      break;
 80a43a8:	e014      	b.n	80a43d4 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x40>
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
 80a43aa:	2014      	movs	r0, #20
 80a43ac:	680e      	ldr	r6, [r1, #0]
 80a43ae:	f7fb fe74 	bl	80a009a <_Znwj>
 80a43b2:	4605      	mov	r5, r0
 80a43b4:	b120      	cbz	r0, 80a43c0 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x2c>
      template<typename... _Args>
	explicit _Bind(_Functor&& __f, _Args&&... __args)
	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
	{ }

      _Bind(const _Bind&) = default;
 80a43b6:	4631      	mov	r1, r6
 80a43b8:	f7ff ffdd 	bl	80a4376 <_ZNSt8functionIFvRKbEEC1ERKS3_>
 80a43bc:	7c33      	ldrb	r3, [r6, #16]
 80a43be:	742b      	strb	r3, [r5, #16]
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
 80a43c0:	6025      	str	r5, [r4, #0]
 80a43c2:	e007      	b.n	80a43d4 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x40>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
 80a43c4:	6804      	ldr	r4, [r0, #0]
 80a43c6:	b12c      	cbz	r4, 80a43d4 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x40>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a43c8:	4620      	mov	r0, r4
 80a43ca:	f7ff fd4e 	bl	80a3e6a <_ZNSt14_Function_baseD1Ev>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
 80a43ce:	4620      	mov	r0, r4
 80a43d0:	f7fb fe65 	bl	80a009e <_ZdlPv>
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
 80a43d4:	2000      	movs	r0, #0
 80a43d6:	bd70      	pop	{r4, r5, r6, pc}

080a43d8 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_>:
        delete callbackPtr; // Delete old callback
    }

    // Takes a callback from its atomic wrapper and invokes it
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(std::atomic<std::function<FunctionT>*>& wrapper, ArgsT&&... args) {
 80a43d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a43da:	460c      	mov	r4, r1

      _GLIBCXX_ALWAYS_INLINE __pointer_type
      exchange(__pointer_type __p,
	       memory_order __m = memory_order_seq_cst) noexcept
      {
	return __atomic_exchange_n(&_M_p, __p, __m);
 80a43dc:	f3bf 8f5f 	dmb	sy
 80a43e0:	b087      	sub	sp, #28
 80a43e2:	2300      	movs	r3, #0
 80a43e4:	e850 6f00 	ldrex	r6, [r0]
 80a43e8:	e840 3200 	strex	r2, r3, [r0]
 80a43ec:	2a00      	cmp	r2, #0
 80a43ee:	d1f9      	bne.n	80a43e4 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xc>
 80a43f0:	f3bf 8f5f 	dmb	sy
        std::function<FunctionT>* callbackPtr = wrapper.exchange(nullptr, std::memory_order_acq_rel);
        if (callbackPtr) {
 80a43f4:	2e00      	cmp	r6, #0
 80a43f6:	d03e      	beq.n	80a4476 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x9e>
        return (application_thread_invoke(callback, data, nullptr) == 0);
    }

    // Returns true if current thread is the application thread
    static bool isApplicationThreadCurrent() {
        return (application_thread_current(nullptr) != 0);
 80a43f8:	4618      	mov	r0, r3
 80a43fa:	f7ff fad1 	bl	80a39a0 <application_thread_current>
    }

    // Invokes std::function in the application context
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(const std::function<FunctionT>& callback, ArgsT&&... args) {
        if (ContextT::isApplicationThreadCurrent()) {
 80a43fe:	4607      	mov	r7, r0
 80a4400:	b120      	cbz	r0, 80a440c <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x34>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
 80a4402:	4621      	mov	r1, r4
 80a4404:	4630      	mov	r0, r6
 80a4406:	f7ff fe64 	bl	80a40d2 <_ZNKSt8functionIFvRKbEEclES1_>
 80a440a:	e02e      	b.n	80a446a <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x92>
	}

     public:
      template<typename... _Args>
	explicit _Bind(const _Functor& __f, _Args&&... __args)
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 80a440c:	4631      	mov	r1, r6
 80a440e:	a801      	add	r0, sp, #4
 80a4410:	f7ff ffb1 	bl	80a4376 <_ZNSt8functionIFvRKbEEC1ERKS3_>
      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 80a4414:	7823      	ldrb	r3, [r4, #0]
        } else {
            // Bind all arguments and wrap resulting function into a pointer
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
 80a4416:	2010      	movs	r0, #16
 80a4418:	f88d 3014 	strb.w	r3, [sp, #20]
 80a441c:	f7fb fe3d 	bl	80a009a <_Znwj>
 80a4420:	4605      	mov	r5, r0
 80a4422:	b1d0      	cbz	r0, 80a445a <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x82>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a4424:	6087      	str	r7, [r0, #8]
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a4426:	2014      	movs	r0, #20
 80a4428:	f7fb fe37 	bl	80a009a <_Znwj>
 80a442c:	4604      	mov	r4, r0
 80a442e:	b178      	cbz	r0, 80a4450 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x78>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a4430:	6087      	str	r7, [r0, #8]
       *  Swap the targets of @c this function object and @a __f. This
       *  function will not throw an %exception.
       */
      void swap(function& __x)
      {
	std::swap(_M_functor, __x._M_functor);
 80a4432:	4601      	mov	r1, r0
 80a4434:	a801      	add	r0, sp, #4
 80a4436:	f7ff fd27 	bl	80a3e88 <_ZSt4swapISt9_Any_dataEvRT_S2_>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a443a:	9b03      	ldr	r3, [sp, #12]
      __a = _GLIBCXX_MOVE(__b);
 80a443c:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a443e:	60a3      	str	r3, [r4, #8]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a4440:	9b04      	ldr	r3, [sp, #16]
      __a = _GLIBCXX_MOVE(__b);
 80a4442:	9203      	str	r2, [sp, #12]
 80a4444:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a4446:	60e3      	str	r3, [r4, #12]
 80a4448:	f89d 3014 	ldrb.w	r3, [sp, #20]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a444c:	9204      	str	r2, [sp, #16]
 80a444e:	7423      	strb	r3, [r4, #16]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a4450:	4b0a      	ldr	r3, [pc, #40]	; (80a447c <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xa4>)
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a4452:	602c      	str	r4, [r5, #0]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a4454:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a4456:	4b0a      	ldr	r3, [pc, #40]	; (80a4480 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xa8>)
 80a4458:	60ab      	str	r3, [r5, #8]
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a445a:	a801      	add	r0, sp, #4
 80a445c:	f7ff fd05 	bl	80a3e6a <_ZNSt14_Function_baseD1Ev>
        spark_process();
    }

    // Asynchronously invokes a callback in the application context
    static bool invokeApplicationCallback(void (*callback)(void* data), void* data) {
        return (application_thread_invoke(callback, data, nullptr) == 0);
 80a4460:	2200      	movs	r2, #0
 80a4462:	4629      	mov	r1, r5
 80a4464:	4807      	ldr	r0, [pc, #28]	; (80a4484 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xac>)
 80a4466:	f7ff faa3 	bl	80a39b0 <application_thread_invoke>
 80a446a:	4630      	mov	r0, r6
 80a446c:	f7ff fcfd 	bl	80a3e6a <_ZNSt14_Function_baseD1Ev>
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(std::atomic<std::function<FunctionT>*>& wrapper, ArgsT&&... args) {
        std::function<FunctionT>* callbackPtr = wrapper.exchange(nullptr, std::memory_order_acq_rel);
        if (callbackPtr) {
            invokeCallback(*callbackPtr, std::forward<ArgsT>(args)...);
            delete callbackPtr;
 80a4470:	4630      	mov	r0, r6
 80a4472:	f7fb fe14 	bl	80a009e <_ZdlPv>
        }
    }
 80a4476:	b007      	add	sp, #28
 80a4478:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a447a:	bf00      	nop
 80a447c:	080a40e5 	.word	0x080a40e5
 80a4480:	080a4395 	.word	0x080a4395
 80a4484:	080a47b9 	.word	0x080a47b9

080a4488 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_>:
namespace {

using namespace particle;

#ifndef SPARK_NO_CLOUD
void publishCompletionCallback(int error, const void* data, void* callbackData, void* reserved) {
 80a4488:	b530      	push	{r4, r5, lr}
 80a448a:	4604      	mov	r4, r0
 80a448c:	b085      	sub	sp, #20
 80a448e:	460d      	mov	r5, r1
    auto p = Promise<bool>::fromDataPtr(callbackData);
 80a4490:	4668      	mov	r0, sp
 80a4492:	4611      	mov	r1, r2
 80a4494:	f7ff fdf0 	bl	80a4078 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
    if (error != Error::NONE) {
 80a4498:	b17c      	cbz	r4, 80a44ba <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
        p.setError(Error((Error::Type)error, (const char*)data));
 80a449a:	b224      	sxth	r4, r4
        type_(type) {
}

inline particle::Error::Error(Type type, const char* msg) :
        msg_(msg ? (const char*)strdup(msg) : nullptr),
        type_(type) {
 80a449c:	4628      	mov	r0, r5
 80a449e:	b10d      	cbz	r5, 80a44a4 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x1c>
 80a44a0:	f001 fc12 	bl	80a5cc8 <strdup>
 80a44a4:	9002      	str	r0, [sp, #8]
 80a44a6:	a902      	add	r1, sp, #8
 80a44a8:	4668      	mov	r0, sp
 80a44aa:	f8ad 400c 	strh.w	r4, [sp, #12]
 80a44ae:	f7ff fe2f 	bl	80a4110 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
        Error() {
    swap(*this, error);
}

inline particle::Error::~Error() {
    free((void*)msg_);
 80a44b2:	9802      	ldr	r0, [sp, #8]
 80a44b4:	f7ff fac0 	bl	80a3a38 <free>
 80a44b8:	e01d      	b.n	80a44f6 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x6e>

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s, 
			      memory_order __f) noexcept
      {
	return __atomic_compare_exchange(&_M_i, &__e, &__i, false, __s, __f);
 80a44ba:	f04f 0201 	mov.w	r2, #1
 80a44be:	9800      	ldr	r0, [sp, #0]
            onSuccess_(nullptr),
            onError_(nullptr) {
    }

    bool changeState(State state) {
        State s = State::RUNNING; // Expected state
 80a44c0:	f88d 4008 	strb.w	r4, [sp, #8]
 80a44c4:	e8d0 3f4f 	ldrexb	r3, [r0]
 80a44c8:	42a3      	cmp	r3, r4
 80a44ca:	d103      	bne.n	80a44d4 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x4c>
 80a44cc:	e8c0 2f41 	strexb	r1, r2, [r0]
 80a44d0:	2900      	cmp	r1, #0
 80a44d2:	d1f7      	bne.n	80a44c4 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x3c>
 80a44d4:	d002      	beq.n	80a44dc <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x54>
 80a44d6:	f88d 3008 	strb.w	r3, [sp, #8]
 80a44da:	e00c      	b.n	80a44f6 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x6e>
        }
    }

    void setResult(ResultT result) {
        if (this->changeState(State::SUCCEEDED)) {
            new(&result_) ResultT(std::move(result));
 80a44dc:	f110 010c 	adds.w	r1, r0, #12
 80a44e0:	f04f 0301 	mov.w	r3, #1
 80a44e4:	bf18      	it	ne
 80a44e6:	7303      	strbne	r3, [r0, #12]
        memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_acquire);
	__glibcxx_assert(__b != memory_order_acq_rel);
	__glibcxx_assert(__b != memory_order_consume);

	__atomic_store_n(&_M_i, __i, __m);
 80a44e8:	f3bf 8f5f 	dmb	sy
            this->releaseDone();
            this->invokeCallback(this->onSuccess_, result_);
 80a44ec:	3004      	adds	r0, #4
 80a44ee:	f800 3c03 	strb.w	r3, [r0, #-3]
 80a44f2:	f7ff ff71 	bl	80a43d8 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_>
 80a44f6:	a801      	add	r0, sp, #4
 80a44f8:	f7ff fc79 	bl	80a3dee <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
    } else {
        p.setResult(true);
    }
}
 80a44fc:	b005      	add	sp, #20
 80a44fe:	bd30      	pop	{r4, r5, pc}

080a4500 <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a4500:	4770      	bx	lr

080a4502 <_ZN9IPAddressD0Ev>:
 80a4502:	b510      	push	{r4, lr}
 80a4504:	4604      	mov	r4, r0
 80a4506:	f7fb fdca 	bl	80a009e <_ZdlPv>
 80a450a:	4620      	mov	r0, r4
 80a450c:	bd10      	pop	{r4, pc}

080a450e <_ZNK9IPAddress7printToER5Print>:
#endif
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a450e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a4510:	460f      	mov	r7, r1
 80a4512:	f100 0608 	add.w	r6, r0, #8
 80a4516:	1d05      	adds	r5, r0, #4
 80a4518:	2400      	movs	r4, #0
    size_t n = 0;
    for (int i = 0; i < 4; i++)
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a451a:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 80a451e:	220a      	movs	r2, #10
 80a4520:	4638      	mov	r0, r7
 80a4522:	f7ff fc1e 	bl	80a3d62 <_ZN5Print5printEhi>
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a4526:	42ae      	cmp	r6, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a4528:	4404      	add	r4, r0
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a452a:	d007      	beq.n	80a453c <_ZNK9IPAddress7printToER5Print+0x2e>
    {
        if (n)
 80a452c:	2c00      	cmp	r4, #0
 80a452e:	d0f4      	beq.n	80a451a <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a4530:	212e      	movs	r1, #46	; 0x2e
 80a4532:	4638      	mov	r0, r7
 80a4534:	f7ff fbd2 	bl	80a3cdc <_ZN5Print5printEc>
 80a4538:	4404      	add	r4, r0
 80a453a:	e7ee      	b.n	80a451a <_ZNK9IPAddress7printToER5Print+0xc>
        n += p.print((*this)[i], DEC);
    }
    return n;
}
 80a453c:	4620      	mov	r0, r4
 80a453e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a4540 <_ZN9IPAddress8set_ipv4Ehhhh>:
    return address.ipv4!=0;
#endif
}

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
 80a4540:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a4542:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a4546:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80a454a:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 80a454e:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
 80a4552:	2304      	movs	r3, #4
 80a4554:	6041      	str	r1, [r0, #4]
 80a4556:	7503      	strb	r3, [r0, #20]
 80a4558:	bd10      	pop	{r4, pc}
	...

080a455c <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a455c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a455e:	4d04      	ldr	r5, [pc, #16]	; (80a4570 <_ZN9IPAddressC1Ehhhh+0x14>)
 80a4560:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a4562:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a4566:	9500      	str	r5, [sp, #0]
 80a4568:	f7ff ffea 	bl	80a4540 <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a456c:	b003      	add	sp, #12
 80a456e:	bd30      	pop	{r4, r5, pc}
 80a4570:	080a6bf8 	.word	0x080a6bf8

080a4574 <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a4574:	7441      	strb	r1, [r0, #17]
 80a4576:	4770      	bx	lr

080a4578 <_ZN9USBSerialD1Ev>:
#include "spark_wiring_platform.h"
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"

class USBSerial : public Stream
 80a4578:	4770      	bx	lr

080a457a <_ZN9USBSerial4readEv>:


// Read data from buffer
int USBSerial::read()
{
	return HAL_USB_USART_Receive_Data(_serial, false);
 80a457a:	2100      	movs	r1, #0
 80a457c:	7c00      	ldrb	r0, [r0, #16]
 80a457e:	f7ff b9df 	b.w	80a3940 <HAL_USB_USART_Receive_Data>

080a4582 <_ZN9USBSerial4peekEv>:
  _blocking = block;
}

int USBSerial::peek()
{
	return HAL_USB_USART_Receive_Data(_serial, true);
 80a4582:	2101      	movs	r1, #1
 80a4584:	7c00      	ldrb	r0, [r0, #16]
 80a4586:	f7ff b9db 	b.w	80a3940 <HAL_USB_USART_Receive_Data>

080a458a <_ZN9USBSerial17availableForWriteEv>:
	return HAL_USB_USART_Receive_Data(_serial, false);
}

int USBSerial::availableForWrite()
{
  return HAL_USB_USART_Available_Data_For_Write(_serial);
 80a458a:	7c00      	ldrb	r0, [r0, #16]
 80a458c:	f7ff b9d0 	b.w	80a3930 <HAL_USB_USART_Available_Data_For_Write>

080a4590 <_ZN9USBSerial9availableEv>:
}

int USBSerial::available()
{
	return HAL_USB_USART_Available_Data(_serial);
 80a4590:	7c00      	ldrb	r0, [r0, #16]
 80a4592:	f7ff b9c5 	b.w	80a3920 <HAL_USB_USART_Available_Data>

080a4596 <_ZN9USBSerial5writeEh>:
}

size_t USBSerial::write(uint8_t byte)
{
 80a4596:	b538      	push	{r3, r4, r5, lr}
 80a4598:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a459a:	7c00      	ldrb	r0, [r0, #16]
{
	return HAL_USB_USART_Available_Data(_serial);
}

size_t USBSerial::write(uint8_t byte)
{
 80a459c:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a459e:	f7ff f9c7 	bl	80a3930 <HAL_USB_USART_Available_Data_For_Write>
 80a45a2:	2800      	cmp	r0, #0
 80a45a4:	dc01      	bgt.n	80a45aa <_ZN9USBSerial5writeEh+0x14>
 80a45a6:	7c60      	ldrb	r0, [r4, #17]
 80a45a8:	b120      	cbz	r0, 80a45b4 <_ZN9USBSerial5writeEh+0x1e>
    HAL_USB_USART_Send_Data(_serial, byte);
 80a45aa:	4629      	mov	r1, r5
 80a45ac:	7c20      	ldrb	r0, [r4, #16]
 80a45ae:	f7ff f9cf 	bl	80a3950 <HAL_USB_USART_Send_Data>
    return 1;
 80a45b2:	2001      	movs	r0, #1
  }
  return 0;
}
 80a45b4:	bd38      	pop	{r3, r4, r5, pc}

080a45b6 <_ZN9USBSerial5flushEv>:

void USBSerial::flush()
{
  HAL_USB_USART_Flush_Data(_serial);
 80a45b6:	7c00      	ldrb	r0, [r0, #16]
 80a45b8:	f7ff b9d2 	b.w	80a3960 <HAL_USB_USART_Flush_Data>

080a45bc <_ZN9USBSerialD0Ev>:
 80a45bc:	b510      	push	{r4, lr}
 80a45be:	4604      	mov	r4, r0
 80a45c0:	f7fb fd6d 	bl	80a009e <_ZdlPv>
 80a45c4:	4620      	mov	r0, r4
 80a45c6:	bd10      	pop	{r4, pc}

080a45c8 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a45c8:	b510      	push	{r4, lr}
 80a45ca:	4604      	mov	r4, r0
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a45cc:	2300      	movs	r3, #0
 80a45ce:	6063      	str	r3, [r4, #4]
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a45d0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a45d4:	60a3      	str	r3, [r4, #8]
 80a45d6:	4b05      	ldr	r3, [pc, #20]	; (80a45ec <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
 80a45d8:	4608      	mov	r0, r1
 80a45da:	6023      	str	r3, [r4, #0]
{
  _serial = serial;
  _blocking = true;
 80a45dc:	2301      	movs	r3, #1
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
{
  _serial = serial;
 80a45de:	7421      	strb	r1, [r4, #16]
  _blocking = true;
 80a45e0:	7463      	strb	r3, [r4, #17]

  HAL_USB_USART_Init(_serial, &conf);
 80a45e2:	4611      	mov	r1, r2
 80a45e4:	f7ff f98c 	bl	80a3900 <HAL_USB_USART_Init>
}
 80a45e8:	4620      	mov	r0, r4
 80a45ea:	bd10      	pop	{r4, pc}
 80a45ec:	080a6c0c 	.word	0x080a6c0c

080a45f0 <_ZN9USBSerial5beginEl>:
// Public methods
//

void USBSerial::begin(long speed)
{
    HAL_USB_USART_Begin(_serial, speed, NULL);
 80a45f0:	2200      	movs	r2, #0
 80a45f2:	7c00      	ldrb	r0, [r0, #16]
 80a45f4:	f7ff b98c 	b.w	80a3910 <HAL_USB_USART_Begin>

080a45f8 <_Z19acquireSerialBufferv>:
 80a45f8:	b510      	push	{r4, lr}
 80a45fa:	4604      	mov	r4, r0
 80a45fc:	2214      	movs	r2, #20
 80a45fe:	2100      	movs	r1, #0
 80a4600:	f001 fad5 	bl	80a5bae <memset>
 80a4604:	4620      	mov	r0, r4
 80a4606:	bd10      	pop	{r4, pc}

080a4608 <_Z16_fetch_usbserialv>:

  return conf;
}

USBSerial& _fetch_usbserial()
{
 80a4608:	b530      	push	{r4, r5, lr}
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a460a:	4d0e      	ldr	r5, [pc, #56]	; (80a4644 <_Z16_fetch_usbserialv+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial()
{
 80a460c:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a460e:	a801      	add	r0, sp, #4
 80a4610:	f7ff fff2 	bl	80a45f8 <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a4614:	6829      	ldr	r1, [r5, #0]
 80a4616:	f011 0401 	ands.w	r4, r1, #1
 80a461a:	d110      	bne.n	80a463e <_Z16_fetch_usbserialv+0x36>
 80a461c:	4628      	mov	r0, r5
 80a461e:	f7fb fd4b 	bl	80a00b8 <__cxa_guard_acquire>
 80a4622:	b160      	cbz	r0, 80a463e <_Z16_fetch_usbserialv+0x36>
 80a4624:	aa01      	add	r2, sp, #4
 80a4626:	4621      	mov	r1, r4
 80a4628:	4807      	ldr	r0, [pc, #28]	; (80a4648 <_Z16_fetch_usbserialv+0x40>)
 80a462a:	f7ff ffcd 	bl	80a45c8 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a462e:	4628      	mov	r0, r5
 80a4630:	f7fb fd47 	bl	80a00c2 <__cxa_guard_release>
 80a4634:	4a05      	ldr	r2, [pc, #20]	; (80a464c <_Z16_fetch_usbserialv+0x44>)
 80a4636:	4906      	ldr	r1, [pc, #24]	; (80a4650 <_Z16_fetch_usbserialv+0x48>)
 80a4638:	4803      	ldr	r0, [pc, #12]	; (80a4648 <_Z16_fetch_usbserialv+0x40>)
 80a463a:	f000 f9cf 	bl	80a49dc <__aeabi_atexit>
	return _usbserial;
}
 80a463e:	4802      	ldr	r0, [pc, #8]	; (80a4648 <_Z16_fetch_usbserialv+0x40>)
 80a4640:	b007      	add	sp, #28
 80a4642:	bd30      	pop	{r4, r5, pc}
 80a4644:	200013f8 	.word	0x200013f8
 80a4648:	20001400 	.word	0x20001400
 80a464c:	200004f0 	.word	0x200004f0
 80a4650:	080a4579 	.word	0x080a4579

080a4654 <_Z23acquireUSBSerial1Bufferv>:

#if Wiring_USBSerial1

HAL_USB_USART_Config __attribute__((weak)) acquireUSBSerial1Buffer()
{
 80a4654:	b510      	push	{r4, lr}
 80a4656:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a4658:	2214      	movs	r2, #20
 80a465a:	2100      	movs	r1, #0
 80a465c:	f001 faa7 	bl	80a5bae <memset>
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a4660:	4620      	mov	r0, r4
 80a4662:	bd10      	pop	{r4, pc}

080a4664 <_Z17_fetch_usbserial1v>:

USBSerial& _fetch_usbserial1()
{
 80a4664:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a4666:	4c0e      	ldr	r4, [pc, #56]	; (80a46a0 <_Z17_fetch_usbserial1v+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial1()
{
 80a4668:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a466a:	a801      	add	r0, sp, #4
 80a466c:	f7ff fff2 	bl	80a4654 <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a4670:	6823      	ldr	r3, [r4, #0]
 80a4672:	07db      	lsls	r3, r3, #31
 80a4674:	d410      	bmi.n	80a4698 <_Z17_fetch_usbserial1v+0x34>
 80a4676:	4620      	mov	r0, r4
 80a4678:	f7fb fd1e 	bl	80a00b8 <__cxa_guard_acquire>
 80a467c:	b160      	cbz	r0, 80a4698 <_Z17_fetch_usbserial1v+0x34>
 80a467e:	aa01      	add	r2, sp, #4
 80a4680:	2101      	movs	r1, #1
 80a4682:	4808      	ldr	r0, [pc, #32]	; (80a46a4 <_Z17_fetch_usbserial1v+0x40>)
 80a4684:	f7ff ffa0 	bl	80a45c8 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a4688:	4620      	mov	r0, r4
 80a468a:	f7fb fd1a 	bl	80a00c2 <__cxa_guard_release>
 80a468e:	4a06      	ldr	r2, [pc, #24]	; (80a46a8 <_Z17_fetch_usbserial1v+0x44>)
 80a4690:	4906      	ldr	r1, [pc, #24]	; (80a46ac <_Z17_fetch_usbserial1v+0x48>)
 80a4692:	4804      	ldr	r0, [pc, #16]	; (80a46a4 <_Z17_fetch_usbserial1v+0x40>)
 80a4694:	f000 f9a2 	bl	80a49dc <__aeabi_atexit>
  return _usbserial1;
}
 80a4698:	4802      	ldr	r0, [pc, #8]	; (80a46a4 <_Z17_fetch_usbserial1v+0x40>)
 80a469a:	b006      	add	sp, #24
 80a469c:	bd10      	pop	{r4, pc}
 80a469e:	bf00      	nop
 80a46a0:	200013fc 	.word	0x200013fc
 80a46a4:	20001414 	.word	0x20001414
 80a46a8:	200004f0 	.word	0x200004f0
 80a46ac:	080a4579 	.word	0x080a4579

080a46b0 <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
 80a46b0:	4770      	bx	lr

080a46b2 <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a46b2:	7441      	strb	r1, [r0, #17]
 80a46b4:	4770      	bx	lr

080a46b6 <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
  return HAL_USART_Available_Data_For_Write(_serial);
 80a46b6:	7c00      	ldrb	r0, [r0, #16]
 80a46b8:	f7ff b8e0 	b.w	80a387c <HAL_USART_Available_Data_For_Write>

080a46bc <_ZN11USARTSerial9availableEv>:
}

int USARTSerial::available(void)
{
  return HAL_USART_Available_Data(_serial);
 80a46bc:	7c00      	ldrb	r0, [r0, #16]
 80a46be:	f7ff b8b5 	b.w	80a382c <HAL_USART_Available_Data>

080a46c2 <_ZN11USARTSerial4peekEv>:
}

int USARTSerial::peek(void)
{
  return HAL_USART_Peek_Data(_serial);
 80a46c2:	7c00      	ldrb	r0, [r0, #16]
 80a46c4:	f7ff b8c2 	b.w	80a384c <HAL_USART_Peek_Data>

080a46c8 <_ZN11USARTSerial4readEv>:
}

int USARTSerial::read(void)
{
  return HAL_USART_Read_Data(_serial);
 80a46c8:	7c00      	ldrb	r0, [r0, #16]
 80a46ca:	f7ff b8b7 	b.w	80a383c <HAL_USART_Read_Data>

080a46ce <_ZN11USARTSerial5flushEv>:
}

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
 80a46ce:	7c00      	ldrb	r0, [r0, #16]
 80a46d0:	f7ff b8c4 	b.w	80a385c <HAL_USART_Flush_Data>

080a46d4 <_ZN11USARTSerialD0Ev>:
 80a46d4:	b510      	push	{r4, lr}
 80a46d6:	4604      	mov	r4, r0
 80a46d8:	f7fb fce1 	bl	80a009e <_ZdlPv>
 80a46dc:	4620      	mov	r0, r4
 80a46de:	bd10      	pop	{r4, pc}

080a46e0 <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
 80a46e0:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a46e2:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
 80a46e4:	4604      	mov	r4, r0
 80a46e6:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a46e8:	b925      	cbnz	r5, 80a46f4 <_ZN11USARTSerial5writeEh+0x14>
 80a46ea:	7c00      	ldrb	r0, [r0, #16]
 80a46ec:	f7ff f8c6 	bl	80a387c <HAL_USART_Available_Data_For_Write>
 80a46f0:	2800      	cmp	r0, #0
 80a46f2:	dd05      	ble.n	80a4700 <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a46f4:	4631      	mov	r1, r6
 80a46f6:	7c20      	ldrb	r0, [r4, #16]
  }
  return 0;
}
 80a46f8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a46fc:	f7ff b88e 	b.w	80a381c <HAL_USART_Write_Data>
  }
  return 0;
}
 80a4700:	4628      	mov	r0, r5
 80a4702:	bd70      	pop	{r4, r5, r6, pc}

080a4704 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a4704:	b510      	push	{r4, lr}
 80a4706:	4604      	mov	r4, r0
 80a4708:	4608      	mov	r0, r1
 80a470a:	4611      	mov	r1, r2
 80a470c:	2200      	movs	r2, #0
 80a470e:	6062      	str	r2, [r4, #4]
 80a4710:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a4714:	60a2      	str	r2, [r4, #8]
 80a4716:	4a05      	ldr	r2, [pc, #20]	; (80a472c <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
{
  _serial = serial;
 80a4718:	7420      	strb	r0, [r4, #16]
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a471a:	6022      	str	r2, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
 80a471c:	2201      	movs	r2, #1
 80a471e:	7462      	strb	r2, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
 80a4720:	461a      	mov	r2, r3
 80a4722:	f7ff f873 	bl	80a380c <HAL_USART_Init>
}
 80a4726:	4620      	mov	r0, r4
 80a4728:	bd10      	pop	{r4, pc}
 80a472a:	bf00      	nop
 80a472c:	080a6c3c 	.word	0x080a6c3c

080a4730 <_ZN11USARTSerial9isEnabledEv>:
USARTSerial::operator bool() {
  return true;
}

bool USARTSerial::isEnabled() {
  return HAL_USART_Is_Enabled(_serial);
 80a4730:	7c00      	ldrb	r0, [r0, #16]
 80a4732:	f7ff b89b 	b.w	80a386c <HAL_USART_Is_Enabled>
	...

080a4738 <_Z22__fetch_global_Serial1v>:
static Ring_Buffer* serial1_rx_buffer = NULL;
static Ring_Buffer* serial1_tx_buffer = NULL;
#endif

USARTSerial& __fetch_global_Serial1()
{
 80a4738:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
#else
  if (!serial1_rx_buffer) {
 80a473a:	4c19      	ldr	r4, [pc, #100]	; (80a47a0 <_Z22__fetch_global_Serial1v+0x68>)
 80a473c:	6825      	ldr	r5, [r4, #0]
 80a473e:	b94d      	cbnz	r5, 80a4754 <_Z22__fetch_global_Serial1v+0x1c>
    serial1_rx_buffer = new Ring_Buffer();
 80a4740:	2084      	movs	r0, #132	; 0x84
 80a4742:	f7fb fcaa 	bl	80a009a <_Znwj>
 80a4746:	4606      	mov	r6, r0
 80a4748:	b118      	cbz	r0, 80a4752 <_Z22__fetch_global_Serial1v+0x1a>
 80a474a:	2284      	movs	r2, #132	; 0x84
 80a474c:	4629      	mov	r1, r5
 80a474e:	f001 fa2e 	bl	80a5bae <memset>
 80a4752:	6026      	str	r6, [r4, #0]
  }
  if (!serial1_tx_buffer) {
 80a4754:	4d13      	ldr	r5, [pc, #76]	; (80a47a4 <_Z22__fetch_global_Serial1v+0x6c>)
 80a4756:	682e      	ldr	r6, [r5, #0]
 80a4758:	b94e      	cbnz	r6, 80a476e <_Z22__fetch_global_Serial1v+0x36>
    serial1_tx_buffer = new Ring_Buffer();
 80a475a:	2084      	movs	r0, #132	; 0x84
 80a475c:	f7fb fc9d 	bl	80a009a <_Znwj>
 80a4760:	4607      	mov	r7, r0
 80a4762:	b118      	cbz	r0, 80a476c <_Z22__fetch_global_Serial1v+0x34>
 80a4764:	2284      	movs	r2, #132	; 0x84
 80a4766:	4631      	mov	r1, r6
 80a4768:	f001 fa21 	bl	80a5bae <memset>
 80a476c:	602f      	str	r7, [r5, #0]
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
 80a476e:	4f0e      	ldr	r7, [pc, #56]	; (80a47a8 <_Z22__fetch_global_Serial1v+0x70>)
 80a4770:	6839      	ldr	r1, [r7, #0]
 80a4772:	f011 0601 	ands.w	r6, r1, #1
 80a4776:	d111      	bne.n	80a479c <_Z22__fetch_global_Serial1v+0x64>
 80a4778:	4638      	mov	r0, r7
 80a477a:	f7fb fc9d 	bl	80a00b8 <__cxa_guard_acquire>
 80a477e:	b168      	cbz	r0, 80a479c <_Z22__fetch_global_Serial1v+0x64>
 80a4780:	6822      	ldr	r2, [r4, #0]
 80a4782:	4631      	mov	r1, r6
 80a4784:	682b      	ldr	r3, [r5, #0]
 80a4786:	4809      	ldr	r0, [pc, #36]	; (80a47ac <_Z22__fetch_global_Serial1v+0x74>)
 80a4788:	f7ff ffbc 	bl	80a4704 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
 80a478c:	4638      	mov	r0, r7
 80a478e:	f7fb fc98 	bl	80a00c2 <__cxa_guard_release>
 80a4792:	4a07      	ldr	r2, [pc, #28]	; (80a47b0 <_Z22__fetch_global_Serial1v+0x78>)
 80a4794:	4907      	ldr	r1, [pc, #28]	; (80a47b4 <_Z22__fetch_global_Serial1v+0x7c>)
 80a4796:	4805      	ldr	r0, [pc, #20]	; (80a47ac <_Z22__fetch_global_Serial1v+0x74>)
 80a4798:	f000 f920 	bl	80a49dc <__aeabi_atexit>
#endif
	return serial1;
}
 80a479c:	4803      	ldr	r0, [pc, #12]	; (80a47ac <_Z22__fetch_global_Serial1v+0x74>)
 80a479e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a47a0:	20001444 	.word	0x20001444
 80a47a4:	2000143c 	.word	0x2000143c
 80a47a8:	20001440 	.word	0x20001440
 80a47ac:	20001428 	.word	0x20001428
 80a47b0:	200004f0 	.word	0x200004f0
 80a47b4:	080a46b1 	.word	0x080a46b1

080a47b8 <_ZN8particle6detail21futureCallbackWrapperEPv>:
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#include "spark_wiring_async.h"

void particle::detail::futureCallbackWrapper(void* data) {
 80a47b8:	b510      	push	{r4, lr}
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a47ba:	6883      	ldr	r3, [r0, #8]
 80a47bc:	4604      	mov	r4, r0
 80a47be:	b90b      	cbnz	r3, 80a47c4 <_ZN8particle6detail21futureCallbackWrapperEPv+0xc>
	__throw_bad_function_call();
 80a47c0:	f000 f911 	bl	80a49e6 <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a47c4:	68c3      	ldr	r3, [r0, #12]
 80a47c6:	4798      	blx	r3

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
    {
      if (_M_manager)
 80a47c8:	68a3      	ldr	r3, [r4, #8]
 80a47ca:	b11b      	cbz	r3, 80a47d4 <_ZN8particle6detail21futureCallbackWrapperEPv+0x1c>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a47cc:	2203      	movs	r2, #3
 80a47ce:	4621      	mov	r1, r4
 80a47d0:	4620      	mov	r0, r4
 80a47d2:	4798      	blx	r3
    auto callbackPtr = static_cast<const std::function<void()>*>(data);
    (*callbackPtr)();
    delete callbackPtr;
 80a47d4:	4620      	mov	r0, r4
}
 80a47d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
#include "spark_wiring_async.h"

void particle::detail::futureCallbackWrapper(void* data) {
    auto callbackPtr = static_cast<const std::function<void()>*>(data);
    (*callbackPtr)();
    delete callbackPtr;
 80a47da:	f7fb bc60 	b.w	80a009e <_ZdlPv>

080a47de <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c);
  virtual ~TwoWire() {};
 80a47de:	4770      	bx	lr

080a47e0 <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a47e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a47e2:	4606      	mov	r6, r0
 80a47e4:	4615      	mov	r5, r2
 80a47e6:	460c      	mov	r4, r1
 80a47e8:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a47ea:	42bc      	cmp	r4, r7
 80a47ec:	d006      	beq.n	80a47fc <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a47ee:	6833      	ldr	r3, [r6, #0]
 80a47f0:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a47f4:	689b      	ldr	r3, [r3, #8]
 80a47f6:	4630      	mov	r0, r6
 80a47f8:	4798      	blx	r3
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a47fa:	e7f6      	b.n	80a47ea <_ZN7TwoWire5writeEPKhj+0xa>
  {
    write(data[i]);
  }

  return quantity;
}
 80a47fc:	4628      	mov	r0, r5
 80a47fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a4800 <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
 80a4800:	2200      	movs	r2, #0
 80a4802:	7c00      	ldrb	r0, [r0, #16]
 80a4804:	f7ff b842 	b.w	80a388c <HAL_I2C_Write_Data>

080a4808 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
 80a4808:	2100      	movs	r1, #0
 80a480a:	7c00      	ldrb	r0, [r0, #16]
 80a480c:	f7ff b846 	b.w	80a389c <HAL_I2C_Available_Data>

080a4810 <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
 80a4810:	2100      	movs	r1, #0
 80a4812:	7c00      	ldrb	r0, [r0, #16]
 80a4814:	f7ff b84a 	b.w	80a38ac <HAL_I2C_Read_Data>

080a4818 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
 80a4818:	2100      	movs	r1, #0
 80a481a:	7c00      	ldrb	r0, [r0, #16]
 80a481c:	f7ff b84e 	b.w	80a38bc <HAL_I2C_Peek_Data>

080a4820 <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
 80a4820:	2100      	movs	r1, #0
 80a4822:	7c00      	ldrb	r0, [r0, #16]
 80a4824:	f7ff b852 	b.w	80a38cc <HAL_I2C_Flush_Data>

080a4828 <_ZN7TwoWireD0Ev>:
 80a4828:	b510      	push	{r4, lr}
 80a482a:	4604      	mov	r4, r0
 80a482c:	f7fb fc37 	bl	80a009e <_ZdlPv>
 80a4830:	4620      	mov	r0, r4
 80a4832:	bd10      	pop	{r4, pc}

080a4834 <_ZN7TwoWireC1E17HAL_I2C_Interface>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a4834:	b510      	push	{r4, lr}
 80a4836:	4604      	mov	r4, r0
 80a4838:	4608      	mov	r0, r1
 80a483a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a483e:	60a3      	str	r3, [r4, #8]
 80a4840:	4b04      	ldr	r3, [pc, #16]	; (80a4854 <_ZN7TwoWireC1E17HAL_I2C_Interface+0x20>)
 80a4842:	2100      	movs	r1, #0
{
  _i2c = i2c;
 80a4844:	7420      	strb	r0, [r4, #16]
 80a4846:	6061      	str	r1, [r4, #4]
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a4848:	6023      	str	r3, [r4, #0]
{
  _i2c = i2c;
  HAL_I2C_Init(_i2c, NULL);
 80a484a:	f7ff f84f 	bl	80a38ec <HAL_I2C_Init>

}
 80a484e:	4620      	mov	r0, r4
 80a4850:	bd10      	pop	{r4, pc}
 80a4852:	bf00      	nop
 80a4854:	080a6c6c 	.word	0x080a6c6c

080a4858 <_ZN7TwoWire9isEnabledEv>:
  HAL_I2C_Set_Callback_On_Request(_i2c, function, NULL);
}

bool TwoWire::isEnabled()
{
  return HAL_I2C_Is_Enabled(_i2c, NULL);
 80a4858:	2100      	movs	r1, #0
 80a485a:	7c00      	ldrb	r0, [r0, #16]
 80a485c:	f7ff b83e 	b.w	80a38dc <HAL_I2C_Is_Enabled>

080a4860 <_ZN5spark9WiFiClassD1Ev>:
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
    ~WiFiClass() {}
 80a4860:	4770      	bx	lr

080a4862 <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a4862:	2200      	movs	r2, #0
 80a4864:	4611      	mov	r1, r2
 80a4866:	4610      	mov	r0, r2
 80a4868:	f7ff b8be 	b.w	80a39e8 <network_ready>

080a486c <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t>:
    void setIPAddressSource(IPAddressSource source) {
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
 80a486c:	4803      	ldr	r0, [pc, #12]	; (80a487c <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x10>)
 80a486e:	4b04      	ldr	r3, [pc, #16]	; (80a4880 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x14>)
one second timeout is reached). If the aforementioned "bug" is ever fixed by
TI, no changes need to be made to this function, as it would be implemented
the same way.
*****************************************************************************/

    WiFiClass WiFi;
 80a4870:	4a04      	ldr	r2, [pc, #16]	; (80a4884 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x18>)
 80a4872:	4905      	ldr	r1, [pc, #20]	; (80a4888 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x1c>)
 80a4874:	6003      	str	r3, [r0, #0]
 80a4876:	f000 b8b1 	b.w	80a49dc <__aeabi_atexit>
 80a487a:	bf00      	nop
 80a487c:	20001448 	.word	0x20001448
 80a4880:	080a6c94 	.word	0x080a6c94
 80a4884:	200004f0 	.word	0x200004f0
 80a4888:	080a4861 	.word	0x080a4861

080a488c <pinAvailable>:

/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
 80a488c:	b510      	push	{r4, lr}
 80a488e:	4604      	mov	r4, r0

  // SPI safety check
#ifndef SPARK_WIRING_NO_SPI
  if(SPI.isEnabled() == true && (pin == SCK || pin == MOSI || pin == MISO))
 80a4890:	480f      	ldr	r0, [pc, #60]	; (80a48d0 <pinAvailable+0x44>)
 80a4892:	f7ff f91d 	bl	80a3ad0 <_ZN8SPIClass9isEnabledEv>
 80a4896:	b128      	cbz	r0, 80a48a4 <pinAvailable+0x18>
 80a4898:	f1a4 030d 	sub.w	r3, r4, #13
 80a489c:	2b02      	cmp	r3, #2
 80a489e:	d801      	bhi.n	80a48a4 <pinAvailable+0x18>
  {
    return 0; // 'pin' is used
 80a48a0:	2000      	movs	r0, #0
 80a48a2:	bd10      	pop	{r4, pc}
  }
#endif
  // I2C safety check
#ifndef SPARK_WIRING_NO_I2C
  if(Wire.isEnabled() == true && (pin == SCL || pin == SDA))
 80a48a4:	f000 f87a 	bl	80a499c <_Z19__fetch_global_Wirev>
 80a48a8:	f7ff ffd6 	bl	80a4858 <_ZN7TwoWire9isEnabledEv>
 80a48ac:	b108      	cbz	r0, 80a48b2 <pinAvailable+0x26>
 80a48ae:	2c01      	cmp	r4, #1
 80a48b0:	d9f6      	bls.n	80a48a0 <pinAvailable+0x14>
    return 0; // 'pin' is used
  }
#endif
#ifndef SPARK_WIRING_NO_USART_SERIAL
  // Serial1 safety check
  if(Serial1.isEnabled() == true && (pin == RX || pin == TX))
 80a48b2:	f7ff ff41 	bl	80a4738 <_Z22__fetch_global_Serial1v>
 80a48b6:	f7ff ff3b 	bl	80a4730 <_ZN11USARTSerial9isEnabledEv>
 80a48ba:	b118      	cbz	r0, 80a48c4 <pinAvailable+0x38>
 80a48bc:	f1a4 0312 	sub.w	r3, r4, #18
 80a48c0:	2b01      	cmp	r3, #1
 80a48c2:	d9ed      	bls.n	80a48a0 <pinAvailable+0x14>
  {
    return 0; // 'pin' is used
  }
#endif

  if (pin >= TOTAL_PINS)
 80a48c4:	2c17      	cmp	r4, #23
 80a48c6:	bf8c      	ite	hi
 80a48c8:	2000      	movhi	r0, #0
 80a48ca:	2001      	movls	r0, #1
    return 0;
  else
    return 1; // 'pin' is available
}
 80a48cc:	bd10      	pop	{r4, pc}
 80a48ce:	bf00      	nop
 80a48d0:	2000144c 	.word	0x2000144c

080a48d4 <pinMode>:
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a48d4:	2817      	cmp	r0, #23
/*
 * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP,
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{
 80a48d6:	b538      	push	{r3, r4, r5, lr}
 80a48d8:	4604      	mov	r4, r0
 80a48da:	460d      	mov	r5, r1

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a48dc:	d80a      	bhi.n	80a48f4 <pinMode+0x20>
 80a48de:	29ff      	cmp	r1, #255	; 0xff
 80a48e0:	d008      	beq.n	80a48f4 <pinMode+0x20>
  {
    return;
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a48e2:	f7ff ffd3 	bl	80a488c <pinAvailable>
 80a48e6:	b128      	cbz	r0, 80a48f4 <pinMode+0x20>
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a48e8:	4629      	mov	r1, r5
 80a48ea:	4620      	mov	r0, r4
}
 80a48ec:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a48f0:	f7fe bf34 	b.w	80a375c <HAL_Pin_Mode>
 80a48f4:	bd38      	pop	{r3, r4, r5, pc}

080a48f6 <digitalWrite>:

/*
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(pin_t pin, uint8_t value)
{
 80a48f6:	b538      	push	{r3, r4, r5, lr}
 80a48f8:	4604      	mov	r4, r0
 80a48fa:	460d      	mov	r5, r1
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a48fc:	f7fe ff36 	bl	80a376c <HAL_Get_Pin_Mode>
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
 80a4900:	28ff      	cmp	r0, #255	; 0xff
 80a4902:	d010      	beq.n	80a4926 <digitalWrite+0x30>
}

inline bool is_input_mode(PinMode mode) {
    return  mode == INPUT ||
            mode == INPUT_PULLUP ||
            mode == INPUT_PULLDOWN ||
 80a4904:	2806      	cmp	r0, #6
 80a4906:	d804      	bhi.n	80a4912 <digitalWrite+0x1c>
 80a4908:	234d      	movs	r3, #77	; 0x4d
 80a490a:	fa23 f000 	lsr.w	r0, r3, r0
 80a490e:	07c3      	lsls	r3, r0, #31
 80a4910:	d409      	bmi.n	80a4926 <digitalWrite+0x30>
{
    PinMode mode = HAL_Get_Pin_Mode(pin);
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
        return;
  // Safety check
  if( !pinAvailable(pin) ) {
 80a4912:	4620      	mov	r0, r4
 80a4914:	f7ff ffba 	bl	80a488c <pinAvailable>
 80a4918:	b128      	cbz	r0, 80a4926 <digitalWrite+0x30>
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a491a:	4629      	mov	r1, r5
 80a491c:	4620      	mov	r0, r4
}
 80a491e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a4922:	f7fe bf2b 	b.w	80a377c <HAL_GPIO_Write>
 80a4926:	bd38      	pop	{r3, r4, r5, pc}

080a4928 <_GLOBAL__sub_I_SPI>:
#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a4928:	b570      	push	{r4, r5, r6, lr}
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a492a:	4c0c      	ldr	r4, [pc, #48]	; (80a495c <_GLOBAL__sub_I_SPI+0x34>)
 80a492c:	4e0c      	ldr	r6, [pc, #48]	; (80a4960 <_GLOBAL__sub_I_SPI+0x38>)
 80a492e:	4d0d      	ldr	r5, [pc, #52]	; (80a4964 <_GLOBAL__sub_I_SPI+0x3c>)
 80a4930:	2100      	movs	r1, #0
 80a4932:	4620      	mov	r0, r4
 80a4934:	f7ff f8b8 	bl	80a3aa8 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a4938:	4620      	mov	r0, r4

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a493a:	4c0b      	ldr	r4, [pc, #44]	; (80a4968 <_GLOBAL__sub_I_SPI+0x40>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a493c:	4632      	mov	r2, r6
 80a493e:	4629      	mov	r1, r5
 80a4940:	f000 f84c 	bl	80a49dc <__aeabi_atexit>

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a4944:	2101      	movs	r1, #1
 80a4946:	4620      	mov	r0, r4
 80a4948:	f7ff f8ae 	bl	80a3aa8 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a494c:	4632      	mov	r2, r6
 80a494e:	4629      	mov	r1, r5
 80a4950:	4620      	mov	r0, r4
 80a4952:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80a4956:	f000 b841 	b.w	80a49dc <__aeabi_atexit>
 80a495a:	bf00      	nop
 80a495c:	2000144c 	.word	0x2000144c
 80a4960:	200004f0 	.word	0x200004f0
 80a4964:	080a3a99 	.word	0x080a3a99
 80a4968:	2000145c 	.word	0x2000145c

080a496c <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a496c:	b513      	push	{r0, r1, r4, lr}
 80a496e:	4c08      	ldr	r4, [pc, #32]	; (80a4990 <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a4970:	2300      	movs	r3, #0
 80a4972:	461a      	mov	r2, r3
 80a4974:	4619      	mov	r1, r3
 80a4976:	9300      	str	r3, [sp, #0]
 80a4978:	4620      	mov	r0, r4
 80a497a:	f7ff fdef 	bl	80a455c <_ZN9IPAddressC1Ehhhh>
 80a497e:	4620      	mov	r0, r4
 80a4980:	4a04      	ldr	r2, [pc, #16]	; (80a4994 <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a4982:	4905      	ldr	r1, [pc, #20]	; (80a4998 <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a4984:	b002      	add	sp, #8
 80a4986:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a498a:	f000 b827 	b.w	80a49dc <__aeabi_atexit>
 80a498e:	bf00      	nop
 80a4990:	20001470 	.word	0x20001470
 80a4994:	200004f0 	.word	0x200004f0
 80a4998:	080a4501 	.word	0x080a4501

080a499c <_Z19__fetch_global_Wirev>:
#include "i2c_hal.h"

#ifndef SPARK_WIRING_NO_I2C

TwoWire& __fetch_global_Wire()
{
 80a499c:	b538      	push	{r3, r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1);
 80a499e:	4d0b      	ldr	r5, [pc, #44]	; (80a49cc <_Z19__fetch_global_Wirev+0x30>)
 80a49a0:	6829      	ldr	r1, [r5, #0]
 80a49a2:	f011 0401 	ands.w	r4, r1, #1
 80a49a6:	d10f      	bne.n	80a49c8 <_Z19__fetch_global_Wirev+0x2c>
 80a49a8:	4628      	mov	r0, r5
 80a49aa:	f7fb fb85 	bl	80a00b8 <__cxa_guard_acquire>
 80a49ae:	b158      	cbz	r0, 80a49c8 <_Z19__fetch_global_Wirev+0x2c>
 80a49b0:	4621      	mov	r1, r4
 80a49b2:	4807      	ldr	r0, [pc, #28]	; (80a49d0 <_Z19__fetch_global_Wirev+0x34>)
 80a49b4:	f7ff ff3e 	bl	80a4834 <_ZN7TwoWireC1E17HAL_I2C_Interface>
 80a49b8:	4628      	mov	r0, r5
 80a49ba:	f7fb fb82 	bl	80a00c2 <__cxa_guard_release>
 80a49be:	4a05      	ldr	r2, [pc, #20]	; (80a49d4 <_Z19__fetch_global_Wirev+0x38>)
 80a49c0:	4905      	ldr	r1, [pc, #20]	; (80a49d8 <_Z19__fetch_global_Wirev+0x3c>)
 80a49c2:	4803      	ldr	r0, [pc, #12]	; (80a49d0 <_Z19__fetch_global_Wirev+0x34>)
 80a49c4:	f000 f80a 	bl	80a49dc <__aeabi_atexit>
	return wire;
}
 80a49c8:	4801      	ldr	r0, [pc, #4]	; (80a49d0 <_Z19__fetch_global_Wirev+0x34>)
 80a49ca:	bd38      	pop	{r3, r4, r5, pc}
 80a49cc:	20001488 	.word	0x20001488
 80a49d0:	2000148c 	.word	0x2000148c
 80a49d4:	200004f0 	.word	0x200004f0
 80a49d8:	080a47df 	.word	0x080a47df

080a49dc <__aeabi_atexit>:
 80a49dc:	460b      	mov	r3, r1
 80a49de:	4601      	mov	r1, r0
 80a49e0:	4618      	mov	r0, r3
 80a49e2:	f001 b8cb 	b.w	80a5b7c <__cxa_atexit>

080a49e6 <_ZSt25__throw_bad_function_callv>:
 80a49e6:	b508      	push	{r3, lr}
 80a49e8:	f7ff f846 	bl	80a3a78 <abort>

080a49ec <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a49ec:	4b18      	ldr	r3, [pc, #96]	; (80a4a50 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a49ee:	681a      	ldr	r2, [r3, #0]
 80a49f0:	07d1      	lsls	r1, r2, #31
 80a49f2:	bf5c      	itt	pl
 80a49f4:	2201      	movpl	r2, #1
 80a49f6:	601a      	strpl	r2, [r3, #0]
 80a49f8:	4b16      	ldr	r3, [pc, #88]	; (80a4a54 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a49fa:	681a      	ldr	r2, [r3, #0]
 80a49fc:	07d2      	lsls	r2, r2, #31
 80a49fe:	bf5c      	itt	pl
 80a4a00:	2201      	movpl	r2, #1
 80a4a02:	601a      	strpl	r2, [r3, #0]
 80a4a04:	4b14      	ldr	r3, [pc, #80]	; (80a4a58 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a4a06:	681a      	ldr	r2, [r3, #0]
 80a4a08:	07d0      	lsls	r0, r2, #31
 80a4a0a:	bf5c      	itt	pl
 80a4a0c:	2201      	movpl	r2, #1
 80a4a0e:	601a      	strpl	r2, [r3, #0]
 80a4a10:	4b12      	ldr	r3, [pc, #72]	; (80a4a5c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a4a12:	681a      	ldr	r2, [r3, #0]
 80a4a14:	07d1      	lsls	r1, r2, #31
 80a4a16:	bf5c      	itt	pl
 80a4a18:	2201      	movpl	r2, #1
 80a4a1a:	601a      	strpl	r2, [r3, #0]
 80a4a1c:	4b10      	ldr	r3, [pc, #64]	; (80a4a60 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a4a1e:	681a      	ldr	r2, [r3, #0]
 80a4a20:	07d2      	lsls	r2, r2, #31
 80a4a22:	bf5c      	itt	pl
 80a4a24:	2201      	movpl	r2, #1
 80a4a26:	601a      	strpl	r2, [r3, #0]
 80a4a28:	4b0e      	ldr	r3, [pc, #56]	; (80a4a64 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a4a2a:	681a      	ldr	r2, [r3, #0]
 80a4a2c:	07d0      	lsls	r0, r2, #31
 80a4a2e:	bf5c      	itt	pl
 80a4a30:	2201      	movpl	r2, #1
 80a4a32:	601a      	strpl	r2, [r3, #0]
 80a4a34:	4b0c      	ldr	r3, [pc, #48]	; (80a4a68 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a4a36:	681a      	ldr	r2, [r3, #0]
 80a4a38:	07d1      	lsls	r1, r2, #31
 80a4a3a:	bf5c      	itt	pl
 80a4a3c:	2201      	movpl	r2, #1
 80a4a3e:	601a      	strpl	r2, [r3, #0]
 80a4a40:	4b0a      	ldr	r3, [pc, #40]	; (80a4a6c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a4a42:	681a      	ldr	r2, [r3, #0]
 80a4a44:	07d2      	lsls	r2, r2, #31
 80a4a46:	bf5c      	itt	pl
 80a4a48:	2201      	movpl	r2, #1
 80a4a4a:	601a      	strpl	r2, [r3, #0]
 80a4a4c:	4770      	bx	lr
 80a4a4e:	bf00      	nop
 80a4a50:	200014bc 	.word	0x200014bc
 80a4a54:	200014b8 	.word	0x200014b8
 80a4a58:	200014b4 	.word	0x200014b4
 80a4a5c:	200014b0 	.word	0x200014b0
 80a4a60:	200014ac 	.word	0x200014ac
 80a4a64:	200014a8 	.word	0x200014a8
 80a4a68:	200014a4 	.word	0x200014a4
 80a4a6c:	200014a0 	.word	0x200014a0

080a4a70 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj>:
 80a4a70:	4b24      	ldr	r3, [pc, #144]	; (80a4b04 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x94>)
 80a4a72:	681a      	ldr	r2, [r3, #0]
 80a4a74:	07d0      	lsls	r0, r2, #31
 80a4a76:	bf5c      	itt	pl
 80a4a78:	2201      	movpl	r2, #1
 80a4a7a:	601a      	strpl	r2, [r3, #0]
 80a4a7c:	4b22      	ldr	r3, [pc, #136]	; (80a4b08 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x98>)
 80a4a7e:	681a      	ldr	r2, [r3, #0]
 80a4a80:	07d1      	lsls	r1, r2, #31
 80a4a82:	bf5c      	itt	pl
 80a4a84:	2201      	movpl	r2, #1
 80a4a86:	601a      	strpl	r2, [r3, #0]
 80a4a88:	4b20      	ldr	r3, [pc, #128]	; (80a4b0c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x9c>)
 80a4a8a:	681a      	ldr	r2, [r3, #0]
 80a4a8c:	07d2      	lsls	r2, r2, #31
 80a4a8e:	bf5c      	itt	pl
 80a4a90:	2201      	movpl	r2, #1
 80a4a92:	601a      	strpl	r2, [r3, #0]
 80a4a94:	4b1e      	ldr	r3, [pc, #120]	; (80a4b10 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa0>)
 80a4a96:	681a      	ldr	r2, [r3, #0]
 80a4a98:	07d0      	lsls	r0, r2, #31
 80a4a9a:	bf5c      	itt	pl
 80a4a9c:	2201      	movpl	r2, #1
 80a4a9e:	601a      	strpl	r2, [r3, #0]
 80a4aa0:	4b1c      	ldr	r3, [pc, #112]	; (80a4b14 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa4>)
 80a4aa2:	681a      	ldr	r2, [r3, #0]
 80a4aa4:	07d1      	lsls	r1, r2, #31
 80a4aa6:	bf5c      	itt	pl
 80a4aa8:	2201      	movpl	r2, #1
 80a4aaa:	601a      	strpl	r2, [r3, #0]
 80a4aac:	4b1a      	ldr	r3, [pc, #104]	; (80a4b18 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa8>)
 80a4aae:	681a      	ldr	r2, [r3, #0]
 80a4ab0:	07d2      	lsls	r2, r2, #31
 80a4ab2:	bf5c      	itt	pl
 80a4ab4:	2201      	movpl	r2, #1
 80a4ab6:	601a      	strpl	r2, [r3, #0]
 80a4ab8:	4b18      	ldr	r3, [pc, #96]	; (80a4b1c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xac>)
 80a4aba:	681a      	ldr	r2, [r3, #0]
 80a4abc:	07d0      	lsls	r0, r2, #31
 80a4abe:	bf5c      	itt	pl
 80a4ac0:	2201      	movpl	r2, #1
 80a4ac2:	601a      	strpl	r2, [r3, #0]
 80a4ac4:	4b16      	ldr	r3, [pc, #88]	; (80a4b20 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb0>)
 80a4ac6:	681a      	ldr	r2, [r3, #0]
 80a4ac8:	07d1      	lsls	r1, r2, #31
 80a4aca:	bf5c      	itt	pl
 80a4acc:	2201      	movpl	r2, #1
 80a4ace:	601a      	strpl	r2, [r3, #0]
 80a4ad0:	4b14      	ldr	r3, [pc, #80]	; (80a4b24 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb4>)
 80a4ad2:	681a      	ldr	r2, [r3, #0]
 80a4ad4:	07d2      	lsls	r2, r2, #31
 80a4ad6:	bf5c      	itt	pl
 80a4ad8:	2201      	movpl	r2, #1
 80a4ada:	601a      	strpl	r2, [r3, #0]
 80a4adc:	4b12      	ldr	r3, [pc, #72]	; (80a4b28 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb8>)
 80a4ade:	681a      	ldr	r2, [r3, #0]
 80a4ae0:	07d0      	lsls	r0, r2, #31
 80a4ae2:	bf5c      	itt	pl
 80a4ae4:	2201      	movpl	r2, #1
 80a4ae6:	601a      	strpl	r2, [r3, #0]
 80a4ae8:	4b10      	ldr	r3, [pc, #64]	; (80a4b2c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xbc>)
 80a4aea:	681a      	ldr	r2, [r3, #0]
 80a4aec:	07d1      	lsls	r1, r2, #31
 80a4aee:	bf5c      	itt	pl
 80a4af0:	2201      	movpl	r2, #1
 80a4af2:	601a      	strpl	r2, [r3, #0]
 80a4af4:	4b0e      	ldr	r3, [pc, #56]	; (80a4b30 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xc0>)
 80a4af6:	681a      	ldr	r2, [r3, #0]
 80a4af8:	07d2      	lsls	r2, r2, #31
 80a4afa:	bf5c      	itt	pl
 80a4afc:	2201      	movpl	r2, #1
 80a4afe:	601a      	strpl	r2, [r3, #0]
 80a4b00:	4770      	bx	lr
 80a4b02:	bf00      	nop
 80a4b04:	200014ec 	.word	0x200014ec
 80a4b08:	200014e8 	.word	0x200014e8
 80a4b0c:	200014e4 	.word	0x200014e4
 80a4b10:	200014e0 	.word	0x200014e0
 80a4b14:	200014dc 	.word	0x200014dc
 80a4b18:	200014d8 	.word	0x200014d8
 80a4b1c:	200014d4 	.word	0x200014d4
 80a4b20:	200014d0 	.word	0x200014d0
 80a4b24:	200014cc 	.word	0x200014cc
 80a4b28:	200014c8 	.word	0x200014c8
 80a4b2c:	200014c4 	.word	0x200014c4
 80a4b30:	200014c0 	.word	0x200014c0

080a4b34 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj>:
 80a4b34:	4b24      	ldr	r3, [pc, #144]	; (80a4bc8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x94>)
 80a4b36:	681a      	ldr	r2, [r3, #0]
 80a4b38:	07d0      	lsls	r0, r2, #31
 80a4b3a:	bf5c      	itt	pl
 80a4b3c:	2201      	movpl	r2, #1
 80a4b3e:	601a      	strpl	r2, [r3, #0]
 80a4b40:	4b22      	ldr	r3, [pc, #136]	; (80a4bcc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x98>)
 80a4b42:	681a      	ldr	r2, [r3, #0]
 80a4b44:	07d1      	lsls	r1, r2, #31
 80a4b46:	bf5c      	itt	pl
 80a4b48:	2201      	movpl	r2, #1
 80a4b4a:	601a      	strpl	r2, [r3, #0]
 80a4b4c:	4b20      	ldr	r3, [pc, #128]	; (80a4bd0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x9c>)
 80a4b4e:	681a      	ldr	r2, [r3, #0]
 80a4b50:	07d2      	lsls	r2, r2, #31
 80a4b52:	bf5c      	itt	pl
 80a4b54:	2201      	movpl	r2, #1
 80a4b56:	601a      	strpl	r2, [r3, #0]
 80a4b58:	4b1e      	ldr	r3, [pc, #120]	; (80a4bd4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa0>)
 80a4b5a:	681a      	ldr	r2, [r3, #0]
 80a4b5c:	07d0      	lsls	r0, r2, #31
 80a4b5e:	bf5c      	itt	pl
 80a4b60:	2201      	movpl	r2, #1
 80a4b62:	601a      	strpl	r2, [r3, #0]
 80a4b64:	4b1c      	ldr	r3, [pc, #112]	; (80a4bd8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa4>)
 80a4b66:	681a      	ldr	r2, [r3, #0]
 80a4b68:	07d1      	lsls	r1, r2, #31
 80a4b6a:	bf5c      	itt	pl
 80a4b6c:	2201      	movpl	r2, #1
 80a4b6e:	601a      	strpl	r2, [r3, #0]
 80a4b70:	4b1a      	ldr	r3, [pc, #104]	; (80a4bdc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa8>)
 80a4b72:	681a      	ldr	r2, [r3, #0]
 80a4b74:	07d2      	lsls	r2, r2, #31
 80a4b76:	bf5c      	itt	pl
 80a4b78:	2201      	movpl	r2, #1
 80a4b7a:	601a      	strpl	r2, [r3, #0]
 80a4b7c:	4b18      	ldr	r3, [pc, #96]	; (80a4be0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xac>)
 80a4b7e:	681a      	ldr	r2, [r3, #0]
 80a4b80:	07d0      	lsls	r0, r2, #31
 80a4b82:	bf5c      	itt	pl
 80a4b84:	2201      	movpl	r2, #1
 80a4b86:	601a      	strpl	r2, [r3, #0]
 80a4b88:	4b16      	ldr	r3, [pc, #88]	; (80a4be4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb0>)
 80a4b8a:	681a      	ldr	r2, [r3, #0]
 80a4b8c:	07d1      	lsls	r1, r2, #31
 80a4b8e:	bf5c      	itt	pl
 80a4b90:	2201      	movpl	r2, #1
 80a4b92:	601a      	strpl	r2, [r3, #0]
 80a4b94:	4b14      	ldr	r3, [pc, #80]	; (80a4be8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb4>)
 80a4b96:	681a      	ldr	r2, [r3, #0]
 80a4b98:	07d2      	lsls	r2, r2, #31
 80a4b9a:	bf5c      	itt	pl
 80a4b9c:	2201      	movpl	r2, #1
 80a4b9e:	601a      	strpl	r2, [r3, #0]
 80a4ba0:	4b12      	ldr	r3, [pc, #72]	; (80a4bec <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb8>)
 80a4ba2:	681a      	ldr	r2, [r3, #0]
 80a4ba4:	07d0      	lsls	r0, r2, #31
 80a4ba6:	bf5c      	itt	pl
 80a4ba8:	2201      	movpl	r2, #1
 80a4baa:	601a      	strpl	r2, [r3, #0]
 80a4bac:	4b10      	ldr	r3, [pc, #64]	; (80a4bf0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xbc>)
 80a4bae:	681a      	ldr	r2, [r3, #0]
 80a4bb0:	07d1      	lsls	r1, r2, #31
 80a4bb2:	bf5c      	itt	pl
 80a4bb4:	2201      	movpl	r2, #1
 80a4bb6:	601a      	strpl	r2, [r3, #0]
 80a4bb8:	4b0e      	ldr	r3, [pc, #56]	; (80a4bf4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xc0>)
 80a4bba:	681a      	ldr	r2, [r3, #0]
 80a4bbc:	07d2      	lsls	r2, r2, #31
 80a4bbe:	bf5c      	itt	pl
 80a4bc0:	2201      	movpl	r2, #1
 80a4bc2:	601a      	strpl	r2, [r3, #0]
 80a4bc4:	4770      	bx	lr
 80a4bc6:	bf00      	nop
 80a4bc8:	2000151c 	.word	0x2000151c
 80a4bcc:	20001518 	.word	0x20001518
 80a4bd0:	20001514 	.word	0x20001514
 80a4bd4:	20001510 	.word	0x20001510
 80a4bd8:	2000150c 	.word	0x2000150c
 80a4bdc:	20001508 	.word	0x20001508
 80a4be0:	20001504 	.word	0x20001504
 80a4be4:	20001500 	.word	0x20001500
 80a4be8:	200014fc 	.word	0x200014fc
 80a4bec:	200014f8 	.word	0x200014f8
 80a4bf0:	200014f4 	.word	0x200014f4
 80a4bf4:	200014f0 	.word	0x200014f0

080a4bf8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a4bf8:	4b18      	ldr	r3, [pc, #96]	; (80a4c5c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a4bfa:	681a      	ldr	r2, [r3, #0]
 80a4bfc:	07d1      	lsls	r1, r2, #31
 80a4bfe:	bf5c      	itt	pl
 80a4c00:	2201      	movpl	r2, #1
 80a4c02:	601a      	strpl	r2, [r3, #0]
 80a4c04:	4b16      	ldr	r3, [pc, #88]	; (80a4c60 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a4c06:	681a      	ldr	r2, [r3, #0]
 80a4c08:	07d2      	lsls	r2, r2, #31
 80a4c0a:	bf5c      	itt	pl
 80a4c0c:	2201      	movpl	r2, #1
 80a4c0e:	601a      	strpl	r2, [r3, #0]
 80a4c10:	4b14      	ldr	r3, [pc, #80]	; (80a4c64 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a4c12:	681a      	ldr	r2, [r3, #0]
 80a4c14:	07d0      	lsls	r0, r2, #31
 80a4c16:	bf5c      	itt	pl
 80a4c18:	2201      	movpl	r2, #1
 80a4c1a:	601a      	strpl	r2, [r3, #0]
 80a4c1c:	4b12      	ldr	r3, [pc, #72]	; (80a4c68 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a4c1e:	681a      	ldr	r2, [r3, #0]
 80a4c20:	07d1      	lsls	r1, r2, #31
 80a4c22:	bf5c      	itt	pl
 80a4c24:	2201      	movpl	r2, #1
 80a4c26:	601a      	strpl	r2, [r3, #0]
 80a4c28:	4b10      	ldr	r3, [pc, #64]	; (80a4c6c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a4c2a:	681a      	ldr	r2, [r3, #0]
 80a4c2c:	07d2      	lsls	r2, r2, #31
 80a4c2e:	bf5c      	itt	pl
 80a4c30:	2201      	movpl	r2, #1
 80a4c32:	601a      	strpl	r2, [r3, #0]
 80a4c34:	4b0e      	ldr	r3, [pc, #56]	; (80a4c70 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a4c36:	681a      	ldr	r2, [r3, #0]
 80a4c38:	07d0      	lsls	r0, r2, #31
 80a4c3a:	bf5c      	itt	pl
 80a4c3c:	2201      	movpl	r2, #1
 80a4c3e:	601a      	strpl	r2, [r3, #0]
 80a4c40:	4b0c      	ldr	r3, [pc, #48]	; (80a4c74 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a4c42:	681a      	ldr	r2, [r3, #0]
 80a4c44:	07d1      	lsls	r1, r2, #31
 80a4c46:	bf5c      	itt	pl
 80a4c48:	2201      	movpl	r2, #1
 80a4c4a:	601a      	strpl	r2, [r3, #0]
 80a4c4c:	4b0a      	ldr	r3, [pc, #40]	; (80a4c78 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a4c4e:	681a      	ldr	r2, [r3, #0]
 80a4c50:	07d2      	lsls	r2, r2, #31
 80a4c52:	bf5c      	itt	pl
 80a4c54:	2201      	movpl	r2, #1
 80a4c56:	601a      	strpl	r2, [r3, #0]
 80a4c58:	4770      	bx	lr
 80a4c5a:	bf00      	nop
 80a4c5c:	2000153c 	.word	0x2000153c
 80a4c60:	20001538 	.word	0x20001538
 80a4c64:	20001534 	.word	0x20001534
 80a4c68:	20001530 	.word	0x20001530
 80a4c6c:	2000152c 	.word	0x2000152c
 80a4c70:	20001528 	.word	0x20001528
 80a4c74:	20001524 	.word	0x20001524
 80a4c78:	20001520 	.word	0x20001520

080a4c7c <__aeabi_drsub>:
 80a4c7c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80a4c80:	e002      	b.n	80a4c88 <__adddf3>
 80a4c82:	bf00      	nop

080a4c84 <__aeabi_dsub>:
 80a4c84:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080a4c88 <__adddf3>:
 80a4c88:	b530      	push	{r4, r5, lr}
 80a4c8a:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80a4c8e:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80a4c92:	ea94 0f05 	teq	r4, r5
 80a4c96:	bf08      	it	eq
 80a4c98:	ea90 0f02 	teqeq	r0, r2
 80a4c9c:	bf1f      	itttt	ne
 80a4c9e:	ea54 0c00 	orrsne.w	ip, r4, r0
 80a4ca2:	ea55 0c02 	orrsne.w	ip, r5, r2
 80a4ca6:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80a4caa:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80a4cae:	f000 80e2 	beq.w	80a4e76 <__adddf3+0x1ee>
 80a4cb2:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80a4cb6:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80a4cba:	bfb8      	it	lt
 80a4cbc:	426d      	neglt	r5, r5
 80a4cbe:	dd0c      	ble.n	80a4cda <__adddf3+0x52>
 80a4cc0:	442c      	add	r4, r5
 80a4cc2:	ea80 0202 	eor.w	r2, r0, r2
 80a4cc6:	ea81 0303 	eor.w	r3, r1, r3
 80a4cca:	ea82 0000 	eor.w	r0, r2, r0
 80a4cce:	ea83 0101 	eor.w	r1, r3, r1
 80a4cd2:	ea80 0202 	eor.w	r2, r0, r2
 80a4cd6:	ea81 0303 	eor.w	r3, r1, r3
 80a4cda:	2d36      	cmp	r5, #54	; 0x36
 80a4cdc:	bf88      	it	hi
 80a4cde:	bd30      	pophi	{r4, r5, pc}
 80a4ce0:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a4ce4:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80a4ce8:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80a4cec:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80a4cf0:	d002      	beq.n	80a4cf8 <__adddf3+0x70>
 80a4cf2:	4240      	negs	r0, r0
 80a4cf4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a4cf8:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80a4cfc:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80a4d00:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80a4d04:	d002      	beq.n	80a4d0c <__adddf3+0x84>
 80a4d06:	4252      	negs	r2, r2
 80a4d08:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80a4d0c:	ea94 0f05 	teq	r4, r5
 80a4d10:	f000 80a7 	beq.w	80a4e62 <__adddf3+0x1da>
 80a4d14:	f1a4 0401 	sub.w	r4, r4, #1
 80a4d18:	f1d5 0e20 	rsbs	lr, r5, #32
 80a4d1c:	db0d      	blt.n	80a4d3a <__adddf3+0xb2>
 80a4d1e:	fa02 fc0e 	lsl.w	ip, r2, lr
 80a4d22:	fa22 f205 	lsr.w	r2, r2, r5
 80a4d26:	1880      	adds	r0, r0, r2
 80a4d28:	f141 0100 	adc.w	r1, r1, #0
 80a4d2c:	fa03 f20e 	lsl.w	r2, r3, lr
 80a4d30:	1880      	adds	r0, r0, r2
 80a4d32:	fa43 f305 	asr.w	r3, r3, r5
 80a4d36:	4159      	adcs	r1, r3
 80a4d38:	e00e      	b.n	80a4d58 <__adddf3+0xd0>
 80a4d3a:	f1a5 0520 	sub.w	r5, r5, #32
 80a4d3e:	f10e 0e20 	add.w	lr, lr, #32
 80a4d42:	2a01      	cmp	r2, #1
 80a4d44:	fa03 fc0e 	lsl.w	ip, r3, lr
 80a4d48:	bf28      	it	cs
 80a4d4a:	f04c 0c02 	orrcs.w	ip, ip, #2
 80a4d4e:	fa43 f305 	asr.w	r3, r3, r5
 80a4d52:	18c0      	adds	r0, r0, r3
 80a4d54:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80a4d58:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a4d5c:	d507      	bpl.n	80a4d6e <__adddf3+0xe6>
 80a4d5e:	f04f 0e00 	mov.w	lr, #0
 80a4d62:	f1dc 0c00 	rsbs	ip, ip, #0
 80a4d66:	eb7e 0000 	sbcs.w	r0, lr, r0
 80a4d6a:	eb6e 0101 	sbc.w	r1, lr, r1
 80a4d6e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80a4d72:	d31b      	bcc.n	80a4dac <__adddf3+0x124>
 80a4d74:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80a4d78:	d30c      	bcc.n	80a4d94 <__adddf3+0x10c>
 80a4d7a:	0849      	lsrs	r1, r1, #1
 80a4d7c:	ea5f 0030 	movs.w	r0, r0, rrx
 80a4d80:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80a4d84:	f104 0401 	add.w	r4, r4, #1
 80a4d88:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80a4d8c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80a4d90:	f080 809a 	bcs.w	80a4ec8 <__adddf3+0x240>
 80a4d94:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80a4d98:	bf08      	it	eq
 80a4d9a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80a4d9e:	f150 0000 	adcs.w	r0, r0, #0
 80a4da2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a4da6:	ea41 0105 	orr.w	r1, r1, r5
 80a4daa:	bd30      	pop	{r4, r5, pc}
 80a4dac:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80a4db0:	4140      	adcs	r0, r0
 80a4db2:	eb41 0101 	adc.w	r1, r1, r1
 80a4db6:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a4dba:	f1a4 0401 	sub.w	r4, r4, #1
 80a4dbe:	d1e9      	bne.n	80a4d94 <__adddf3+0x10c>
 80a4dc0:	f091 0f00 	teq	r1, #0
 80a4dc4:	bf04      	itt	eq
 80a4dc6:	4601      	moveq	r1, r0
 80a4dc8:	2000      	moveq	r0, #0
 80a4dca:	fab1 f381 	clz	r3, r1
 80a4dce:	bf08      	it	eq
 80a4dd0:	3320      	addeq	r3, #32
 80a4dd2:	f1a3 030b 	sub.w	r3, r3, #11
 80a4dd6:	f1b3 0220 	subs.w	r2, r3, #32
 80a4dda:	da0c      	bge.n	80a4df6 <__adddf3+0x16e>
 80a4ddc:	320c      	adds	r2, #12
 80a4dde:	dd08      	ble.n	80a4df2 <__adddf3+0x16a>
 80a4de0:	f102 0c14 	add.w	ip, r2, #20
 80a4de4:	f1c2 020c 	rsb	r2, r2, #12
 80a4de8:	fa01 f00c 	lsl.w	r0, r1, ip
 80a4dec:	fa21 f102 	lsr.w	r1, r1, r2
 80a4df0:	e00c      	b.n	80a4e0c <__adddf3+0x184>
 80a4df2:	f102 0214 	add.w	r2, r2, #20
 80a4df6:	bfd8      	it	le
 80a4df8:	f1c2 0c20 	rsble	ip, r2, #32
 80a4dfc:	fa01 f102 	lsl.w	r1, r1, r2
 80a4e00:	fa20 fc0c 	lsr.w	ip, r0, ip
 80a4e04:	bfdc      	itt	le
 80a4e06:	ea41 010c 	orrle.w	r1, r1, ip
 80a4e0a:	4090      	lslle	r0, r2
 80a4e0c:	1ae4      	subs	r4, r4, r3
 80a4e0e:	bfa2      	ittt	ge
 80a4e10:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80a4e14:	4329      	orrge	r1, r5
 80a4e16:	bd30      	popge	{r4, r5, pc}
 80a4e18:	ea6f 0404 	mvn.w	r4, r4
 80a4e1c:	3c1f      	subs	r4, #31
 80a4e1e:	da1c      	bge.n	80a4e5a <__adddf3+0x1d2>
 80a4e20:	340c      	adds	r4, #12
 80a4e22:	dc0e      	bgt.n	80a4e42 <__adddf3+0x1ba>
 80a4e24:	f104 0414 	add.w	r4, r4, #20
 80a4e28:	f1c4 0220 	rsb	r2, r4, #32
 80a4e2c:	fa20 f004 	lsr.w	r0, r0, r4
 80a4e30:	fa01 f302 	lsl.w	r3, r1, r2
 80a4e34:	ea40 0003 	orr.w	r0, r0, r3
 80a4e38:	fa21 f304 	lsr.w	r3, r1, r4
 80a4e3c:	ea45 0103 	orr.w	r1, r5, r3
 80a4e40:	bd30      	pop	{r4, r5, pc}
 80a4e42:	f1c4 040c 	rsb	r4, r4, #12
 80a4e46:	f1c4 0220 	rsb	r2, r4, #32
 80a4e4a:	fa20 f002 	lsr.w	r0, r0, r2
 80a4e4e:	fa01 f304 	lsl.w	r3, r1, r4
 80a4e52:	ea40 0003 	orr.w	r0, r0, r3
 80a4e56:	4629      	mov	r1, r5
 80a4e58:	bd30      	pop	{r4, r5, pc}
 80a4e5a:	fa21 f004 	lsr.w	r0, r1, r4
 80a4e5e:	4629      	mov	r1, r5
 80a4e60:	bd30      	pop	{r4, r5, pc}
 80a4e62:	f094 0f00 	teq	r4, #0
 80a4e66:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80a4e6a:	bf06      	itte	eq
 80a4e6c:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80a4e70:	3401      	addeq	r4, #1
 80a4e72:	3d01      	subne	r5, #1
 80a4e74:	e74e      	b.n	80a4d14 <__adddf3+0x8c>
 80a4e76:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80a4e7a:	bf18      	it	ne
 80a4e7c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80a4e80:	d029      	beq.n	80a4ed6 <__adddf3+0x24e>
 80a4e82:	ea94 0f05 	teq	r4, r5
 80a4e86:	bf08      	it	eq
 80a4e88:	ea90 0f02 	teqeq	r0, r2
 80a4e8c:	d005      	beq.n	80a4e9a <__adddf3+0x212>
 80a4e8e:	ea54 0c00 	orrs.w	ip, r4, r0
 80a4e92:	bf04      	itt	eq
 80a4e94:	4619      	moveq	r1, r3
 80a4e96:	4610      	moveq	r0, r2
 80a4e98:	bd30      	pop	{r4, r5, pc}
 80a4e9a:	ea91 0f03 	teq	r1, r3
 80a4e9e:	bf1e      	ittt	ne
 80a4ea0:	2100      	movne	r1, #0
 80a4ea2:	2000      	movne	r0, #0
 80a4ea4:	bd30      	popne	{r4, r5, pc}
 80a4ea6:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80a4eaa:	d105      	bne.n	80a4eb8 <__adddf3+0x230>
 80a4eac:	0040      	lsls	r0, r0, #1
 80a4eae:	4149      	adcs	r1, r1
 80a4eb0:	bf28      	it	cs
 80a4eb2:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80a4eb6:	bd30      	pop	{r4, r5, pc}
 80a4eb8:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80a4ebc:	bf3c      	itt	cc
 80a4ebe:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80a4ec2:	bd30      	popcc	{r4, r5, pc}
 80a4ec4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a4ec8:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80a4ecc:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80a4ed0:	f04f 0000 	mov.w	r0, #0
 80a4ed4:	bd30      	pop	{r4, r5, pc}
 80a4ed6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80a4eda:	bf1a      	itte	ne
 80a4edc:	4619      	movne	r1, r3
 80a4ede:	4610      	movne	r0, r2
 80a4ee0:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80a4ee4:	bf1c      	itt	ne
 80a4ee6:	460b      	movne	r3, r1
 80a4ee8:	4602      	movne	r2, r0
 80a4eea:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80a4eee:	bf06      	itte	eq
 80a4ef0:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80a4ef4:	ea91 0f03 	teqeq	r1, r3
 80a4ef8:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80a4efc:	bd30      	pop	{r4, r5, pc}
 80a4efe:	bf00      	nop

080a4f00 <__aeabi_ui2d>:
 80a4f00:	f090 0f00 	teq	r0, #0
 80a4f04:	bf04      	itt	eq
 80a4f06:	2100      	moveq	r1, #0
 80a4f08:	4770      	bxeq	lr
 80a4f0a:	b530      	push	{r4, r5, lr}
 80a4f0c:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a4f10:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a4f14:	f04f 0500 	mov.w	r5, #0
 80a4f18:	f04f 0100 	mov.w	r1, #0
 80a4f1c:	e750      	b.n	80a4dc0 <__adddf3+0x138>
 80a4f1e:	bf00      	nop

080a4f20 <__aeabi_i2d>:
 80a4f20:	f090 0f00 	teq	r0, #0
 80a4f24:	bf04      	itt	eq
 80a4f26:	2100      	moveq	r1, #0
 80a4f28:	4770      	bxeq	lr
 80a4f2a:	b530      	push	{r4, r5, lr}
 80a4f2c:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a4f30:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a4f34:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80a4f38:	bf48      	it	mi
 80a4f3a:	4240      	negmi	r0, r0
 80a4f3c:	f04f 0100 	mov.w	r1, #0
 80a4f40:	e73e      	b.n	80a4dc0 <__adddf3+0x138>
 80a4f42:	bf00      	nop

080a4f44 <__aeabi_f2d>:
 80a4f44:	0042      	lsls	r2, r0, #1
 80a4f46:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80a4f4a:	ea4f 0131 	mov.w	r1, r1, rrx
 80a4f4e:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80a4f52:	bf1f      	itttt	ne
 80a4f54:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80a4f58:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80a4f5c:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80a4f60:	4770      	bxne	lr
 80a4f62:	f092 0f00 	teq	r2, #0
 80a4f66:	bf14      	ite	ne
 80a4f68:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80a4f6c:	4770      	bxeq	lr
 80a4f6e:	b530      	push	{r4, r5, lr}
 80a4f70:	f44f 7460 	mov.w	r4, #896	; 0x380
 80a4f74:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a4f78:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a4f7c:	e720      	b.n	80a4dc0 <__adddf3+0x138>
 80a4f7e:	bf00      	nop

080a4f80 <__aeabi_ul2d>:
 80a4f80:	ea50 0201 	orrs.w	r2, r0, r1
 80a4f84:	bf08      	it	eq
 80a4f86:	4770      	bxeq	lr
 80a4f88:	b530      	push	{r4, r5, lr}
 80a4f8a:	f04f 0500 	mov.w	r5, #0
 80a4f8e:	e00a      	b.n	80a4fa6 <__aeabi_l2d+0x16>

080a4f90 <__aeabi_l2d>:
 80a4f90:	ea50 0201 	orrs.w	r2, r0, r1
 80a4f94:	bf08      	it	eq
 80a4f96:	4770      	bxeq	lr
 80a4f98:	b530      	push	{r4, r5, lr}
 80a4f9a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80a4f9e:	d502      	bpl.n	80a4fa6 <__aeabi_l2d+0x16>
 80a4fa0:	4240      	negs	r0, r0
 80a4fa2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a4fa6:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a4faa:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a4fae:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80a4fb2:	f43f aedc 	beq.w	80a4d6e <__adddf3+0xe6>
 80a4fb6:	f04f 0203 	mov.w	r2, #3
 80a4fba:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80a4fbe:	bf18      	it	ne
 80a4fc0:	3203      	addne	r2, #3
 80a4fc2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80a4fc6:	bf18      	it	ne
 80a4fc8:	3203      	addne	r2, #3
 80a4fca:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80a4fce:	f1c2 0320 	rsb	r3, r2, #32
 80a4fd2:	fa00 fc03 	lsl.w	ip, r0, r3
 80a4fd6:	fa20 f002 	lsr.w	r0, r0, r2
 80a4fda:	fa01 fe03 	lsl.w	lr, r1, r3
 80a4fde:	ea40 000e 	orr.w	r0, r0, lr
 80a4fe2:	fa21 f102 	lsr.w	r1, r1, r2
 80a4fe6:	4414      	add	r4, r2
 80a4fe8:	e6c1      	b.n	80a4d6e <__adddf3+0xe6>
 80a4fea:	bf00      	nop

080a4fec <__aeabi_dmul>:
 80a4fec:	b570      	push	{r4, r5, r6, lr}
 80a4fee:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a4ff2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80a4ff6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80a4ffa:	bf1d      	ittte	ne
 80a4ffc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80a5000:	ea94 0f0c 	teqne	r4, ip
 80a5004:	ea95 0f0c 	teqne	r5, ip
 80a5008:	f000 f8de 	bleq	80a51c8 <__aeabi_dmul+0x1dc>
 80a500c:	442c      	add	r4, r5
 80a500e:	ea81 0603 	eor.w	r6, r1, r3
 80a5012:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80a5016:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80a501a:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80a501e:	bf18      	it	ne
 80a5020:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80a5024:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a5028:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80a502c:	d038      	beq.n	80a50a0 <__aeabi_dmul+0xb4>
 80a502e:	fba0 ce02 	umull	ip, lr, r0, r2
 80a5032:	f04f 0500 	mov.w	r5, #0
 80a5036:	fbe1 e502 	umlal	lr, r5, r1, r2
 80a503a:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80a503e:	fbe0 e503 	umlal	lr, r5, r0, r3
 80a5042:	f04f 0600 	mov.w	r6, #0
 80a5046:	fbe1 5603 	umlal	r5, r6, r1, r3
 80a504a:	f09c 0f00 	teq	ip, #0
 80a504e:	bf18      	it	ne
 80a5050:	f04e 0e01 	orrne.w	lr, lr, #1
 80a5054:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80a5058:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80a505c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80a5060:	d204      	bcs.n	80a506c <__aeabi_dmul+0x80>
 80a5062:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80a5066:	416d      	adcs	r5, r5
 80a5068:	eb46 0606 	adc.w	r6, r6, r6
 80a506c:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80a5070:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80a5074:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80a5078:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80a507c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80a5080:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80a5084:	bf88      	it	hi
 80a5086:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80a508a:	d81e      	bhi.n	80a50ca <__aeabi_dmul+0xde>
 80a508c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80a5090:	bf08      	it	eq
 80a5092:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80a5096:	f150 0000 	adcs.w	r0, r0, #0
 80a509a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a509e:	bd70      	pop	{r4, r5, r6, pc}
 80a50a0:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80a50a4:	ea46 0101 	orr.w	r1, r6, r1
 80a50a8:	ea40 0002 	orr.w	r0, r0, r2
 80a50ac:	ea81 0103 	eor.w	r1, r1, r3
 80a50b0:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80a50b4:	bfc2      	ittt	gt
 80a50b6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80a50ba:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80a50be:	bd70      	popgt	{r4, r5, r6, pc}
 80a50c0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a50c4:	f04f 0e00 	mov.w	lr, #0
 80a50c8:	3c01      	subs	r4, #1
 80a50ca:	f300 80ab 	bgt.w	80a5224 <__aeabi_dmul+0x238>
 80a50ce:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80a50d2:	bfde      	ittt	le
 80a50d4:	2000      	movle	r0, #0
 80a50d6:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80a50da:	bd70      	pople	{r4, r5, r6, pc}
 80a50dc:	f1c4 0400 	rsb	r4, r4, #0
 80a50e0:	3c20      	subs	r4, #32
 80a50e2:	da35      	bge.n	80a5150 <__aeabi_dmul+0x164>
 80a50e4:	340c      	adds	r4, #12
 80a50e6:	dc1b      	bgt.n	80a5120 <__aeabi_dmul+0x134>
 80a50e8:	f104 0414 	add.w	r4, r4, #20
 80a50ec:	f1c4 0520 	rsb	r5, r4, #32
 80a50f0:	fa00 f305 	lsl.w	r3, r0, r5
 80a50f4:	fa20 f004 	lsr.w	r0, r0, r4
 80a50f8:	fa01 f205 	lsl.w	r2, r1, r5
 80a50fc:	ea40 0002 	orr.w	r0, r0, r2
 80a5100:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 80a5104:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a5108:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80a510c:	fa21 f604 	lsr.w	r6, r1, r4
 80a5110:	eb42 0106 	adc.w	r1, r2, r6
 80a5114:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a5118:	bf08      	it	eq
 80a511a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a511e:	bd70      	pop	{r4, r5, r6, pc}
 80a5120:	f1c4 040c 	rsb	r4, r4, #12
 80a5124:	f1c4 0520 	rsb	r5, r4, #32
 80a5128:	fa00 f304 	lsl.w	r3, r0, r4
 80a512c:	fa20 f005 	lsr.w	r0, r0, r5
 80a5130:	fa01 f204 	lsl.w	r2, r1, r4
 80a5134:	ea40 0002 	orr.w	r0, r0, r2
 80a5138:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a513c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80a5140:	f141 0100 	adc.w	r1, r1, #0
 80a5144:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a5148:	bf08      	it	eq
 80a514a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a514e:	bd70      	pop	{r4, r5, r6, pc}
 80a5150:	f1c4 0520 	rsb	r5, r4, #32
 80a5154:	fa00 f205 	lsl.w	r2, r0, r5
 80a5158:	ea4e 0e02 	orr.w	lr, lr, r2
 80a515c:	fa20 f304 	lsr.w	r3, r0, r4
 80a5160:	fa01 f205 	lsl.w	r2, r1, r5
 80a5164:	ea43 0302 	orr.w	r3, r3, r2
 80a5168:	fa21 f004 	lsr.w	r0, r1, r4
 80a516c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a5170:	fa21 f204 	lsr.w	r2, r1, r4
 80a5174:	ea20 0002 	bic.w	r0, r0, r2
 80a5178:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80a517c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a5180:	bf08      	it	eq
 80a5182:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a5186:	bd70      	pop	{r4, r5, r6, pc}
 80a5188:	f094 0f00 	teq	r4, #0
 80a518c:	d10f      	bne.n	80a51ae <__aeabi_dmul+0x1c2>
 80a518e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80a5192:	0040      	lsls	r0, r0, #1
 80a5194:	eb41 0101 	adc.w	r1, r1, r1
 80a5198:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a519c:	bf08      	it	eq
 80a519e:	3c01      	subeq	r4, #1
 80a51a0:	d0f7      	beq.n	80a5192 <__aeabi_dmul+0x1a6>
 80a51a2:	ea41 0106 	orr.w	r1, r1, r6
 80a51a6:	f095 0f00 	teq	r5, #0
 80a51aa:	bf18      	it	ne
 80a51ac:	4770      	bxne	lr
 80a51ae:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80a51b2:	0052      	lsls	r2, r2, #1
 80a51b4:	eb43 0303 	adc.w	r3, r3, r3
 80a51b8:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80a51bc:	bf08      	it	eq
 80a51be:	3d01      	subeq	r5, #1
 80a51c0:	d0f7      	beq.n	80a51b2 <__aeabi_dmul+0x1c6>
 80a51c2:	ea43 0306 	orr.w	r3, r3, r6
 80a51c6:	4770      	bx	lr
 80a51c8:	ea94 0f0c 	teq	r4, ip
 80a51cc:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80a51d0:	bf18      	it	ne
 80a51d2:	ea95 0f0c 	teqne	r5, ip
 80a51d6:	d00c      	beq.n	80a51f2 <__aeabi_dmul+0x206>
 80a51d8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a51dc:	bf18      	it	ne
 80a51de:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a51e2:	d1d1      	bne.n	80a5188 <__aeabi_dmul+0x19c>
 80a51e4:	ea81 0103 	eor.w	r1, r1, r3
 80a51e8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a51ec:	f04f 0000 	mov.w	r0, #0
 80a51f0:	bd70      	pop	{r4, r5, r6, pc}
 80a51f2:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a51f6:	bf06      	itte	eq
 80a51f8:	4610      	moveq	r0, r2
 80a51fa:	4619      	moveq	r1, r3
 80a51fc:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a5200:	d019      	beq.n	80a5236 <__aeabi_dmul+0x24a>
 80a5202:	ea94 0f0c 	teq	r4, ip
 80a5206:	d102      	bne.n	80a520e <__aeabi_dmul+0x222>
 80a5208:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80a520c:	d113      	bne.n	80a5236 <__aeabi_dmul+0x24a>
 80a520e:	ea95 0f0c 	teq	r5, ip
 80a5212:	d105      	bne.n	80a5220 <__aeabi_dmul+0x234>
 80a5214:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80a5218:	bf1c      	itt	ne
 80a521a:	4610      	movne	r0, r2
 80a521c:	4619      	movne	r1, r3
 80a521e:	d10a      	bne.n	80a5236 <__aeabi_dmul+0x24a>
 80a5220:	ea81 0103 	eor.w	r1, r1, r3
 80a5224:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a5228:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80a522c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80a5230:	f04f 0000 	mov.w	r0, #0
 80a5234:	bd70      	pop	{r4, r5, r6, pc}
 80a5236:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80a523a:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80a523e:	bd70      	pop	{r4, r5, r6, pc}

080a5240 <__aeabi_ddiv>:
 80a5240:	b570      	push	{r4, r5, r6, lr}
 80a5242:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a5246:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80a524a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80a524e:	bf1d      	ittte	ne
 80a5250:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80a5254:	ea94 0f0c 	teqne	r4, ip
 80a5258:	ea95 0f0c 	teqne	r5, ip
 80a525c:	f000 f8a7 	bleq	80a53ae <__aeabi_ddiv+0x16e>
 80a5260:	eba4 0405 	sub.w	r4, r4, r5
 80a5264:	ea81 0e03 	eor.w	lr, r1, r3
 80a5268:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80a526c:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80a5270:	f000 8088 	beq.w	80a5384 <__aeabi_ddiv+0x144>
 80a5274:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80a5278:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80a527c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80a5280:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80a5284:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80a5288:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80a528c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80a5290:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80a5294:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80a5298:	429d      	cmp	r5, r3
 80a529a:	bf08      	it	eq
 80a529c:	4296      	cmpeq	r6, r2
 80a529e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80a52a2:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80a52a6:	d202      	bcs.n	80a52ae <__aeabi_ddiv+0x6e>
 80a52a8:	085b      	lsrs	r3, r3, #1
 80a52aa:	ea4f 0232 	mov.w	r2, r2, rrx
 80a52ae:	1ab6      	subs	r6, r6, r2
 80a52b0:	eb65 0503 	sbc.w	r5, r5, r3
 80a52b4:	085b      	lsrs	r3, r3, #1
 80a52b6:	ea4f 0232 	mov.w	r2, r2, rrx
 80a52ba:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80a52be:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80a52c2:	ebb6 0e02 	subs.w	lr, r6, r2
 80a52c6:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a52ca:	bf22      	ittt	cs
 80a52cc:	1ab6      	subcs	r6, r6, r2
 80a52ce:	4675      	movcs	r5, lr
 80a52d0:	ea40 000c 	orrcs.w	r0, r0, ip
 80a52d4:	085b      	lsrs	r3, r3, #1
 80a52d6:	ea4f 0232 	mov.w	r2, r2, rrx
 80a52da:	ebb6 0e02 	subs.w	lr, r6, r2
 80a52de:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a52e2:	bf22      	ittt	cs
 80a52e4:	1ab6      	subcs	r6, r6, r2
 80a52e6:	4675      	movcs	r5, lr
 80a52e8:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80a52ec:	085b      	lsrs	r3, r3, #1
 80a52ee:	ea4f 0232 	mov.w	r2, r2, rrx
 80a52f2:	ebb6 0e02 	subs.w	lr, r6, r2
 80a52f6:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a52fa:	bf22      	ittt	cs
 80a52fc:	1ab6      	subcs	r6, r6, r2
 80a52fe:	4675      	movcs	r5, lr
 80a5300:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80a5304:	085b      	lsrs	r3, r3, #1
 80a5306:	ea4f 0232 	mov.w	r2, r2, rrx
 80a530a:	ebb6 0e02 	subs.w	lr, r6, r2
 80a530e:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a5312:	bf22      	ittt	cs
 80a5314:	1ab6      	subcs	r6, r6, r2
 80a5316:	4675      	movcs	r5, lr
 80a5318:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80a531c:	ea55 0e06 	orrs.w	lr, r5, r6
 80a5320:	d018      	beq.n	80a5354 <__aeabi_ddiv+0x114>
 80a5322:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80a5326:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80a532a:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80a532e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80a5332:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80a5336:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80a533a:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80a533e:	d1c0      	bne.n	80a52c2 <__aeabi_ddiv+0x82>
 80a5340:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a5344:	d10b      	bne.n	80a535e <__aeabi_ddiv+0x11e>
 80a5346:	ea41 0100 	orr.w	r1, r1, r0
 80a534a:	f04f 0000 	mov.w	r0, #0
 80a534e:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80a5352:	e7b6      	b.n	80a52c2 <__aeabi_ddiv+0x82>
 80a5354:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a5358:	bf04      	itt	eq
 80a535a:	4301      	orreq	r1, r0
 80a535c:	2000      	moveq	r0, #0
 80a535e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80a5362:	bf88      	it	hi
 80a5364:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80a5368:	f63f aeaf 	bhi.w	80a50ca <__aeabi_dmul+0xde>
 80a536c:	ebb5 0c03 	subs.w	ip, r5, r3
 80a5370:	bf04      	itt	eq
 80a5372:	ebb6 0c02 	subseq.w	ip, r6, r2
 80a5376:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80a537a:	f150 0000 	adcs.w	r0, r0, #0
 80a537e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a5382:	bd70      	pop	{r4, r5, r6, pc}
 80a5384:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80a5388:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80a538c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80a5390:	bfc2      	ittt	gt
 80a5392:	ebd4 050c 	rsbsgt	r5, r4, ip
 80a5396:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80a539a:	bd70      	popgt	{r4, r5, r6, pc}
 80a539c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a53a0:	f04f 0e00 	mov.w	lr, #0
 80a53a4:	3c01      	subs	r4, #1
 80a53a6:	e690      	b.n	80a50ca <__aeabi_dmul+0xde>
 80a53a8:	ea45 0e06 	orr.w	lr, r5, r6
 80a53ac:	e68d      	b.n	80a50ca <__aeabi_dmul+0xde>
 80a53ae:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80a53b2:	ea94 0f0c 	teq	r4, ip
 80a53b6:	bf08      	it	eq
 80a53b8:	ea95 0f0c 	teqeq	r5, ip
 80a53bc:	f43f af3b 	beq.w	80a5236 <__aeabi_dmul+0x24a>
 80a53c0:	ea94 0f0c 	teq	r4, ip
 80a53c4:	d10a      	bne.n	80a53dc <__aeabi_ddiv+0x19c>
 80a53c6:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80a53ca:	f47f af34 	bne.w	80a5236 <__aeabi_dmul+0x24a>
 80a53ce:	ea95 0f0c 	teq	r5, ip
 80a53d2:	f47f af25 	bne.w	80a5220 <__aeabi_dmul+0x234>
 80a53d6:	4610      	mov	r0, r2
 80a53d8:	4619      	mov	r1, r3
 80a53da:	e72c      	b.n	80a5236 <__aeabi_dmul+0x24a>
 80a53dc:	ea95 0f0c 	teq	r5, ip
 80a53e0:	d106      	bne.n	80a53f0 <__aeabi_ddiv+0x1b0>
 80a53e2:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80a53e6:	f43f aefd 	beq.w	80a51e4 <__aeabi_dmul+0x1f8>
 80a53ea:	4610      	mov	r0, r2
 80a53ec:	4619      	mov	r1, r3
 80a53ee:	e722      	b.n	80a5236 <__aeabi_dmul+0x24a>
 80a53f0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a53f4:	bf18      	it	ne
 80a53f6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a53fa:	f47f aec5 	bne.w	80a5188 <__aeabi_dmul+0x19c>
 80a53fe:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80a5402:	f47f af0d 	bne.w	80a5220 <__aeabi_dmul+0x234>
 80a5406:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80a540a:	f47f aeeb 	bne.w	80a51e4 <__aeabi_dmul+0x1f8>
 80a540e:	e712      	b.n	80a5236 <__aeabi_dmul+0x24a>

080a5410 <__aeabi_d2iz>:
 80a5410:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80a5414:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80a5418:	d215      	bcs.n	80a5446 <__aeabi_d2iz+0x36>
 80a541a:	d511      	bpl.n	80a5440 <__aeabi_d2iz+0x30>
 80a541c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80a5420:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80a5424:	d912      	bls.n	80a544c <__aeabi_d2iz+0x3c>
 80a5426:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a542a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a542e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80a5432:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a5436:	fa23 f002 	lsr.w	r0, r3, r2
 80a543a:	bf18      	it	ne
 80a543c:	4240      	negne	r0, r0
 80a543e:	4770      	bx	lr
 80a5440:	f04f 0000 	mov.w	r0, #0
 80a5444:	4770      	bx	lr
 80a5446:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80a544a:	d105      	bne.n	80a5458 <__aeabi_d2iz+0x48>
 80a544c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 80a5450:	bf08      	it	eq
 80a5452:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a5456:	4770      	bx	lr
 80a5458:	f04f 0000 	mov.w	r0, #0
 80a545c:	4770      	bx	lr
 80a545e:	bf00      	nop

080a5460 <__aeabi_d2uiz>:
 80a5460:	004a      	lsls	r2, r1, #1
 80a5462:	d211      	bcs.n	80a5488 <__aeabi_d2uiz+0x28>
 80a5464:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80a5468:	d211      	bcs.n	80a548e <__aeabi_d2uiz+0x2e>
 80a546a:	d50d      	bpl.n	80a5488 <__aeabi_d2uiz+0x28>
 80a546c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80a5470:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80a5474:	d40e      	bmi.n	80a5494 <__aeabi_d2uiz+0x34>
 80a5476:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a547a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a547e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80a5482:	fa23 f002 	lsr.w	r0, r3, r2
 80a5486:	4770      	bx	lr
 80a5488:	f04f 0000 	mov.w	r0, #0
 80a548c:	4770      	bx	lr
 80a548e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80a5492:	d102      	bne.n	80a549a <__aeabi_d2uiz+0x3a>
 80a5494:	f04f 30ff 	mov.w	r0, #4294967295
 80a5498:	4770      	bx	lr
 80a549a:	f04f 0000 	mov.w	r0, #0
 80a549e:	4770      	bx	lr

080a54a0 <__aeabi_d2f>:
 80a54a0:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80a54a4:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 80a54a8:	bf24      	itt	cs
 80a54aa:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 80a54ae:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 80a54b2:	d90d      	bls.n	80a54d0 <__aeabi_d2f+0x30>
 80a54b4:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a54b8:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 80a54bc:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 80a54c0:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 80a54c4:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 80a54c8:	bf08      	it	eq
 80a54ca:	f020 0001 	biceq.w	r0, r0, #1
 80a54ce:	4770      	bx	lr
 80a54d0:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 80a54d4:	d121      	bne.n	80a551a <__aeabi_d2f+0x7a>
 80a54d6:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 80a54da:	bfbc      	itt	lt
 80a54dc:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 80a54e0:	4770      	bxlt	lr
 80a54e2:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a54e6:	ea4f 5252 	mov.w	r2, r2, lsr #21
 80a54ea:	f1c2 0218 	rsb	r2, r2, #24
 80a54ee:	f1c2 0c20 	rsb	ip, r2, #32
 80a54f2:	fa10 f30c 	lsls.w	r3, r0, ip
 80a54f6:	fa20 f002 	lsr.w	r0, r0, r2
 80a54fa:	bf18      	it	ne
 80a54fc:	f040 0001 	orrne.w	r0, r0, #1
 80a5500:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a5504:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 80a5508:	fa03 fc0c 	lsl.w	ip, r3, ip
 80a550c:	ea40 000c 	orr.w	r0, r0, ip
 80a5510:	fa23 f302 	lsr.w	r3, r3, r2
 80a5514:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80a5518:	e7cc      	b.n	80a54b4 <__aeabi_d2f+0x14>
 80a551a:	ea7f 5362 	mvns.w	r3, r2, asr #21
 80a551e:	d107      	bne.n	80a5530 <__aeabi_d2f+0x90>
 80a5520:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 80a5524:	bf1e      	ittt	ne
 80a5526:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 80a552a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 80a552e:	4770      	bxne	lr
 80a5530:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 80a5534:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a5538:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a553c:	4770      	bx	lr
 80a553e:	bf00      	nop

080a5540 <__aeabi_frsub>:
 80a5540:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 80a5544:	e002      	b.n	80a554c <__addsf3>
 80a5546:	bf00      	nop

080a5548 <__aeabi_fsub>:
 80a5548:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

080a554c <__addsf3>:
 80a554c:	0042      	lsls	r2, r0, #1
 80a554e:	bf1f      	itttt	ne
 80a5550:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 80a5554:	ea92 0f03 	teqne	r2, r3
 80a5558:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 80a555c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a5560:	d06a      	beq.n	80a5638 <__addsf3+0xec>
 80a5562:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80a5566:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 80a556a:	bfc1      	itttt	gt
 80a556c:	18d2      	addgt	r2, r2, r3
 80a556e:	4041      	eorgt	r1, r0
 80a5570:	4048      	eorgt	r0, r1
 80a5572:	4041      	eorgt	r1, r0
 80a5574:	bfb8      	it	lt
 80a5576:	425b      	neglt	r3, r3
 80a5578:	2b19      	cmp	r3, #25
 80a557a:	bf88      	it	hi
 80a557c:	4770      	bxhi	lr
 80a557e:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80a5582:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a5586:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 80a558a:	bf18      	it	ne
 80a558c:	4240      	negne	r0, r0
 80a558e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a5592:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 80a5596:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 80a559a:	bf18      	it	ne
 80a559c:	4249      	negne	r1, r1
 80a559e:	ea92 0f03 	teq	r2, r3
 80a55a2:	d03f      	beq.n	80a5624 <__addsf3+0xd8>
 80a55a4:	f1a2 0201 	sub.w	r2, r2, #1
 80a55a8:	fa41 fc03 	asr.w	ip, r1, r3
 80a55ac:	eb10 000c 	adds.w	r0, r0, ip
 80a55b0:	f1c3 0320 	rsb	r3, r3, #32
 80a55b4:	fa01 f103 	lsl.w	r1, r1, r3
 80a55b8:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80a55bc:	d502      	bpl.n	80a55c4 <__addsf3+0x78>
 80a55be:	4249      	negs	r1, r1
 80a55c0:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 80a55c4:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 80a55c8:	d313      	bcc.n	80a55f2 <__addsf3+0xa6>
 80a55ca:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80a55ce:	d306      	bcc.n	80a55de <__addsf3+0x92>
 80a55d0:	0840      	lsrs	r0, r0, #1
 80a55d2:	ea4f 0131 	mov.w	r1, r1, rrx
 80a55d6:	f102 0201 	add.w	r2, r2, #1
 80a55da:	2afe      	cmp	r2, #254	; 0xfe
 80a55dc:	d251      	bcs.n	80a5682 <__addsf3+0x136>
 80a55de:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 80a55e2:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a55e6:	bf08      	it	eq
 80a55e8:	f020 0001 	biceq.w	r0, r0, #1
 80a55ec:	ea40 0003 	orr.w	r0, r0, r3
 80a55f0:	4770      	bx	lr
 80a55f2:	0049      	lsls	r1, r1, #1
 80a55f4:	eb40 0000 	adc.w	r0, r0, r0
 80a55f8:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 80a55fc:	f1a2 0201 	sub.w	r2, r2, #1
 80a5600:	d1ed      	bne.n	80a55de <__addsf3+0x92>
 80a5602:	fab0 fc80 	clz	ip, r0
 80a5606:	f1ac 0c08 	sub.w	ip, ip, #8
 80a560a:	ebb2 020c 	subs.w	r2, r2, ip
 80a560e:	fa00 f00c 	lsl.w	r0, r0, ip
 80a5612:	bfaa      	itet	ge
 80a5614:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 80a5618:	4252      	neglt	r2, r2
 80a561a:	4318      	orrge	r0, r3
 80a561c:	bfbc      	itt	lt
 80a561e:	40d0      	lsrlt	r0, r2
 80a5620:	4318      	orrlt	r0, r3
 80a5622:	4770      	bx	lr
 80a5624:	f092 0f00 	teq	r2, #0
 80a5628:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 80a562c:	bf06      	itte	eq
 80a562e:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 80a5632:	3201      	addeq	r2, #1
 80a5634:	3b01      	subne	r3, #1
 80a5636:	e7b5      	b.n	80a55a4 <__addsf3+0x58>
 80a5638:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80a563c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a5640:	bf18      	it	ne
 80a5642:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a5646:	d021      	beq.n	80a568c <__addsf3+0x140>
 80a5648:	ea92 0f03 	teq	r2, r3
 80a564c:	d004      	beq.n	80a5658 <__addsf3+0x10c>
 80a564e:	f092 0f00 	teq	r2, #0
 80a5652:	bf08      	it	eq
 80a5654:	4608      	moveq	r0, r1
 80a5656:	4770      	bx	lr
 80a5658:	ea90 0f01 	teq	r0, r1
 80a565c:	bf1c      	itt	ne
 80a565e:	2000      	movne	r0, #0
 80a5660:	4770      	bxne	lr
 80a5662:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 80a5666:	d104      	bne.n	80a5672 <__addsf3+0x126>
 80a5668:	0040      	lsls	r0, r0, #1
 80a566a:	bf28      	it	cs
 80a566c:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 80a5670:	4770      	bx	lr
 80a5672:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 80a5676:	bf3c      	itt	cc
 80a5678:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 80a567c:	4770      	bxcc	lr
 80a567e:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80a5682:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 80a5686:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a568a:	4770      	bx	lr
 80a568c:	ea7f 6222 	mvns.w	r2, r2, asr #24
 80a5690:	bf16      	itet	ne
 80a5692:	4608      	movne	r0, r1
 80a5694:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 80a5698:	4601      	movne	r1, r0
 80a569a:	0242      	lsls	r2, r0, #9
 80a569c:	bf06      	itte	eq
 80a569e:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 80a56a2:	ea90 0f01 	teqeq	r0, r1
 80a56a6:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 80a56aa:	4770      	bx	lr

080a56ac <__aeabi_ui2f>:
 80a56ac:	f04f 0300 	mov.w	r3, #0
 80a56b0:	e004      	b.n	80a56bc <__aeabi_i2f+0x8>
 80a56b2:	bf00      	nop

080a56b4 <__aeabi_i2f>:
 80a56b4:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 80a56b8:	bf48      	it	mi
 80a56ba:	4240      	negmi	r0, r0
 80a56bc:	ea5f 0c00 	movs.w	ip, r0
 80a56c0:	bf08      	it	eq
 80a56c2:	4770      	bxeq	lr
 80a56c4:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 80a56c8:	4601      	mov	r1, r0
 80a56ca:	f04f 0000 	mov.w	r0, #0
 80a56ce:	e01c      	b.n	80a570a <__aeabi_l2f+0x2a>

080a56d0 <__aeabi_ul2f>:
 80a56d0:	ea50 0201 	orrs.w	r2, r0, r1
 80a56d4:	bf08      	it	eq
 80a56d6:	4770      	bxeq	lr
 80a56d8:	f04f 0300 	mov.w	r3, #0
 80a56dc:	e00a      	b.n	80a56f4 <__aeabi_l2f+0x14>
 80a56de:	bf00      	nop

080a56e0 <__aeabi_l2f>:
 80a56e0:	ea50 0201 	orrs.w	r2, r0, r1
 80a56e4:	bf08      	it	eq
 80a56e6:	4770      	bxeq	lr
 80a56e8:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 80a56ec:	d502      	bpl.n	80a56f4 <__aeabi_l2f+0x14>
 80a56ee:	4240      	negs	r0, r0
 80a56f0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a56f4:	ea5f 0c01 	movs.w	ip, r1
 80a56f8:	bf02      	ittt	eq
 80a56fa:	4684      	moveq	ip, r0
 80a56fc:	4601      	moveq	r1, r0
 80a56fe:	2000      	moveq	r0, #0
 80a5700:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 80a5704:	bf08      	it	eq
 80a5706:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 80a570a:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 80a570e:	fabc f28c 	clz	r2, ip
 80a5712:	3a08      	subs	r2, #8
 80a5714:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 80a5718:	db10      	blt.n	80a573c <__aeabi_l2f+0x5c>
 80a571a:	fa01 fc02 	lsl.w	ip, r1, r2
 80a571e:	4463      	add	r3, ip
 80a5720:	fa00 fc02 	lsl.w	ip, r0, r2
 80a5724:	f1c2 0220 	rsb	r2, r2, #32
 80a5728:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80a572c:	fa20 f202 	lsr.w	r2, r0, r2
 80a5730:	eb43 0002 	adc.w	r0, r3, r2
 80a5734:	bf08      	it	eq
 80a5736:	f020 0001 	biceq.w	r0, r0, #1
 80a573a:	4770      	bx	lr
 80a573c:	f102 0220 	add.w	r2, r2, #32
 80a5740:	fa01 fc02 	lsl.w	ip, r1, r2
 80a5744:	f1c2 0220 	rsb	r2, r2, #32
 80a5748:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 80a574c:	fa21 f202 	lsr.w	r2, r1, r2
 80a5750:	eb43 0002 	adc.w	r0, r3, r2
 80a5754:	bf08      	it	eq
 80a5756:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a575a:	4770      	bx	lr

080a575c <__aeabi_fmul>:
 80a575c:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a5760:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a5764:	bf1e      	ittt	ne
 80a5766:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a576a:	ea92 0f0c 	teqne	r2, ip
 80a576e:	ea93 0f0c 	teqne	r3, ip
 80a5772:	d06f      	beq.n	80a5854 <__aeabi_fmul+0xf8>
 80a5774:	441a      	add	r2, r3
 80a5776:	ea80 0c01 	eor.w	ip, r0, r1
 80a577a:	0240      	lsls	r0, r0, #9
 80a577c:	bf18      	it	ne
 80a577e:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 80a5782:	d01e      	beq.n	80a57c2 <__aeabi_fmul+0x66>
 80a5784:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80a5788:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 80a578c:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 80a5790:	fba0 3101 	umull	r3, r1, r0, r1
 80a5794:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a5798:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 80a579c:	bf3e      	ittt	cc
 80a579e:	0049      	lslcc	r1, r1, #1
 80a57a0:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 80a57a4:	005b      	lslcc	r3, r3, #1
 80a57a6:	ea40 0001 	orr.w	r0, r0, r1
 80a57aa:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 80a57ae:	2afd      	cmp	r2, #253	; 0xfd
 80a57b0:	d81d      	bhi.n	80a57ee <__aeabi_fmul+0x92>
 80a57b2:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80a57b6:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a57ba:	bf08      	it	eq
 80a57bc:	f020 0001 	biceq.w	r0, r0, #1
 80a57c0:	4770      	bx	lr
 80a57c2:	f090 0f00 	teq	r0, #0
 80a57c6:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a57ca:	bf08      	it	eq
 80a57cc:	0249      	lsleq	r1, r1, #9
 80a57ce:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a57d2:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 80a57d6:	3a7f      	subs	r2, #127	; 0x7f
 80a57d8:	bfc2      	ittt	gt
 80a57da:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a57de:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a57e2:	4770      	bxgt	lr
 80a57e4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a57e8:	f04f 0300 	mov.w	r3, #0
 80a57ec:	3a01      	subs	r2, #1
 80a57ee:	dc5d      	bgt.n	80a58ac <__aeabi_fmul+0x150>
 80a57f0:	f112 0f19 	cmn.w	r2, #25
 80a57f4:	bfdc      	itt	le
 80a57f6:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 80a57fa:	4770      	bxle	lr
 80a57fc:	f1c2 0200 	rsb	r2, r2, #0
 80a5800:	0041      	lsls	r1, r0, #1
 80a5802:	fa21 f102 	lsr.w	r1, r1, r2
 80a5806:	f1c2 0220 	rsb	r2, r2, #32
 80a580a:	fa00 fc02 	lsl.w	ip, r0, r2
 80a580e:	ea5f 0031 	movs.w	r0, r1, rrx
 80a5812:	f140 0000 	adc.w	r0, r0, #0
 80a5816:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 80a581a:	bf08      	it	eq
 80a581c:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a5820:	4770      	bx	lr
 80a5822:	f092 0f00 	teq	r2, #0
 80a5826:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a582a:	bf02      	ittt	eq
 80a582c:	0040      	lsleq	r0, r0, #1
 80a582e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a5832:	3a01      	subeq	r2, #1
 80a5834:	d0f9      	beq.n	80a582a <__aeabi_fmul+0xce>
 80a5836:	ea40 000c 	orr.w	r0, r0, ip
 80a583a:	f093 0f00 	teq	r3, #0
 80a583e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a5842:	bf02      	ittt	eq
 80a5844:	0049      	lsleq	r1, r1, #1
 80a5846:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a584a:	3b01      	subeq	r3, #1
 80a584c:	d0f9      	beq.n	80a5842 <__aeabi_fmul+0xe6>
 80a584e:	ea41 010c 	orr.w	r1, r1, ip
 80a5852:	e78f      	b.n	80a5774 <__aeabi_fmul+0x18>
 80a5854:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a5858:	ea92 0f0c 	teq	r2, ip
 80a585c:	bf18      	it	ne
 80a585e:	ea93 0f0c 	teqne	r3, ip
 80a5862:	d00a      	beq.n	80a587a <__aeabi_fmul+0x11e>
 80a5864:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a5868:	bf18      	it	ne
 80a586a:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a586e:	d1d8      	bne.n	80a5822 <__aeabi_fmul+0xc6>
 80a5870:	ea80 0001 	eor.w	r0, r0, r1
 80a5874:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a5878:	4770      	bx	lr
 80a587a:	f090 0f00 	teq	r0, #0
 80a587e:	bf17      	itett	ne
 80a5880:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 80a5884:	4608      	moveq	r0, r1
 80a5886:	f091 0f00 	teqne	r1, #0
 80a588a:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 80a588e:	d014      	beq.n	80a58ba <__aeabi_fmul+0x15e>
 80a5890:	ea92 0f0c 	teq	r2, ip
 80a5894:	d101      	bne.n	80a589a <__aeabi_fmul+0x13e>
 80a5896:	0242      	lsls	r2, r0, #9
 80a5898:	d10f      	bne.n	80a58ba <__aeabi_fmul+0x15e>
 80a589a:	ea93 0f0c 	teq	r3, ip
 80a589e:	d103      	bne.n	80a58a8 <__aeabi_fmul+0x14c>
 80a58a0:	024b      	lsls	r3, r1, #9
 80a58a2:	bf18      	it	ne
 80a58a4:	4608      	movne	r0, r1
 80a58a6:	d108      	bne.n	80a58ba <__aeabi_fmul+0x15e>
 80a58a8:	ea80 0001 	eor.w	r0, r0, r1
 80a58ac:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a58b0:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a58b4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a58b8:	4770      	bx	lr
 80a58ba:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a58be:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 80a58c2:	4770      	bx	lr

080a58c4 <__aeabi_fdiv>:
 80a58c4:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a58c8:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a58cc:	bf1e      	ittt	ne
 80a58ce:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a58d2:	ea92 0f0c 	teqne	r2, ip
 80a58d6:	ea93 0f0c 	teqne	r3, ip
 80a58da:	d069      	beq.n	80a59b0 <__aeabi_fdiv+0xec>
 80a58dc:	eba2 0203 	sub.w	r2, r2, r3
 80a58e0:	ea80 0c01 	eor.w	ip, r0, r1
 80a58e4:	0249      	lsls	r1, r1, #9
 80a58e6:	ea4f 2040 	mov.w	r0, r0, lsl #9
 80a58ea:	d037      	beq.n	80a595c <__aeabi_fdiv+0x98>
 80a58ec:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80a58f0:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 80a58f4:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 80a58f8:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a58fc:	428b      	cmp	r3, r1
 80a58fe:	bf38      	it	cc
 80a5900:	005b      	lslcc	r3, r3, #1
 80a5902:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 80a5906:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 80a590a:	428b      	cmp	r3, r1
 80a590c:	bf24      	itt	cs
 80a590e:	1a5b      	subcs	r3, r3, r1
 80a5910:	ea40 000c 	orrcs.w	r0, r0, ip
 80a5914:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 80a5918:	bf24      	itt	cs
 80a591a:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 80a591e:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80a5922:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 80a5926:	bf24      	itt	cs
 80a5928:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 80a592c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80a5930:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 80a5934:	bf24      	itt	cs
 80a5936:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 80a593a:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80a593e:	011b      	lsls	r3, r3, #4
 80a5940:	bf18      	it	ne
 80a5942:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 80a5946:	d1e0      	bne.n	80a590a <__aeabi_fdiv+0x46>
 80a5948:	2afd      	cmp	r2, #253	; 0xfd
 80a594a:	f63f af50 	bhi.w	80a57ee <__aeabi_fmul+0x92>
 80a594e:	428b      	cmp	r3, r1
 80a5950:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a5954:	bf08      	it	eq
 80a5956:	f020 0001 	biceq.w	r0, r0, #1
 80a595a:	4770      	bx	lr
 80a595c:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a5960:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a5964:	327f      	adds	r2, #127	; 0x7f
 80a5966:	bfc2      	ittt	gt
 80a5968:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a596c:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a5970:	4770      	bxgt	lr
 80a5972:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a5976:	f04f 0300 	mov.w	r3, #0
 80a597a:	3a01      	subs	r2, #1
 80a597c:	e737      	b.n	80a57ee <__aeabi_fmul+0x92>
 80a597e:	f092 0f00 	teq	r2, #0
 80a5982:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a5986:	bf02      	ittt	eq
 80a5988:	0040      	lsleq	r0, r0, #1
 80a598a:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a598e:	3a01      	subeq	r2, #1
 80a5990:	d0f9      	beq.n	80a5986 <__aeabi_fdiv+0xc2>
 80a5992:	ea40 000c 	orr.w	r0, r0, ip
 80a5996:	f093 0f00 	teq	r3, #0
 80a599a:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a599e:	bf02      	ittt	eq
 80a59a0:	0049      	lsleq	r1, r1, #1
 80a59a2:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a59a6:	3b01      	subeq	r3, #1
 80a59a8:	d0f9      	beq.n	80a599e <__aeabi_fdiv+0xda>
 80a59aa:	ea41 010c 	orr.w	r1, r1, ip
 80a59ae:	e795      	b.n	80a58dc <__aeabi_fdiv+0x18>
 80a59b0:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a59b4:	ea92 0f0c 	teq	r2, ip
 80a59b8:	d108      	bne.n	80a59cc <__aeabi_fdiv+0x108>
 80a59ba:	0242      	lsls	r2, r0, #9
 80a59bc:	f47f af7d 	bne.w	80a58ba <__aeabi_fmul+0x15e>
 80a59c0:	ea93 0f0c 	teq	r3, ip
 80a59c4:	f47f af70 	bne.w	80a58a8 <__aeabi_fmul+0x14c>
 80a59c8:	4608      	mov	r0, r1
 80a59ca:	e776      	b.n	80a58ba <__aeabi_fmul+0x15e>
 80a59cc:	ea93 0f0c 	teq	r3, ip
 80a59d0:	d104      	bne.n	80a59dc <__aeabi_fdiv+0x118>
 80a59d2:	024b      	lsls	r3, r1, #9
 80a59d4:	f43f af4c 	beq.w	80a5870 <__aeabi_fmul+0x114>
 80a59d8:	4608      	mov	r0, r1
 80a59da:	e76e      	b.n	80a58ba <__aeabi_fmul+0x15e>
 80a59dc:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a59e0:	bf18      	it	ne
 80a59e2:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a59e6:	d1ca      	bne.n	80a597e <__aeabi_fdiv+0xba>
 80a59e8:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 80a59ec:	f47f af5c 	bne.w	80a58a8 <__aeabi_fmul+0x14c>
 80a59f0:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 80a59f4:	f47f af3c 	bne.w	80a5870 <__aeabi_fmul+0x114>
 80a59f8:	e75f      	b.n	80a58ba <__aeabi_fmul+0x15e>
 80a59fa:	bf00      	nop

080a59fc <__gesf2>:
 80a59fc:	f04f 3cff 	mov.w	ip, #4294967295
 80a5a00:	e006      	b.n	80a5a10 <__cmpsf2+0x4>
 80a5a02:	bf00      	nop

080a5a04 <__lesf2>:
 80a5a04:	f04f 0c01 	mov.w	ip, #1
 80a5a08:	e002      	b.n	80a5a10 <__cmpsf2+0x4>
 80a5a0a:	bf00      	nop

080a5a0c <__cmpsf2>:
 80a5a0c:	f04f 0c01 	mov.w	ip, #1
 80a5a10:	f84d cd04 	str.w	ip, [sp, #-4]!
 80a5a14:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80a5a18:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80a5a1c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a5a20:	bf18      	it	ne
 80a5a22:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a5a26:	d011      	beq.n	80a5a4c <__cmpsf2+0x40>
 80a5a28:	b001      	add	sp, #4
 80a5a2a:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 80a5a2e:	bf18      	it	ne
 80a5a30:	ea90 0f01 	teqne	r0, r1
 80a5a34:	bf58      	it	pl
 80a5a36:	ebb2 0003 	subspl.w	r0, r2, r3
 80a5a3a:	bf88      	it	hi
 80a5a3c:	17c8      	asrhi	r0, r1, #31
 80a5a3e:	bf38      	it	cc
 80a5a40:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 80a5a44:	bf18      	it	ne
 80a5a46:	f040 0001 	orrne.w	r0, r0, #1
 80a5a4a:	4770      	bx	lr
 80a5a4c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a5a50:	d102      	bne.n	80a5a58 <__cmpsf2+0x4c>
 80a5a52:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 80a5a56:	d105      	bne.n	80a5a64 <__cmpsf2+0x58>
 80a5a58:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 80a5a5c:	d1e4      	bne.n	80a5a28 <__cmpsf2+0x1c>
 80a5a5e:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 80a5a62:	d0e1      	beq.n	80a5a28 <__cmpsf2+0x1c>
 80a5a64:	f85d 0b04 	ldr.w	r0, [sp], #4
 80a5a68:	4770      	bx	lr
 80a5a6a:	bf00      	nop

080a5a6c <__aeabi_cfrcmple>:
 80a5a6c:	4684      	mov	ip, r0
 80a5a6e:	4608      	mov	r0, r1
 80a5a70:	4661      	mov	r1, ip
 80a5a72:	e7ff      	b.n	80a5a74 <__aeabi_cfcmpeq>

080a5a74 <__aeabi_cfcmpeq>:
 80a5a74:	b50f      	push	{r0, r1, r2, r3, lr}
 80a5a76:	f7ff ffc9 	bl	80a5a0c <__cmpsf2>
 80a5a7a:	2800      	cmp	r0, #0
 80a5a7c:	bf48      	it	mi
 80a5a7e:	f110 0f00 	cmnmi.w	r0, #0
 80a5a82:	bd0f      	pop	{r0, r1, r2, r3, pc}

080a5a84 <__aeabi_fcmpeq>:
 80a5a84:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a5a88:	f7ff fff4 	bl	80a5a74 <__aeabi_cfcmpeq>
 80a5a8c:	bf0c      	ite	eq
 80a5a8e:	2001      	moveq	r0, #1
 80a5a90:	2000      	movne	r0, #0
 80a5a92:	f85d fb08 	ldr.w	pc, [sp], #8
 80a5a96:	bf00      	nop

080a5a98 <__aeabi_fcmplt>:
 80a5a98:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a5a9c:	f7ff ffea 	bl	80a5a74 <__aeabi_cfcmpeq>
 80a5aa0:	bf34      	ite	cc
 80a5aa2:	2001      	movcc	r0, #1
 80a5aa4:	2000      	movcs	r0, #0
 80a5aa6:	f85d fb08 	ldr.w	pc, [sp], #8
 80a5aaa:	bf00      	nop

080a5aac <__aeabi_fcmple>:
 80a5aac:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a5ab0:	f7ff ffe0 	bl	80a5a74 <__aeabi_cfcmpeq>
 80a5ab4:	bf94      	ite	ls
 80a5ab6:	2001      	movls	r0, #1
 80a5ab8:	2000      	movhi	r0, #0
 80a5aba:	f85d fb08 	ldr.w	pc, [sp], #8
 80a5abe:	bf00      	nop

080a5ac0 <__aeabi_fcmpge>:
 80a5ac0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a5ac4:	f7ff ffd2 	bl	80a5a6c <__aeabi_cfrcmple>
 80a5ac8:	bf94      	ite	ls
 80a5aca:	2001      	movls	r0, #1
 80a5acc:	2000      	movhi	r0, #0
 80a5ace:	f85d fb08 	ldr.w	pc, [sp], #8
 80a5ad2:	bf00      	nop

080a5ad4 <__aeabi_fcmpgt>:
 80a5ad4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a5ad8:	f7ff ffc8 	bl	80a5a6c <__aeabi_cfrcmple>
 80a5adc:	bf34      	ite	cc
 80a5ade:	2001      	movcc	r0, #1
 80a5ae0:	2000      	movcs	r0, #0
 80a5ae2:	f85d fb08 	ldr.w	pc, [sp], #8
 80a5ae6:	bf00      	nop

080a5ae8 <__aeabi_f2iz>:
 80a5ae8:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80a5aec:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80a5af0:	d30f      	bcc.n	80a5b12 <__aeabi_f2iz+0x2a>
 80a5af2:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80a5af6:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 80a5afa:	d90d      	bls.n	80a5b18 <__aeabi_f2iz+0x30>
 80a5afc:	ea4f 2300 	mov.w	r3, r0, lsl #8
 80a5b00:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a5b04:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80a5b08:	fa23 f002 	lsr.w	r0, r3, r2
 80a5b0c:	bf18      	it	ne
 80a5b0e:	4240      	negne	r0, r0
 80a5b10:	4770      	bx	lr
 80a5b12:	f04f 0000 	mov.w	r0, #0
 80a5b16:	4770      	bx	lr
 80a5b18:	f112 0f61 	cmn.w	r2, #97	; 0x61
 80a5b1c:	d101      	bne.n	80a5b22 <__aeabi_f2iz+0x3a>
 80a5b1e:	0242      	lsls	r2, r0, #9
 80a5b20:	d105      	bne.n	80a5b2e <__aeabi_f2iz+0x46>
 80a5b22:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 80a5b26:	bf08      	it	eq
 80a5b28:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a5b2c:	4770      	bx	lr
 80a5b2e:	f04f 0000 	mov.w	r0, #0
 80a5b32:	4770      	bx	lr

080a5b34 <__aeabi_f2uiz>:
 80a5b34:	0042      	lsls	r2, r0, #1
 80a5b36:	d20e      	bcs.n	80a5b56 <__aeabi_f2uiz+0x22>
 80a5b38:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80a5b3c:	d30b      	bcc.n	80a5b56 <__aeabi_f2uiz+0x22>
 80a5b3e:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80a5b42:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 80a5b46:	d409      	bmi.n	80a5b5c <__aeabi_f2uiz+0x28>
 80a5b48:	ea4f 2300 	mov.w	r3, r0, lsl #8
 80a5b4c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a5b50:	fa23 f002 	lsr.w	r0, r3, r2
 80a5b54:	4770      	bx	lr
 80a5b56:	f04f 0000 	mov.w	r0, #0
 80a5b5a:	4770      	bx	lr
 80a5b5c:	f112 0f61 	cmn.w	r2, #97	; 0x61
 80a5b60:	d101      	bne.n	80a5b66 <__aeabi_f2uiz+0x32>
 80a5b62:	0242      	lsls	r2, r0, #9
 80a5b64:	d102      	bne.n	80a5b6c <__aeabi_f2uiz+0x38>
 80a5b66:	f04f 30ff 	mov.w	r0, #4294967295
 80a5b6a:	4770      	bx	lr
 80a5b6c:	f04f 0000 	mov.w	r0, #0
 80a5b70:	4770      	bx	lr
 80a5b72:	bf00      	nop

080a5b74 <atol>:
 80a5b74:	220a      	movs	r2, #10
 80a5b76:	2100      	movs	r1, #0
 80a5b78:	f000 b9c8 	b.w	80a5f0c <strtol>

080a5b7c <__cxa_atexit>:
 80a5b7c:	b510      	push	{r4, lr}
 80a5b7e:	4c05      	ldr	r4, [pc, #20]	; (80a5b94 <__cxa_atexit+0x18>)
 80a5b80:	4613      	mov	r3, r2
 80a5b82:	b12c      	cbz	r4, 80a5b90 <__cxa_atexit+0x14>
 80a5b84:	460a      	mov	r2, r1
 80a5b86:	4601      	mov	r1, r0
 80a5b88:	2002      	movs	r0, #2
 80a5b8a:	f3af 8000 	nop.w
 80a5b8e:	bd10      	pop	{r4, pc}
 80a5b90:	4620      	mov	r0, r4
 80a5b92:	bd10      	pop	{r4, pc}
 80a5b94:	00000000 	.word	0x00000000

080a5b98 <memcpy>:
 80a5b98:	b510      	push	{r4, lr}
 80a5b9a:	1e43      	subs	r3, r0, #1
 80a5b9c:	440a      	add	r2, r1
 80a5b9e:	4291      	cmp	r1, r2
 80a5ba0:	d004      	beq.n	80a5bac <memcpy+0x14>
 80a5ba2:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a5ba6:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a5baa:	e7f8      	b.n	80a5b9e <memcpy+0x6>
 80a5bac:	bd10      	pop	{r4, pc}

080a5bae <memset>:
 80a5bae:	4603      	mov	r3, r0
 80a5bb0:	4402      	add	r2, r0
 80a5bb2:	4293      	cmp	r3, r2
 80a5bb4:	d002      	beq.n	80a5bbc <memset+0xe>
 80a5bb6:	f803 1b01 	strb.w	r1, [r3], #1
 80a5bba:	e7fa      	b.n	80a5bb2 <memset+0x4>
 80a5bbc:	4770      	bx	lr
	...

080a5bc0 <srand>:
 80a5bc0:	b538      	push	{r3, r4, r5, lr}
 80a5bc2:	4b12      	ldr	r3, [pc, #72]	; (80a5c0c <srand+0x4c>)
 80a5bc4:	4605      	mov	r5, r0
 80a5bc6:	681c      	ldr	r4, [r3, #0]
 80a5bc8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a5bca:	b9d3      	cbnz	r3, 80a5c02 <srand+0x42>
 80a5bcc:	2018      	movs	r0, #24
 80a5bce:	f7fd ff2b 	bl	80a3a28 <malloc>
 80a5bd2:	f243 330e 	movw	r3, #13070	; 0x330e
 80a5bd6:	63a0      	str	r0, [r4, #56]	; 0x38
 80a5bd8:	8003      	strh	r3, [r0, #0]
 80a5bda:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 80a5bde:	8043      	strh	r3, [r0, #2]
 80a5be0:	f241 2334 	movw	r3, #4660	; 0x1234
 80a5be4:	8083      	strh	r3, [r0, #4]
 80a5be6:	f24e 636d 	movw	r3, #58989	; 0xe66d
 80a5bea:	80c3      	strh	r3, [r0, #6]
 80a5bec:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 80a5bf0:	8103      	strh	r3, [r0, #8]
 80a5bf2:	2305      	movs	r3, #5
 80a5bf4:	8143      	strh	r3, [r0, #10]
 80a5bf6:	230b      	movs	r3, #11
 80a5bf8:	8183      	strh	r3, [r0, #12]
 80a5bfa:	2201      	movs	r2, #1
 80a5bfc:	2300      	movs	r3, #0
 80a5bfe:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a5c02:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a5c04:	2200      	movs	r2, #0
 80a5c06:	611d      	str	r5, [r3, #16]
 80a5c08:	615a      	str	r2, [r3, #20]
 80a5c0a:	bd38      	pop	{r3, r4, r5, pc}
 80a5c0c:	200004ec 	.word	0x200004ec

080a5c10 <rand>:
 80a5c10:	4b19      	ldr	r3, [pc, #100]	; (80a5c78 <rand+0x68>)
 80a5c12:	b510      	push	{r4, lr}
 80a5c14:	681c      	ldr	r4, [r3, #0]
 80a5c16:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a5c18:	b9d3      	cbnz	r3, 80a5c50 <rand+0x40>
 80a5c1a:	2018      	movs	r0, #24
 80a5c1c:	f7fd ff04 	bl	80a3a28 <malloc>
 80a5c20:	f243 330e 	movw	r3, #13070	; 0x330e
 80a5c24:	63a0      	str	r0, [r4, #56]	; 0x38
 80a5c26:	8003      	strh	r3, [r0, #0]
 80a5c28:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 80a5c2c:	8043      	strh	r3, [r0, #2]
 80a5c2e:	f241 2334 	movw	r3, #4660	; 0x1234
 80a5c32:	8083      	strh	r3, [r0, #4]
 80a5c34:	f24e 636d 	movw	r3, #58989	; 0xe66d
 80a5c38:	80c3      	strh	r3, [r0, #6]
 80a5c3a:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 80a5c3e:	8103      	strh	r3, [r0, #8]
 80a5c40:	2305      	movs	r3, #5
 80a5c42:	8143      	strh	r3, [r0, #10]
 80a5c44:	230b      	movs	r3, #11
 80a5c46:	8183      	strh	r3, [r0, #12]
 80a5c48:	2201      	movs	r2, #1
 80a5c4a:	2300      	movs	r3, #0
 80a5c4c:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a5c50:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80a5c52:	4c0a      	ldr	r4, [pc, #40]	; (80a5c7c <rand+0x6c>)
 80a5c54:	690b      	ldr	r3, [r1, #16]
 80a5c56:	6948      	ldr	r0, [r1, #20]
 80a5c58:	435c      	muls	r4, r3
 80a5c5a:	4a09      	ldr	r2, [pc, #36]	; (80a5c80 <rand+0x70>)
 80a5c5c:	fb02 4000 	mla	r0, r2, r0, r4
 80a5c60:	fba3 2302 	umull	r2, r3, r3, r2
 80a5c64:	3201      	adds	r2, #1
 80a5c66:	4403      	add	r3, r0
 80a5c68:	f143 0300 	adc.w	r3, r3, #0
 80a5c6c:	e9c1 2304 	strd	r2, r3, [r1, #16]
 80a5c70:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
 80a5c74:	bd10      	pop	{r4, pc}
 80a5c76:	bf00      	nop
 80a5c78:	200004ec 	.word	0x200004ec
 80a5c7c:	5851f42d 	.word	0x5851f42d
 80a5c80:	4c957f2d 	.word	0x4c957f2d

080a5c84 <strcat>:
 80a5c84:	4602      	mov	r2, r0
 80a5c86:	b510      	push	{r4, lr}
 80a5c88:	4613      	mov	r3, r2
 80a5c8a:	781c      	ldrb	r4, [r3, #0]
 80a5c8c:	3201      	adds	r2, #1
 80a5c8e:	2c00      	cmp	r4, #0
 80a5c90:	d1fa      	bne.n	80a5c88 <strcat+0x4>
 80a5c92:	3b01      	subs	r3, #1
 80a5c94:	f811 2b01 	ldrb.w	r2, [r1], #1
 80a5c98:	f803 2f01 	strb.w	r2, [r3, #1]!
 80a5c9c:	2a00      	cmp	r2, #0
 80a5c9e:	d1f9      	bne.n	80a5c94 <strcat+0x10>
 80a5ca0:	bd10      	pop	{r4, pc}

080a5ca2 <strcmp>:
 80a5ca2:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a5ca6:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a5caa:	2a01      	cmp	r2, #1
 80a5cac:	bf28      	it	cs
 80a5cae:	429a      	cmpcs	r2, r3
 80a5cb0:	d0f7      	beq.n	80a5ca2 <strcmp>
 80a5cb2:	1ad0      	subs	r0, r2, r3
 80a5cb4:	4770      	bx	lr

080a5cb6 <strcpy>:
 80a5cb6:	4603      	mov	r3, r0
 80a5cb8:	f811 2b01 	ldrb.w	r2, [r1], #1
 80a5cbc:	f803 2b01 	strb.w	r2, [r3], #1
 80a5cc0:	2a00      	cmp	r2, #0
 80a5cc2:	d1f9      	bne.n	80a5cb8 <strcpy+0x2>
 80a5cc4:	4770      	bx	lr
	...

080a5cc8 <strdup>:
 80a5cc8:	4b02      	ldr	r3, [pc, #8]	; (80a5cd4 <strdup+0xc>)
 80a5cca:	4601      	mov	r1, r0
 80a5ccc:	6818      	ldr	r0, [r3, #0]
 80a5cce:	f000 b803 	b.w	80a5cd8 <_strdup_r>
 80a5cd2:	bf00      	nop
 80a5cd4:	200004ec 	.word	0x200004ec

080a5cd8 <_strdup_r>:
 80a5cd8:	b570      	push	{r4, r5, r6, lr}
 80a5cda:	4606      	mov	r6, r0
 80a5cdc:	4608      	mov	r0, r1
 80a5cde:	460c      	mov	r4, r1
 80a5ce0:	f000 f80d 	bl	80a5cfe <strlen>
 80a5ce4:	1c45      	adds	r5, r0, #1
 80a5ce6:	4629      	mov	r1, r5
 80a5ce8:	4630      	mov	r0, r6
 80a5cea:	f7fd fecd 	bl	80a3a88 <_malloc_r>
 80a5cee:	4606      	mov	r6, r0
 80a5cf0:	b118      	cbz	r0, 80a5cfa <_strdup_r+0x22>
 80a5cf2:	462a      	mov	r2, r5
 80a5cf4:	4621      	mov	r1, r4
 80a5cf6:	f7ff ff4f 	bl	80a5b98 <memcpy>
 80a5cfa:	4630      	mov	r0, r6
 80a5cfc:	bd70      	pop	{r4, r5, r6, pc}

080a5cfe <strlen>:
 80a5cfe:	4603      	mov	r3, r0
 80a5d00:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a5d04:	2a00      	cmp	r2, #0
 80a5d06:	d1fb      	bne.n	80a5d00 <strlen+0x2>
 80a5d08:	1a18      	subs	r0, r3, r0
 80a5d0a:	3801      	subs	r0, #1
 80a5d0c:	4770      	bx	lr

080a5d0e <strstr>:
 80a5d0e:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a5d10:	7803      	ldrb	r3, [r0, #0]
 80a5d12:	b963      	cbnz	r3, 80a5d2e <strstr+0x20>
 80a5d14:	780b      	ldrb	r3, [r1, #0]
 80a5d16:	2b00      	cmp	r3, #0
 80a5d18:	bf18      	it	ne
 80a5d1a:	2000      	movne	r0, #0
 80a5d1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a5d1e:	f815 2f01 	ldrb.w	r2, [r5, #1]!
 80a5d22:	b162      	cbz	r2, 80a5d3e <strstr+0x30>
 80a5d24:	f814 7f01 	ldrb.w	r7, [r4, #1]!
 80a5d28:	4630      	mov	r0, r6
 80a5d2a:	4297      	cmp	r7, r2
 80a5d2c:	d0f7      	beq.n	80a5d1e <strstr+0x10>
 80a5d2e:	4603      	mov	r3, r0
 80a5d30:	1c46      	adds	r6, r0, #1
 80a5d32:	7800      	ldrb	r0, [r0, #0]
 80a5d34:	b110      	cbz	r0, 80a5d3c <strstr+0x2e>
 80a5d36:	1e4d      	subs	r5, r1, #1
 80a5d38:	1e5c      	subs	r4, r3, #1
 80a5d3a:	e7f0      	b.n	80a5d1e <strstr+0x10>
 80a5d3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a5d3e:	4618      	mov	r0, r3
 80a5d40:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080a5d44 <strtok>:
 80a5d44:	4b17      	ldr	r3, [pc, #92]	; (80a5da4 <strtok+0x60>)
 80a5d46:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a5d4a:	681d      	ldr	r5, [r3, #0]
 80a5d4c:	4606      	mov	r6, r0
 80a5d4e:	6dac      	ldr	r4, [r5, #88]	; 0x58
 80a5d50:	460f      	mov	r7, r1
 80a5d52:	b9fc      	cbnz	r4, 80a5d94 <strtok+0x50>
 80a5d54:	2050      	movs	r0, #80	; 0x50
 80a5d56:	f7fd fe67 	bl	80a3a28 <malloc>
 80a5d5a:	65a8      	str	r0, [r5, #88]	; 0x58
 80a5d5c:	6084      	str	r4, [r0, #8]
 80a5d5e:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a5d60:	6004      	str	r4, [r0, #0]
 80a5d62:	6044      	str	r4, [r0, #4]
 80a5d64:	611c      	str	r4, [r3, #16]
 80a5d66:	60dc      	str	r4, [r3, #12]
 80a5d68:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a5d6a:	619c      	str	r4, [r3, #24]
 80a5d6c:	615c      	str	r4, [r3, #20]
 80a5d6e:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a5d70:	62dc      	str	r4, [r3, #44]	; 0x2c
 80a5d72:	629c      	str	r4, [r3, #40]	; 0x28
 80a5d74:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a5d76:	635c      	str	r4, [r3, #52]	; 0x34
 80a5d78:	631c      	str	r4, [r3, #48]	; 0x30
 80a5d7a:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a5d7c:	63dc      	str	r4, [r3, #60]	; 0x3c
 80a5d7e:	639c      	str	r4, [r3, #56]	; 0x38
 80a5d80:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a5d82:	645c      	str	r4, [r3, #68]	; 0x44
 80a5d84:	641c      	str	r4, [r3, #64]	; 0x40
 80a5d86:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a5d88:	64dc      	str	r4, [r3, #76]	; 0x4c
 80a5d8a:	649c      	str	r4, [r3, #72]	; 0x48
 80a5d8c:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a5d8e:	771c      	strb	r4, [r3, #28]
 80a5d90:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80a5d92:	625c      	str	r4, [r3, #36]	; 0x24
 80a5d94:	6daa      	ldr	r2, [r5, #88]	; 0x58
 80a5d96:	4639      	mov	r1, r7
 80a5d98:	4630      	mov	r0, r6
 80a5d9a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80a5d9e:	2301      	movs	r3, #1
 80a5da0:	f000 b802 	b.w	80a5da8 <__strtok_r>
 80a5da4:	200004ec 	.word	0x200004ec

080a5da8 <__strtok_r>:
 80a5da8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a5daa:	b948      	cbnz	r0, 80a5dc0 <__strtok_r+0x18>
 80a5dac:	6810      	ldr	r0, [r2, #0]
 80a5dae:	b938      	cbnz	r0, 80a5dc0 <__strtok_r+0x18>
 80a5db0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a5db2:	f817 6b01 	ldrb.w	r6, [r7], #1
 80a5db6:	b15e      	cbz	r6, 80a5dd0 <__strtok_r+0x28>
 80a5db8:	42b5      	cmp	r5, r6
 80a5dba:	d1fa      	bne.n	80a5db2 <__strtok_r+0xa>
 80a5dbc:	b12b      	cbz	r3, 80a5dca <__strtok_r+0x22>
 80a5dbe:	4620      	mov	r0, r4
 80a5dc0:	4604      	mov	r4, r0
 80a5dc2:	460f      	mov	r7, r1
 80a5dc4:	f814 5b01 	ldrb.w	r5, [r4], #1
 80a5dc8:	e7f3      	b.n	80a5db2 <__strtok_r+0xa>
 80a5dca:	6014      	str	r4, [r2, #0]
 80a5dcc:	7003      	strb	r3, [r0, #0]
 80a5dce:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a5dd0:	b94d      	cbnz	r5, 80a5de6 <__strtok_r+0x3e>
 80a5dd2:	6015      	str	r5, [r2, #0]
 80a5dd4:	4628      	mov	r0, r5
 80a5dd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a5dd8:	f817 6b01 	ldrb.w	r6, [r7], #1
 80a5ddc:	42b5      	cmp	r5, r6
 80a5dde:	d007      	beq.n	80a5df0 <__strtok_r+0x48>
 80a5de0:	2e00      	cmp	r6, #0
 80a5de2:	d1f9      	bne.n	80a5dd8 <__strtok_r+0x30>
 80a5de4:	461c      	mov	r4, r3
 80a5de6:	4623      	mov	r3, r4
 80a5de8:	460f      	mov	r7, r1
 80a5dea:	f813 5b01 	ldrb.w	r5, [r3], #1
 80a5dee:	e7f3      	b.n	80a5dd8 <__strtok_r+0x30>
 80a5df0:	b115      	cbz	r5, 80a5df8 <__strtok_r+0x50>
 80a5df2:	2100      	movs	r1, #0
 80a5df4:	7021      	strb	r1, [r4, #0]
 80a5df6:	e000      	b.n	80a5dfa <__strtok_r+0x52>
 80a5df8:	462b      	mov	r3, r5
 80a5dfa:	6013      	str	r3, [r2, #0]
 80a5dfc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080a5e00 <_strtol_r>:
 80a5e00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a5e04:	460f      	mov	r7, r1
 80a5e06:	4680      	mov	r8, r0
 80a5e08:	483f      	ldr	r0, [pc, #252]	; (80a5f08 <_strtol_r+0x108>)
 80a5e0a:	f8d0 9000 	ldr.w	r9, [r0]
 80a5e0e:	463d      	mov	r5, r7
 80a5e10:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a5e14:	eb09 0004 	add.w	r0, r9, r4
 80a5e18:	7840      	ldrb	r0, [r0, #1]
 80a5e1a:	f000 0008 	and.w	r0, r0, #8
 80a5e1e:	f000 06ff 	and.w	r6, r0, #255	; 0xff
 80a5e22:	b108      	cbz	r0, 80a5e28 <_strtol_r+0x28>
 80a5e24:	462f      	mov	r7, r5
 80a5e26:	e7f2      	b.n	80a5e0e <_strtol_r+0xe>
 80a5e28:	2c2d      	cmp	r4, #45	; 0x2d
 80a5e2a:	d103      	bne.n	80a5e34 <_strtol_r+0x34>
 80a5e2c:	1cbd      	adds	r5, r7, #2
 80a5e2e:	787c      	ldrb	r4, [r7, #1]
 80a5e30:	2601      	movs	r6, #1
 80a5e32:	e003      	b.n	80a5e3c <_strtol_r+0x3c>
 80a5e34:	2c2b      	cmp	r4, #43	; 0x2b
 80a5e36:	bf04      	itt	eq
 80a5e38:	787c      	ldrbeq	r4, [r7, #1]
 80a5e3a:	1cbd      	addeq	r5, r7, #2
 80a5e3c:	b113      	cbz	r3, 80a5e44 <_strtol_r+0x44>
 80a5e3e:	2b10      	cmp	r3, #16
 80a5e40:	d10a      	bne.n	80a5e58 <_strtol_r+0x58>
 80a5e42:	e05b      	b.n	80a5efc <_strtol_r+0xfc>
 80a5e44:	2c30      	cmp	r4, #48	; 0x30
 80a5e46:	d157      	bne.n	80a5ef8 <_strtol_r+0xf8>
 80a5e48:	7828      	ldrb	r0, [r5, #0]
 80a5e4a:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 80a5e4e:	2858      	cmp	r0, #88	; 0x58
 80a5e50:	d14d      	bne.n	80a5eee <_strtol_r+0xee>
 80a5e52:	786c      	ldrb	r4, [r5, #1]
 80a5e54:	2310      	movs	r3, #16
 80a5e56:	3502      	adds	r5, #2
 80a5e58:	2e00      	cmp	r6, #0
 80a5e5a:	bf14      	ite	ne
 80a5e5c:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
 80a5e60:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
 80a5e64:	fbbc faf3 	udiv	sl, ip, r3
 80a5e68:	2700      	movs	r7, #0
 80a5e6a:	4638      	mov	r0, r7
 80a5e6c:	fb03 cc1a 	mls	ip, r3, sl, ip
 80a5e70:	eb09 0e04 	add.w	lr, r9, r4
 80a5e74:	f89e e001 	ldrb.w	lr, [lr, #1]
 80a5e78:	f01e 0f04 	tst.w	lr, #4
 80a5e7c:	d001      	beq.n	80a5e82 <_strtol_r+0x82>
 80a5e7e:	3c30      	subs	r4, #48	; 0x30
 80a5e80:	e00b      	b.n	80a5e9a <_strtol_r+0x9a>
 80a5e82:	f01e 0e03 	ands.w	lr, lr, #3
 80a5e86:	d01b      	beq.n	80a5ec0 <_strtol_r+0xc0>
 80a5e88:	f1be 0f01 	cmp.w	lr, #1
 80a5e8c:	bf0c      	ite	eq
 80a5e8e:	f04f 0e37 	moveq.w	lr, #55	; 0x37
 80a5e92:	f04f 0e57 	movne.w	lr, #87	; 0x57
 80a5e96:	ebce 0404 	rsb	r4, lr, r4
 80a5e9a:	42a3      	cmp	r3, r4
 80a5e9c:	dd10      	ble.n	80a5ec0 <_strtol_r+0xc0>
 80a5e9e:	f1b7 3fff 	cmp.w	r7, #4294967295
 80a5ea2:	d00a      	beq.n	80a5eba <_strtol_r+0xba>
 80a5ea4:	4550      	cmp	r0, sl
 80a5ea6:	d806      	bhi.n	80a5eb6 <_strtol_r+0xb6>
 80a5ea8:	d101      	bne.n	80a5eae <_strtol_r+0xae>
 80a5eaa:	4564      	cmp	r4, ip
 80a5eac:	dc03      	bgt.n	80a5eb6 <_strtol_r+0xb6>
 80a5eae:	fb03 4000 	mla	r0, r3, r0, r4
 80a5eb2:	2701      	movs	r7, #1
 80a5eb4:	e001      	b.n	80a5eba <_strtol_r+0xba>
 80a5eb6:	f04f 37ff 	mov.w	r7, #4294967295
 80a5eba:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a5ebe:	e7d7      	b.n	80a5e70 <_strtol_r+0x70>
 80a5ec0:	1c7b      	adds	r3, r7, #1
 80a5ec2:	d10c      	bne.n	80a5ede <_strtol_r+0xde>
 80a5ec4:	2e00      	cmp	r6, #0
 80a5ec6:	f04f 0322 	mov.w	r3, #34	; 0x22
 80a5eca:	bf14      	ite	ne
 80a5ecc:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 80a5ed0:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a5ed4:	f8c8 3000 	str.w	r3, [r8]
 80a5ed8:	b92a      	cbnz	r2, 80a5ee6 <_strtol_r+0xe6>
 80a5eda:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a5ede:	b106      	cbz	r6, 80a5ee2 <_strtol_r+0xe2>
 80a5ee0:	4240      	negs	r0, r0
 80a5ee2:	b172      	cbz	r2, 80a5f02 <_strtol_r+0x102>
 80a5ee4:	b107      	cbz	r7, 80a5ee8 <_strtol_r+0xe8>
 80a5ee6:	1e69      	subs	r1, r5, #1
 80a5ee8:	6011      	str	r1, [r2, #0]
 80a5eea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a5eee:	2430      	movs	r4, #48	; 0x30
 80a5ef0:	2b00      	cmp	r3, #0
 80a5ef2:	d1b1      	bne.n	80a5e58 <_strtol_r+0x58>
 80a5ef4:	2308      	movs	r3, #8
 80a5ef6:	e7af      	b.n	80a5e58 <_strtol_r+0x58>
 80a5ef8:	230a      	movs	r3, #10
 80a5efa:	e7ad      	b.n	80a5e58 <_strtol_r+0x58>
 80a5efc:	2c30      	cmp	r4, #48	; 0x30
 80a5efe:	d0a3      	beq.n	80a5e48 <_strtol_r+0x48>
 80a5f00:	e7aa      	b.n	80a5e58 <_strtol_r+0x58>
 80a5f02:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a5f06:	bf00      	nop
 80a5f08:	20000488 	.word	0x20000488

080a5f0c <strtol>:
 80a5f0c:	4613      	mov	r3, r2
 80a5f0e:	460a      	mov	r2, r1
 80a5f10:	4601      	mov	r1, r0
 80a5f12:	4802      	ldr	r0, [pc, #8]	; (80a5f1c <strtol+0x10>)
 80a5f14:	6800      	ldr	r0, [r0, #0]
 80a5f16:	f7ff bf73 	b.w	80a5e00 <_strtol_r>
 80a5f1a:	bf00      	nop
 80a5f1c:	200004ec 	.word	0x200004ec

080a5f20 <toupper>:
 80a5f20:	4b04      	ldr	r3, [pc, #16]	; (80a5f34 <toupper+0x14>)
 80a5f22:	681b      	ldr	r3, [r3, #0]
 80a5f24:	4403      	add	r3, r0
 80a5f26:	785b      	ldrb	r3, [r3, #1]
 80a5f28:	f003 0303 	and.w	r3, r3, #3
 80a5f2c:	2b02      	cmp	r3, #2
 80a5f2e:	bf08      	it	eq
 80a5f30:	3820      	subeq	r0, #32
 80a5f32:	4770      	bx	lr
 80a5f34:	20000488 	.word	0x20000488

080a5f38 <dynalib_user>:
 80a5f38:	080a001d 080a005d 080a0089 080a008d     ....]...........
 80a5f48:	00000000                                ....

080a5f4c <_ZTVN11ArduinoJson16StaticJsonBufferILj3000EEE>:
	...
 80a5f54:	080a0127 206f7420 54464900 76455454     '... to .IFTTTEv
 80a5f64:	48746e65 6c646e61 65207265 746e6576     entHandler event
 80a5f74:	7325203a 6164202c 203a6174 7b007325     : %s, data: %s.{
 80a5f84:	6d6f6322 646e616d 25223a22 202c2273     "command":"%s", 
 80a5f94:	74616422 253a2261 7b007d73 6d6f6322     "data":%s}.{"com
 80a5fa4:	646e616d 25223a22 202c2273 74616422     mand":"%s", "dat
 80a5fb4:	223a2261 7d227325 006e6f00 0066666f     a":"%s"}.on.off.
 80a5fc4:	646e6946 746f4279 30303033 6e694600     FindyBot3000.Fin
 80a5fd4:	6f627964 68005f74 2d6b6f6f 70736572     dybot_.hook-resp
 80a5fe4:	65736e6f 6c61632f 757a416c 75466572     onse/callAzureFu
 80a5ff4:	6974636e 76456e6f 00746e65 20452057     nctionEvent.W E 
 80a6004:	2043204c 204d204f 00202045 5c5c2222     L C O M E  .""\\
 80a6014:	0c660862 0d720a6e 6e000974 006c6c75     b.f.n.r.t..null.
 80a6024:	72757a61 6e754665 6f697463 6576456e     azureFunctionEve
 80a6034:	6552746e 6e6f7073 61486573 656c646e     ntResponseHandle
 80a6044:	76650a72 3a746e65 0a732520 61746164     r.event: %s.data
 80a6054:	7325203a 2d2d2d00 2d2d2d2d 2d2d2d2d     : %s.-----------
 80a6064:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
 80a6074:	2d2d2d2d 2d2d2d2d 6150002d 6e697372     ---------.Parsin
 80a6084:	534a2067 66204e4f 656c6961 6f430064     g JSON failed.Co
 80a6094:	6e616d6d 00203a64 6e6b6e75 436e776f     mmand: .unknownC
 80a60a4:	616d6d6f 6552646e 6e6f7073 61486573     ommandResponseHa
 80a60b4:	656c646e 6f430072 00746e75 6d657449     ndler.Count.Item
 80a60c4:	746f6e20 756f6620 5200646e 6c757365      not found.Resul
 80a60d4:	614e0074 5200656d 4300776f 69006c6f     t.Name.Row.Col.i
 80a60e4:	3a6d6574 2c732520 776f7220 6425203a     tem: %s, row: %d
 80a60f4:	6f63202c 25203a6c 71202c64 746e6175     , col: %d, quant
 80a6104:	3a797469 00642520 776f6873 426c6c41     ity: %d.showAllB
 80a6114:	7365786f 70736552 65736e6f 646e6148     oxesResponseHand
 80a6124:	0072656c 776f6853 426c6c41 7365786f     ler.ShowAllBoxes
 80a6134:	74657220 656e7275 20302064 72746e65      returned 0 entr
 80a6144:	00736569 726f6f43 72007364 203a776f     ies.Coords.row: 
 80a6154:	202c6425 3a6c6f63 00642520 4d776f68     %d, col: %d.howM
 80a6164:	52796e61 6f707365 4865736e 6c646e61     anyResponseHandl
 80a6174:	53007265 65636375 48007373 614d776f     er.Success.HowMa
 80a6184:	6620796e 656c6961 6e490064 74726573     ny failed.Insert
 80a6194:	6d657449 69616620 0064656c 6f6d6572     Item failed.remo
 80a61a4:	74496576 65526d65 6e6f7073 61486573     veItemResponseHa
 80a61b4:	656c646e 65520072 65766f6d 6d657449     ndler.RemoveItem
 80a61c4:	69616620 0064656c 54646461 52736761      failed.addTagsR
 80a61d4:	6f707365 4865736e 6c646e61 41007265     esponseHandler.A
 80a61e4:	61546464 66207367 656c6961 65730064     ddTags failed.se
 80a61f4:	61755174 7469746e 73655279 736e6f70     tQuantityRespons
 80a6204:	6e614865 72656c64 74655300 6e617551     eHandler.SetQuan
 80a6214:	79746974 69616620 0064656c 61647075     tity failed.upda
 80a6224:	75516574 69746e61 65527974 6e6f7073     teQuantityRespon
 80a6234:	61486573 656c646e 70550072 65746164     seHandler.Update
 80a6244:	6e617551 79746974 69616620 0064656c     Quantity failed.
 80a6254:	646e7562 6957656c 65526874 6e6f7073     bundleWithRespon
 80a6264:	61486573 656c646e 654e0072 65744977     seHandler.NewIte
 80a6274:	7845006d 69747369 7449676e 4e006d65     m.ExistingItem.N
 80a6284:	74497765 203a6d65 202c7325 3a776f72     ewItem: %s, row:
 80a6294:	2c642520 6c6f6320 6425203a 7571202c      %d, col: %d, qu
 80a62a4:	69746e61 203a7974 202c6425 73697845     antity: %d, Exis
 80a62b4:	676e6974 6d657449 7325203a 6e694600     tingItem: %s.Fin
 80a62c4:	67615464 65722073 6e727574 30206465     dTags returned 0
 80a62d4:	65746920 5200736d 203a776f 202c6425      items.Row: %d, 
 80a62e4:	3a6c6f43 2c642520 6e6f4320 65646966     Col: %d, Confide
 80a62f4:	3a65636e 00662520 6e6b6e55 436e776f     nce: %f.UnknownC
 80a6304:	616d6d6f 4300646e 676e6168 6c6f4365     ommand.ChangeCol
 80a6314:	0073726f 53746553 6c6f7263 7865546c     ors.SetScrollTex
 80a6324:	65530074 73694474 79616c70 74655300     t.SetDisplay.Set
 80a6334:	67697242 656e7468 57007373 6f636c65     Brightness.Welco
 80a6344:	4800656d 614d776f 4200796e 6c646e75     me.HowMany.Bundl
 80a6354:	74695765 68530068 6c41776f 786f426c     eWith.ShowAllBox
 80a6364:	55007365 74616470 61755165 7469746e     es.UpdateQuantit
 80a6374:	65530079 61755174 7469746e 64410079     y.SetQuantity.Ad
 80a6384:	67615464 65520073 65766f6d 6d657449     dTags.RemoveItem
 80a6394:	736e4900 49747265 006d6574 646e6946     .InsertItem.Find
 80a63a4:	73676154 6e694600 65744964 0000006d     Tags.FindItem...

080a63b4 <_ZTV12Adafruit_GFX>:
	...
 80a63c4:	080a1631 080a3c89 080a00a5 080a12a5     1....<..........
 80a63d4:	080a13c5 080a13e1 080a1365 080a13fb     ........e.......
 80a63e4:	080a1433 080a144f                       3...O...

080a63ec <_ZL4font>:
 80a63ec:	00000000 4f5b3e00 6b3e3e5b 1c3e6b4f     .....>[O[>>kOk>.
 80a63fc:	1c3e7c3e 3c7e3c18 7d571c18 5e1c1c57     >|>..<~<..W}W..^
 80a640c:	001c5e7f 00183c18 e7c3e7ff 241800ff     .^...<.........$
 80a641c:	e7ff0018 30ffe7db 0e063a48 29792926     .......0H:..&)y)
 80a642c:	057f4026 7f400705 5a3f2505 5a3ce73c     &@....@..%?Z<.<Z
 80a643c:	1c1c3e7f 1c1c0808 22147f3e 5f14227f     .>......>.."."._
 80a644c:	5f5f005f 017f0906 8966007f 60606a95     _.__......f..j``
 80a645c:	94606060 94a2ffa2 047e0408 7e201008     ```.......~... ~
 80a646c:	08081020 08081c2a 08082a1c 1010101e      ...*....*......
 80a647c:	0c1e0c10 38300c1e 0630383e 060e3e0e     ......08>80..>..
 80a648c:	00000000 5f000000 07000000 14000700     ......._........
 80a649c:	147f147f 2a7f2a24 08132312 49366264     ....$*.*.#..db6I
 80a64ac:	00502056 00030708 41221c00 22410000     V P......."A..A"
 80a64bc:	1c2a001c 082a1c7f 08083e08 30708000     ..*...*..>....p0
 80a64cc:	08080800 00000808 20006060 02040810     ........``. ....
 80a64dc:	4549513e 7f42003e 49720040 21464949     >QIE>.B.@.rIIIF!
 80a64ec:	334d4941 7f121418 45452710 4a3c3945     AIM3.....'EEE9<J
 80a64fc:	41314949 07091121 49494936 49494636     II1A!...6III6FII
 80a650c:	00001e29 00000014 00003440 22140800     ).......@4....."
 80a651c:	14141441 41001414 02081422 06095901     A......A"....Y..
 80a652c:	595d413e 11127c4e 497f7c12 3e364949     >A]YN|...|.III6>
 80a653c:	22414141 4141417f 49497f3e 097f4149     AAA".AAA>.IIIA..
 80a654c:	3e010909 73514141 0808087f 7f41007f     ...>AAQs......A.
 80a655c:	40200041 7f013f41 41221408 4040407f     A. @A?...."A.@@@
 80a656c:	1c027f40 047f7f02 3e7f1008 3e414141     @..........>AAA>
 80a657c:	0909097f 51413e06 097f5e21 26462919     .....>AQ!^...)F&
 80a658c:	32494949 017f0103 40403f03 201f3f40     III2.....?@@@?. 
 80a659c:	3f1f2040 3f403840 14081463 78040363     @ .?@8@?c...c..x
 80a65ac:	59610304 00434d49 4141417f 10080402     ..aYIMC..AAA....
 80a65bc:	41410020 02047f41 40040201 40404040      .AAA......@@@@@
 80a65cc:	08070300 54542000 287f4078 38384444     ..... TTx@.(DD88
 80a65dc:	28444444 28444438 5454387f 08001854     DDD(8DD(.8TTT...
 80a65ec:	1802097e 789ca4a4 0404087f 7d440078     ~......x....x.D}
 80a65fc:	40200040 7f003d40 00442810 407f4100     @. @@=...(D..A.@
 80a660c:	78047c00 087c7804 38780404 38444444     .|.x.x|...x8DDD8
 80a661c:	242418fc 24241818 087cfc18 48080404     ..$$..$$..|....H
 80a662c:	24545454 443f0404 40403c24 201c7c20     TTT$..?D$<@@ |. 
 80a663c:	3c1c2040 3c403040 28102844 90904c44     @ .<@0@<D(.(DL..
 80a664c:	64447c90 00444c54 00413608 00770000     .|DdTLD..6A...w.
 80a665c:	36410000 01020008 3c020402 3c262326     ..A6.......<&#&<
 80a666c:	61a1a11e 40403a12 54387a20 21595554     ...a.:@@ z8TTUY!
 80a667c:	41795555 78545421 54552141 54204078     UUyA!TTxA!UTx@ T
 80a668c:	0c407955 1272521e 55555539 54543959     Uy@..Rr.9UUUY9TT
 80a669c:	55395954 00585454 417c4500 7d450200     TY9UTTX..E|A..E}
 80a66ac:	45010042 29f0407c f0f02924 f0282528     B..E|@.)$)..(%(.
 80a66bc:	4555547c 54542000 0a7c547c 32497f09     |TUE. TT|T|...I2
 80a66cc:	32494949 48484832 484a3232 413a3048     III22HHH22JHH0:A
 80a66dc:	3a7a2141 78204042 a0a09d00 4444397d     A!z:B@ x....}9DD
 80a66ec:	403d3944 3c3d4040 2424ff24 43497e48     D9=@@@=<$.$$H~IC
 80a66fc:	fc2f2b66 09ff2b2f c020f629 03097e88     f+/./+..). ..~..
 80a670c:	79545420 44000041 4830417d 38324a48      TTyA..D}A0HHJ28
 80a671c:	7a224040 0a0a7a00 190d7d72 29267d31     @@"z.z..r}..1}&)
 80a672c:	26282f29 26292929 404d4830 08083820     )/(&)))&0HM@ 8..
 80a673c:	08080808 2f380808 baacc810 3428102f     ......8/..../.(4
 80a674c:	7b0000fa 14080000 2222142a 08142a14     ...{....*."".*..
 80a675c:	005500aa aa55aaaa 0000aa55 1000ff00     ..U...U.U.......
 80a676c:	00ff1010 ff141414 ff101000 1010ff00     ................
 80a677c:	14f010f0 00fc1414 00f71414 ff0000ff     ................
 80a678c:	1414ff00 14fc04f4 1f101714 101f1010     ................
 80a679c:	1414141f 1010001f 0000f010 101f0000     ................
 80a67ac:	1f101010 10101010 000010f0 1010ff00     ................
 80a67bc:	10101010 ff101010 00000010 000014ff     ................
 80a67cc:	00ff00ff 17101f00 04fc0000 171414f4     ................
 80a67dc:	14141710 00f404f4 f700ff00 14141414     ................
 80a67ec:	f7141414 1414f700 10141714 1f101f10     ................
 80a67fc:	f4141414 f0101014 0000f010 001f101f     ................
 80a680c:	141f0000 fc000000 f0000014 1010f010     ................
 80a681c:	14ff10ff 14ff1414 1f101010 00000000     ................
 80a682c:	ffff10f0 f0ffffff f0f0f0f0 00ffffff     ................
 80a683c:	00000000 0f0fffff 380f0f0f 44384444     ...........8DD8D
 80a684c:	3e2a2a7c 02027e14 7e020606 63027e02     |**>.~.....~.~.c
 80a685c:	63414955 3c444438 207e4004 0206201e     UIAc8DD<.@~ . ..
 80a686c:	9902027e 99a5e7a5 2a492a1c 01724c1c     ~........*I*.Lr.
 80a687c:	4a304c72 30304d4d 30487848 465a62bc     rL0JMM00HxH0.bZF
 80a688c:	49493e3d 017e0049 2a7e0101 2a2a2a2a     =>III.~...~*****
 80a689c:	445f4444 4a514044 44404044 0040514a     DD_DD@QJD@@DJQ@.
 80a68ac:	0301ff00 00ff80e0 6b080800 1236086b     ...........kk.6.
 80a68bc:	06362436 060f090f 18180000 10000000     6$6.............
 80a68cc:	40300010 000101ff 1e01011f 171d1900     ..0@............
 80a68dc:	3c3c0012 00003c3c 00000000              ..<<<<......

080a68e8 <CSWTCH.215>:
 80a68e8:	0000012c 00000018 000001f4 0000012c     ,...........,...
 80a68f8:	00000050                                P...

080a68fc <_ZTV18Adafruit_NeoMatrix>:
	...
 80a6904:	080a2a49 080a2a61 080a1631 080a3c89     I*..a*..1....<..
 80a6914:	080a2a73 080a12a5 080a13c5 080a13e1     s*..............
 80a6924:	080a1365 080a13fb 080a2a11 080a144f     e........*..O...

080a6934 <_ZL6gamma5>:
 80a6934:	03020100 0b090705 1814110e 2e28221d     ............."(.
 80a6944:	4f463d36 7c6f6459 b6a69789 ffebd9c7     6=FOYdo|........

080a6954 <_ZL6gamma6>:
 80a6954:	03020100 08060504 0d0b0a09 1312100e     ................
 80a6964:	1b191715 2522201d 302d2a27 3e3a3733     ..... "%'*-037:>
 80a6974:	4d494541 5f5b5652 746e6964 8b857f79     AEIMRV[_dinty...
 80a6984:	a49d9791 c0b9b2ab ded6cfc7 fff7eee6     ................

080a6994 <_ZL26boxLedOffsetByColumnBottom>:
 80a6994:	00000000 00000008 0000000f 00000016     ................
 80a69a4:	0000001f 00000027 0000002e 00000035     ....'.......5...

080a69b4 <_ZL5smile>:
 80a69b4:	381c0000 00004422 066003c0 0000f81f     ...8"D....`.....

080a69c4 <_ZL23boxLedOffsetByColumnTop>:
 80a69c4:	00000000 00000004 00000007 0000000b     ................
 80a69d4:	0000000f 00000012 00000016 00000019     ................
 80a69e4:	0000001f 00000023 00000026 0000002a     ....#...&...*...
 80a69f4:	0000002e 00000031 00000035 00000038     ....1...5...8...

080a6a04 <_ZL4fire>:
 80a6a04:	70e26410 6e490038 696c6176 52202e64     .d.p8.Invalid. R
 80a6a14:	203a776f 202c6425 3a6c6f43 0a642520     ow: %d, Col: %d.
 80a6a24:	49204800 65720020 72670064 006e6565     .H I .red.green.
 80a6a34:	65756c62 67616d00 61746e65 61726f00     blue.magenta.ora
 80a6a44:	0065676e 6e617963 69687700 70006574     nge.cyan.white.p
 80a6a54:	6c707275 00000065                       urple...

080a6a5c <_ZL25boxLedWidthByColumnBottom>:
 80a6a5c:	00000007 00000006 00000006 00000007     ................
 80a6a6c:	00000007 00000006 00000006 00000007     ................

080a6a7c <_ZL22boxLedWidthByColumnTop>:
 80a6a7c:	00000004 00000003 00000004 00000003     ................
 80a6a8c:	00000003 00000004 00000003 00000004     ................
 80a6a9c:	00000004 00000003 00000004 00000003     ................
 80a6aac:	00000003 00000004 00000003 00000004     ................

080a6abc <_ZTV8SPIClass>:
	...
 80a6ac4:	080a3a99 080a3a9b 66006e6c 6f63006e     .:...:..ln.fn.co
 80a6ad4:	64006564 69617465 0a0d006c 31302500     de.detail....%01
 80a6ae4:	00207530 2c00205d 29280020 2000203a     0u .] ., .(): . 
 80a6af4:	6f63005b 3d206564 69250020 74656400     [.code = .%i.det
 80a6b04:	736c6961 00203d20 64756162 72655300     ails = .baud.Ser
 80a6b14:	006c6169 53425355 61697265 7400316c     ial.USBSerial1.t
 80a6b24:	00657079 61726170 6d63006d 64690064     ype.param.cmd.id
 80a6b34:	646e6800 72747300 6966006d 6c00746c     .hnd.strm.filt.l
 80a6b44:	61006c76 61486464 656c646e 65720072     vl.addHandler.re
 80a6b54:	65766f6d 646e6148 0072656c 6d756e65     moveHandler.enum
 80a6b64:	646e6148 7372656c 4f534a00 7274534e     Handlers.JSONStr
 80a6b74:	4c6d6165 6148676f 656c646e 70610072     eamLogHandler.ap
 80a6b84:	6f6e0070 7400656e 65636172 666e6900     p.none.trace.inf
 80a6b94:	6177006f 65006e72 726f7272 6e617000     o.warn.error.pan
 80a6ba4:	61006369 5a006c6c 302b2500 253a6433     ic.all.Z.%+03d:%
 80a6bb4:	00753230 252d5925 64252d6d 3a482554     02u.%Y-%m-%dT%H:
 80a6bc4:	253a4d25 007a2553 74637361 00656d69     %M:%S%z.asctime.

080a6bd4 <_ZTVSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE>:
	...
 80a6bdc:	080a3ffd 080a4003 080a4019 080a400f     .?...@...@...@..
 80a6bec:	080a3fff                                .?..

080a6bf0 <_ZTV9IPAddress>:
	...
 80a6bf8:	080a450f 080a4501 080a4503              .E...E...E..

080a6c04 <_ZTV9USBSerial>:
	...
 80a6c0c:	080a4579 080a45bd 080a4597 080a3c89     yE...E...E...<..
 80a6c1c:	080a4591 080a457b 080a4583 080a45b7     .E..{E...E...E..
 80a6c2c:	080a458b 080a4575                       .E..uE..

080a6c34 <_ZTV11USARTSerial>:
	...
 80a6c3c:	080a46b1 080a46d5 080a46e1 080a3c89     .F...F...F...<..
 80a6c4c:	080a46bd 080a46c9 080a46c3 080a46cf     .F...F...F...F..
 80a6c5c:	080a46b3 080a46b7                       .F...F..

080a6c64 <_ZTV7TwoWire>:
	...
 80a6c6c:	080a47df 080a4829 080a4801 080a47e1     .G..)H...H...G..
 80a6c7c:	080a4809 080a4811 080a4819 080a4821     .H...H...H..!H..

080a6c8c <_ZTVN5spark9WiFiClassE>:
	...
 80a6c94:	080a4863                                cH..

080a6c98 <_ctype_>:
 80a6c98:	20202000 20202020 28282020 20282828     .         ((((( 
 80a6ca8:	20202020 20202020 20202020 20202020                     
 80a6cb8:	10108820 10101010 10101010 10101010      ...............
 80a6cc8:	04040410 04040404 10040404 10101010     ................
 80a6cd8:	41411010 41414141 01010101 01010101     ..AAAAAA........
 80a6ce8:	01010101 01010101 01010101 10101010     ................
 80a6cf8:	42421010 42424242 02020202 02020202     ..BBBBBB........
 80a6d08:	02020202 02020202 02020202 10101010     ................
 80a6d18:	00000020 00000000 00000000 00000000      ...............
	...

080a6d9c <__sf_fake_stdin>:
	...

080a6dbc <__sf_fake_stdout>:
	...

080a6ddc <__sf_fake_stderr>:
	...
 80a6dfc:	00000043                                         C.

080a6dfe <link_const_variable_data_end>:
	...

080a6e00 <link_constructors_location>:
 80a6e00:	080a1189 	.word	0x080a1189
 80a6e04:	080a16b1 	.word	0x080a16b1
 80a6e08:	080a29d5 	.word	0x080a29d5
 80a6e0c:	080a2c61 	.word	0x080a2c61
 80a6e10:	080a35ed 	.word	0x080a35ed
 80a6e14:	080a3ad9 	.word	0x080a3ad9
 80a6e18:	080a3e29 	.word	0x080a3e29
 80a6e1c:	080a3e39 	.word	0x080a3e39
 80a6e20:	080a3ea9 	.word	0x080a3ea9
 80a6e24:	080a486d 	.word	0x080a486d
 80a6e28:	080a4929 	.word	0x080a4929
 80a6e2c:	080a496d 	.word	0x080a496d
 80a6e30:	080a49ed 	.word	0x080a49ed
 80a6e34:	080a4a71 	.word	0x080a4a71
 80a6e38:	080a4b35 	.word	0x080a4b35
 80a6e3c:	080a4bf9 	.word	0x080a4bf9
